<%args>
	$tourn
	$tourn_settings
	$person
	$subject        => undef
	$content        => undef
	$email_id       => undef
	$everybody      => undef
	$everybody_plus => undef
	$diodirs        => undef
	$judge_short    => undef
	$money_short    => undef
	$tba            => undef
	$hidden         => undef
</%args>
<%init>

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	my $now = DateTime->now(time_zone => $tz);

	my $sent_to;
	my @recipients;
	my @emails;
	my @schools;

	if ($tourn_settings->{nsda_nats}) {

		if ($ARGS{"unclaimed_entries"}) {

			Tab::School->set_sql( unclaimed => "
				select school.*
				from school, entry
				where school.id = entry.school
					and school.tourn = ?
					and entry.unconfirmed = 1
					and entry.dropped != 1
				and not exists (
					select es.id
					from entry_setting es
					where es.entry = entry.id
					and es.tag = 'rejected_by'
				)
				and not exists (
					select evs.id
					from event_setting evs
					where evs.event = entry.event
					and (evs.tag = 'supp' OR evs.tag = 'conn')
				)
			");

			push @schools, Tab::School->search_unclaimed($tourn->id);
			$sent_to .= "\n" if $sent_to;
			$sent_to .= "Schools with unclaimed entries ";

		}

		if ($ARGS{"noncomplete_entries"}) {

			Tab::School->set_sql( incomplete => "
				select school.*
				from school, entry, entry_student es
				where school.id = entry.school
					and school.tourn = ?
					and entry.id     = es.entry
					and entry.active = 1

					and not exists (
						select es.id
						from entry_setting es
						where es.entry = entry.id
						and es.tag = 'status'
						and es.value = 'complete'
					)
					and not exists (
						select evs.id
						from event_setting evs
						where evs.event = entry.event
						and evs.tag = 'usa_wsdc'
					)
			");

			push @schools, Tab::School->search_incomplete($tourn->id);

			my $dbh = Tab::DBI->db_Main();

			my $sth = $dbh->prepare("
				select school.id, rf.value_text, student.id
				from (school, entry, entry_student es, student, chapter, event, event_setting usa)
					left join school_setting rf
						on rf.school = school.id
						and rf.tag = 'release_forms'
				where event.tourn = ?
					and event.id = entry.event
					and entry.active = 1
					and entry.id = es.entry
					and es.student = student.id
					and student.chapter = chapter.id
					and chapter.id = school.chapter
					and school.tourn = event.tourn
					and event.id = usa.event
					and usa.tag = 'usa_wsdc'
			");

			$sth->execute($tourn->id);
			my %school_forms;
			my %out = map {$_->id => 1} @schools;
			my %dinged;

			while (
				my ($school_id, $rf_json, $student_id) = $sth->fetchrow_array()
			) {
				next if $out{$school_id};
				next if $dinged{$school_id};

				unless ($school_forms{$school_id}) {
					$school_forms{$school_id} = eval {
						return JSON::decode_json($rf_json);
					};
				}

				unless ($school_forms{$school_id}{$student_id}) {
					$dinged{$school_id}++;
				}
			}

			foreach my $school_id (keys %dinged) {
				push @schools, Tab::School->retrieve($school_id);
			}

			$sent_to .= "\n" if $sent_to;
			$sent_to .= "Schools with incomplete entries ";
		}

		if ($ARGS{"noncomplete_judges"}) {

		    Tab::School->set_sql( incomplete => "
				select school.id, count(judge.id)
				from school, judge
				where school.id = judge.school
					and school.tourn = ?
					and school.chapter > 0
					and exists (
						select js.id
						from judge_setting js
						where js.tag = 'incomplete'
						and js.judge = judge.id
					)
				group by school.id
			");

			push @schools, Tab::School->search_incomplete($tourn->id);
			$sent_to .= "\n" if $sent_to;
			$sent_to .= "Schools with incomplete judges";
		}
	}

	my @empts;
	my %empties;

	unless (
		$ARGS{'waitlist_only'}
		|| $ARGS{"everybody_plus"}
	) {
		Tab::School->set_sql(empties => "
			select school.*
				from school
				where tourn = ?
				and not exists (
					select entry.*
					from entry
					where entry.school = school.id
					and entry.active = 1
				)
				and not exists (
					select judge.*
					from judge
					where judge.school = school.id
					and judge.active = 1
				)
		");

		@empts = Tab::School->search_empties($tourn->id);
		%empties = map {$_->id => $_} @empts;
	}

	if ($diodirs) {
		$sent_to .= "Diocesan Moderators ";
   		foreach my $region (
			$m->comp("/funclib/tourn_regions.mas", tourn => $tourn)
		) {
      	   	push @recipients, $region->admins;
		}
	}

	if ($everybody_plus) {
		$sent_to .= "All Registered Schools ";
		push @schools, $tourn->schools;
	}

	Tab::School->set_sql( active => "
		select school.*
		from school, entry
		where school.tourn = ?
			and school.id = entry.school
			and entry.active = 1
	");

	if ($everybody) {
		$sent_to .= "All Registered Schools With Entries ";
		push @schools, Tab::School->search_active($tourn->id);
	}

	if ($ARGS{"not_checked_in"}) {
		push @schools, $tourn->schools(onsite => 0);
		$sent_to .= "Schools not checked in ";
	}

	if ($judge_short) {

		$sent_to .= " Schools short on judges ";

		if ($tourn_settings->{"nsda_nats"}) {

			$m->comp("/register/judge/nsda_judge_status.mhtml",
				tourn          => $tourn,
				tourn_settings => $tourn_settings,
				return         => 1
			);

			Tab::School->set_sql(short_judging => "

				select distinct school.*
				from school, school_setting
					where school.tourn = ?
					and school_setting.school = school.id
					and school_setting.tag = 'judging_unmet'

					and exists (
						select entry.id
						from entry
						where entry.school = school.id
						and entry.active = 1
					)
			");

			push @schools, Tab::School->search_short_judging($tourn->id);

		} else {

			my @categories = $tourn->categories;

			foreach my $school ($tourn->schools) {

				my $short;

				foreach my $category (@categories) {

					my ($uncovered, $overage) = $m->comp(
						"/funclib/judgemath/uncovered_burden_by_category.mas",
						category => $category,
						school   => $school
					);

					$short++ if $uncovered;
					last if $short;
				}

				next unless $short;
				push @schools, $school;
			}
		}
	}

	my %school_balances;

	if ($money_short || $ARGS{"invoice_short"}) {

		$sent_to .= " Schools with positive balances " if $money_short;
		$sent_to .= " Schools with uninvoiced balances " if $ARGS{"invoice_short"};

		%school_balances = $m->comp(
			"/funclib/balances.mas",
				tourn          => $tourn,
				tourn_settings => $tourn_settings,
				person         => $person
		);

		foreach my $school_id (keys %school_balances) {

			my $yup;

			if ($money_short && $school_balances{$school_id}{"balance"} > 0) {
				$yup++;
			}
			if ($ARGS{"invoice_short"} && $school_balances{$school_id}{"uninvoiced"} > 0) {
				$yup++;
			}

			if ($yup) {
				push @schools, Tab::School->retrieve($school_id);
			}
		}
	}

	if ($tba) {
		$sent_to .= "Schools with TBA entries at ";
		push @schools, $m->comp("/funclib/tourn_school_tba.mas", tourn => $tourn);
	}

	unless ($everybody || $judge_short || $tba) {

		my $event_done;
		my %send_keys = ();

		foreach my $event ($tourn->events) {

			next unless $ARGS{"event_".$event->id};

			unless ($event_done++) {
				$sent_to .= " Schools registered with entries in: ";
			}

			my $waitlist;
			$waitlist++ if $ARGS{"wl_".$event->id};

			$sent_to .= $event->name."\n";

			push @schools, $m->comp(
				"/funclib/event_schools.mas",
				event    => $event,
				waitlist => $waitlist
			);
		}
	}

	if ($ARGS{'waitlist_only'}) {

		Tab::School->set_sql( waitlist_only => "
			select school.*
			from (school, entry)
			where school.tourn = ?
			and school.id = entry.school
			and entry.waitlist = 1
			and entry.unconfirmed = 0
			and entry.dropped = 0
			and not exists (
				select e2.id
				from entry e2
				where e2.school = school.id
				and e2.waitlist = 0
				and e2.dropped  = 0
				and e2.unconfirmed = 0
			)
		");

		$sent_to .= " Schools with only waitlisted entries ";
		push @schools, Tab::School->search_waitlist_only($tourn->id);
	}

	my $balance_log;

	foreach my $category ($tourn->categories) {

		foreach my $jpool ($category->jpools) {

			if ($ARGS{"incomplete_jpool_".$jpool->id}) {

				my $tag = $jpool->setting('paradigm_form');
				next unless $tag;

				Tab::Judge->set_sql( no_paradigm => "
					select judge.*
					from judge, jpool_judge
					where judge.id = jpool_judge.judge
					and judge.active = 1
					and jpool_judge.jpool = ?
					and not exists (
						select js.id
						from judge_setting js
						where js.judge = judge.id
						and js.tag = 'form_complete_$tag'
					)
				");

				my @judges = Tab::Judge->search_no_paradigm($jpool->id);

				foreach my $judge (@judges) {
					$balance_log .= "\n" if $balance_log;
					$balance_log .= "Sent to ".$judge->first." ".$judge->last;

					push @emails, $m->comp("/funclib/judge_follower.mas",
						judge       => $judge->id,
						emails      => 1,
						person_only => 1
					);
				}

				$sent_to .= "<br />" if $sent_to;
				$sent_to .= "Sent to ".$jpool->name." judges without a completed paradigm\n";
			}

			if ($ARGS{"jpool_".$jpool->id}) {

				my @jpools = $m->comp("/funclib/judge_follower.mas",
					jpool       => $jpool->id,
					emails      => 1,
					person_only => 1
				);

				push @emails, @jpools;

				$balance_log .= "\n" if $balance_log;
				$balance_log .= "Sent to ".scalar @jpools." judges in judge pool ".$jpool->name;
				$sent_to .= "<br />" if $sent_to;
				$sent_to .= $jpool->name." judges\n";
			}
		}

		next unless $ARGS{"category_".$category->id};

		$sent_to .= $category->name." judges\n";

		my @categories = $m->comp("/funclib/judge_follower.mas",
			category    => $category->id,
			emails      => 1,
			person_only => 1
		);

		push @emails, @categories;

		$balance_log .= "\n" if $balance_log;
		$balance_log .= "Sent to ".scalar @categories." judges in judge pool ".$category->name;
		$sent_to .= "<br />" if $sent_to;
		$sent_to .= $category->name." judges\n";
	}

	my %done;

	my %tourn_contacts = $m->comp("/funclib/tourn_contacts.mas", tourn => $tourn);

	foreach my $school (sort {$a->name cmp $b->name} @schools) {

		next if $done{$school->id}++;
		next if $empties{$school->id};

		if (%school_balances) {
			$balance_log .= "\n" if $balance_log;
			$balance_log .= "Sending emails to ".$school->name." with balance ".$school_balances{$school->id}{"balance"};
		} else {
			$balance_log .= "\n" if $balance_log;
			$balance_log .= "Sending emails to ".$school->name;
		}

		if ($tourn_settings->{nsda_nats}) {
			$balance_log .= " in ".$school->state;
		}

		push @emails, keys %{$tourn_contacts{$school->id}};
	}

	unless ($ARGS{"nosend"} || @recipients || @emails) {

		my $err = "The categories or checkboxes you have selected did not have any recipients.";
		$err .= "It's possible you didn't check boxes, or that the categories you chose ";
		$err .= "have no active entries.";

		$m->comp("/funclib/abort.mas", message => $err);
	}

	my $email;
	my $sender;

	if ($ARGS{"from"} && (not defined $ARGS{"nosend"})) {

		$sender = Tab::Person->retrieve($ARGS{"from"});

		my $description = "Email subject $subject sent as ".$sender->email." to $sent_to";

	    $m->comp("/funclib/log.mas",
			type        => 'tabbing',
			tourn       => $tourn->id,
			person      => $person->id,
			description => $description
		);

	} else {

		$sender = $person;
	}

	unless ($content) {
		my $err = "The email had no message body.  Try again,";
		$m->redirect("/register/emails/compose.mhtml&err=$err");
	} else {
		$content = $m->comp("/funclib/save_editor.mas", text => $content);
	}

	$hidden = 0 unless $hidden;

	if ($email_id) {

		$email = Tab::Email->retrieve($email_id);

		#If the mail has been sent already we clone instead of overwriting

		if ($email->sent_to && (not defined $ARGS{'nosend'}) ) {

			$email = $email->copy({
				sent_at => $now
			});

			$email->sender($sender);
		}

		$email->subject($subject);
		$email->metadata($balance_log);
		$email->hidden($hidden);
		$email->content($content);

		$email->update();

	} else {

		$email = Tab::Email->create({
			subject  => $subject,
			content  => $content,
			sent_at  => $now,
			tourn    => $tourn->id,
			sender   => $sender,
			hidden   => $hidden,
			metadata => $balance_log
		});
	}


	my $msg;

	unless ($ARGS{"nosend"}) {

		if ($ARGS{"all_admins"}) {
			push @recipients, $m->comp("/funclib/tourn_admins.mas", tourn => $tourn);
		} else {
			push @recipients, $m->comp("/funclib/tourn_admins.mas", tourn => $tourn, "owner" => "true");
		}

		my %seen;
		foreach my $recipient (@recipients) {
			next if $seen{$recipient->email}++;
			push @emails, $recipient->email unless $recipient->no_email;
		}

		$content .="\n-----------------------------<br />\n";
		$content .=" Tournament : ".$tourn->name." <br />\n";
		$content .=" Email sent to:\n";
		$content .=" $sent_to\n\n ";

		if ($email) {
			$email->sent_to($sent_to);
			$email->update();
		}

		$m->comp( "/funclib/send_email.mas",
			from    => $sender,
			array   => \@emails,
			subject => $subject,
			body    => $content
		);

		$msg = "This message has been sent.";

	} else {

		$msg = "This message has been saved but NOT sent.";
	}

	$m->redirect("/register/emails/index.mhtml?email_id=".$email->id."&msg=$msg");

</%init>
