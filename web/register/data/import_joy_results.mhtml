<%args>
	$tourn
	$tourn_settings
	$person
	$person_settings
	$from  => undef
</%args>
<%init>
	use POSIX;

	use Text::CSV::Encoded;

	my $csv = Text::CSV::Encoded->new ({
		sep_char     => ',',
		encoding_in  => "iso-8859-1", # the encoding comes into   Perl
		encoding_out => "iso-8859-1",     # the encoding comes out of Perl
	});

    use Tab::NSDA::Login;
    use Tab::NSDA::Person;
    use Tab::NSDA::PersonSchool;
    use Tab::NSDA::MemberSchool;

	my %ignore_me = map {$_ => 1} ( 
		"fees",
		"judcommit",
		"outcomes",
		"pairopts",
		"restrictions",
		"roomavails",
		"rsvps",
		"seeds",
		"seqstrs",
		"sweeps",
		"team4s",
		"todos",
		"actions",
		"bag"
	);

	my %fucked_joy_rounds = (
		1  => "prelim",
		2  => "prelim",
		3  => "prelim",
		4  => "prelim",
		5  => "prelim",
		11 => "prelim",
		12 => "prelim",
		13 => "prelim",
		14 => "prelim",
		15 => "prelim",
		17 => "runoff",
		10 => "elim",
		9  => "elim",
		6  => "elim",
		7  => "elim",
		16 => "elim",
		8  => "final"
	);

	Tab::Ballot->set_sql( "fakes" => "
		select ballot.*
		from ballot, score
		where ballot.panel = ? 
		and ballot.id = score.ballot
		and not exists (
			select b2.id
			from ballot b2, score s2
			where b2.judge = ballot.judge
			and b2.panel = ballot.panel
			and b2.id = s2.ballot
			and s2.tag = 'rank'
			and s2.value != 9
		)
		and not exists (
			select b3.id
			from ballot b3, score s3
			where b3.judge = ballot.judge
			and b3.panel = ballot.panel
			and b3.id = s3.ballot
			and s3.tag = 'ballot'
		)
	");

    # Get the upload and create the file handle.
    my $req = Apache2::Request->new($r);
    my @csv_handles = $r->upload; 

    my $csv_file = $req->upload($csv_handles[0]);
    my $io = $csv_file->io;

    my @lines = <$io>;
    my @all_lines;

	my $now = DateTime->now();
	my $this_year = $now->year;
	$this_year++ if $now->month > 7;

    foreach (@lines) { 
        $_ =~ s/[\r]+/\n/g;
        $_ =~ s/[\r\n]+/\n/g;
        $_ =~ s/[\n]+/\n/g;
        push @all_lines, split (/\n/, $_);
    }

	my @results;
	my @changes;

	my %segments;

	my $next_header;
	my $segment_key;
	my $segment_label;

	my $district_id = $tourn_settings->{"nsda_district"};
	my $district = Tab::District->retrieve($district_id);

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	# I cannot believe I have to worry about the order this file is in but in
	# some cases the order of the data actually friggin matters.  I was Hitler
	# in a past life or something. 

	my $order = 0;

	foreach my $line (@lines) { 
		chomp $line;
		if ($line eq '!#:----------:#!') { 
			$next_header++;
		} elsif ($next_header) { 
			($segment_label, $segment_label) = split(':', $line);
			undef $next_header;
		} elsif ($ignore_me{$segment_label}) { 
			# DO NOTHING I TELL YOU.  NOTHING.
		} else { 
			$segments{$segment_label}{$order++} = $line;
		}
	}

	my %tourn_settings;

	foreach my $linekey (sort keys %{$segments{"TRN"}}) { 
		my $line = $segments{"TRN"}{$linekey};
		my ($key, $value) = split("=", $line);
		next unless $value;
		$tourn_settings{$key} = $value;
		$ignore_me{"TRN"}++;
	}

	Tab::TournSite->set_sql( delete_blanks => "
		delete from tourn_site
		where tourn = ? 
		and site = 0
	");

	Tab::TournSite->sql_delete_blanks->execute($tourn->id);

	my @sites = $tourn->sites;

	my $default_site;
	$default_site = shift @sites if @sites;

	my $default_weekend_site;

	unless ($default_site > 0) { 

		$default_site = Tab::Site->create({ 
			name => $tourn->name." site",
			host => $person->id
		});

		Tab::TournSite->create({
			tourn => $tourn->id,
			site  => $default_site->id
		});

	}

	undef $segments{"actions"};
	undef $segments{"bag"};
	undef $segments{"fees"};
	undef $segments{"TRN"};

	my %judge_pools;

	#JUDGE CATEGORIES OR POOLS OR SOMESUCH.
	foreach my $linekey (sort keys %{$segments{"judprefs"}}) { 
		my $line = $segments{"judprefs"}{$linekey};

		next unless $csv->parse($line);

		my (
			$judge_id, $category
		) = $csv->fields();

		next if $judge_id eq "Judge ID";
		$judge_id = int($judge_id);
		$category = int($category);

		$judge_pools{$judge_id}{$category}++;

	}

	$ignore_me{"judprefs"}++;

	my $counter = 0;
	my %event_categories;

	$m->print('<div class="main">');

	$m->print("<h5>Importing for district ".$district->code." ".$district->name." </h5>") if $district;

	foreach my $judge (sort keys %judge_pools) { 

		my $standing_category;

		foreach my $event (sort keys %{$judge_pools{$judge}}) { 

			next if $event eq "Event ID";

			unless ($event_categories{$event}) { 

				unless ($standing_category) { 
					$counter++;
					$standing_category = $counter;
				}

				$event_categories{$event} = $standing_category;
			} 
		}
	}

	foreach my $category (1 .. $counter) { 

		my @events;

		foreach my $key (sort keys %event_categories) { 
			push @events, $event_categories{$key};
		}
	}

	my @all_events = $tourn->events;

	my %events;

	foreach my $test (@all_events) { 
		my $jot_id = int($test->setting('jot_id'));
		$events{$jot_id} = $test;
	}

	my $found = 0;
	my $created = 0;
	my %categories;
	my %event_web_ids;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing events</h6>");

	my %weekends;
	my %sites; 
	my %event_site;
	my %event_house_section;
	my %section_round_type;

	my $house = $tourn->events( abbr => "HOU")->first;
	my %house_sections;
	my $house_section_counter;

	$m->print("<p class='semibold marleft'>");

	#EVENTS CATEGORIES
	LINE:
	foreach my $linekey (sort keys %{$segments{"events"}}) { 
		my $line = $segments{"events"}{$linekey};

		next unless $csv->parse($line);

		my (
			$internal_event_id, $event_name, $attributes, $entry_fee, $pattern, 
			$duration, $copies, $complete, $method, $drop_fee, $team_count,
			$entry_blank, $drop_fee2, $drop_fee3, $drop_fee4, $speaker_goal,
			$flags, $min_points, $max_points, $nfl, $tab_method, $rows, 
			$columns, $event_id, $performance, $web_type, $ballot_style, 
			$type, $prelim_method
		) = $csv->fields();

		next LINE if $internal_event_id eq "Event ID";

		# Fucking JOT inconsistency
		$event_name = "US Extemp" if $event_name eq "Domestic Extemp";
		$entry_blank = "USX" if $entry_blank eq "DX";

		$internal_event_id = int($internal_event_id);

		if (index($attributes, "CONGRESS") != -1) {
			$house_sections{$internal_event_id} = $event_name;
			$event_web_ids{$internal_event_id} = "HOUSE";

			$events{"HOUSE"} = $house;
			$event_id = -1;
		} else { 
			$event_web_ids{$internal_event_id} = $event_id;
		}

		my $event;

		if ($event_id < 0) { 

			$house_section_counter++;
			my $section_number = $house_section_counter;
			$event_house_section{$internal_event_id} = $section_number;

			$event = $house;

			$m->print("<span class='greentext third semibold'>Congress: $event_name map to ".$house->abbr."</span>");

		} else {

			if ($events{$event_id}) { 

				$found++;
				$m->print("<span class='third greentext'>Found ".$events{$event_id}->abbr."</span>");

				my $category_code = $event_categories{$internal_event_id};
				$categories{$category_code} = $events{$event_id}->category;
				$categories{$category_code}->setting("jot_id", $category_code);

				$events{$event_id}->setting('code_style', "numbers");
				next LINE;
			}

			$m->print("<span class='half'>Searching for $event_name by name:");

			if ($tourn_settings{"NFL"} == 1) { 

				$event = Tab::Event->search(
					tourn => $tourn->id,
					abbr  => $entry_blank
				)->first;

			} else {

				$event = Tab::Event->search(
					tourn => $tourn->id,
					name  => $event_name
				)->first;

				unless ($event) { 
					$event = Tab::Event->search(
						tourn => $tourn->id,
						abbr => $entry_blank
					)->first;
				}
			
			}

			if ($event) { 
				$found++;
				$m->print("Found </span>");
			}

			my $category;

			unless ($event) { 

				unless ($tourn_settings->{"nsda_district"}) { 
				
					$m->print("Nope.  Creating new:");

					my $category_code = $event_categories{$internal_event_id};
					$category = $categories{$category_code};

					unless ($category) { 
						
						$category = Tab::Category->create({
							tourn => $tourn->id,
							name  => "Judges ".$category_code,
							abbr  => "J".$category_code,
						});

						$category->setting('jot_id', $category_code);
						$categories{$category_code} = $category;
					}

					my ($team, $type) = split(",", $attributes);

					if ($type eq "CONGRESS") { 
						$house_sections{$internal_event_id} = $event_name;
						$type = "congress";
					} elsif ($type eq "PAIR") { 
						$type = "debate";
					} elsif ($type eq "SECTION") { 
						$type = "speech";
					}

					$entry_fee = $entry_fee / 100;

					$event = Tab::Event->create({
						name     => $event_name,
						abbr     => $entry_blank,
						tourn    => $tourn->id,
						category => $category->id,
						type     => $type,
						fee      => $entry_fee
					});

					if ($team eq "TEAM") { 
						$event->setting("min_entry", 2);
						$event->setting("max_entry", 2);
					} else {
						$event->setting("min_entry", 1);
						$event->setting("max_entry", 1);
					}

					$created++;
					
					$m->print("</span>");

				}
			}
		}

		if ($event) { 
		
			$event->setting('code_style', "numbers");

			my $category = $event->category;

			my $category_code = $event_categories{$internal_event_id};
			$categories{$category_code} = $category;
			$category->setting("jot_id", $category_code);

			$event->setting("jot_id", $event_id);
			$events{$event_id} = $event;

			if ($event->setting('weekend')) { 

				my $weekend = Tab::Weekend->retrieve($event->setting("weekend"));

				if ($weekend) { 

					$weekends{$weekend->id} = $weekend;

					my $site = $weekend->site;

					if ($site && $site > 0) { 

						unless ($default_weekend_site) { 
							$default_site = $site;
							$default_weekend_site++;
						}

						$event_site{$event_id} = $site;
						$sites{$site->id} = $site;
					} 
				}

			}

			if ($event->type eq "congress") { 
				foreach ($event->rounds()) { 
					$_->delete();
				}
			}

		} else { 
			$m->print("<span class='semibold redtext full'> I was not able to find ");
			$m->print("or create $entry_blank: $event_name in Tabroom.</span>");
		}

	}

	$m->print("</p>");

	my $unpooled = $tourn->categories(
		abbr => "XX",
		name => "Unpooled Judges"
	)->first;

	unless ($unpooled) { 
		$unpooled = Tab::Category->create({
			tourn => $tourn->id,
			abbr  => "XX",
			name  => "Unpooled Judges"
		});
	}

	# Fill in any un-sited events
	foreach my $event_id (sort keys %events) { 
		unless ($event_site{$event_id}) { 
			$event_site{$event_id} = $default_site;
			$sites{$default_site->id} = $default_site;
		}
	}

	undef $segments{"events"};
	$ignore_me{"events"}++;

	$m->print("<p class='semibold'>$found events found, $created events created</p>");

	$m->print("<h6 class='redtext semibold'>Importing schools</h6>");

	my %schools = map{ $_->setting("jot_id") => $_} $tourn->schools;
	my %school_web_ids;

	$found = 0;
	$created = 0;

	LINE:
	foreach my $linekey (sort keys %{$segments{"schools"}}) { 

		my $line = $segments{"schools"}{$linekey};

		next unless $csv->parse($line);

		my (
			$school_id, $code, $name, $coach, $squad_count, 
			$arrived, $division, $city, $phone, $fax, $coach_phone, 
			$notes, $status, $addr1, $addr2, $state, $zip, $email, 
			$flags, $district_code, $region, $other_coaches, $trophy_points, 
			$web_school_id, $cell_phone, $alt_email
		) = $csv->fields();

		next LINE if $school_id eq "School ID";

		$web_school_id = int($web_school_id);
		$found++ if $schools{$web_school_id};

		$school_id = int($school_id);
		$school_web_ids{$school_id} = $web_school_id;

		$m->print("<div class='full nospace bordertop borderbottom'>");
		$m->print("<span class='semibold half'>Importing school $name: </span>");

		if ($schools{$web_school_id}) { 
			$m->print("<span class='greentext semibold half'>Already exists in tournament</span>");
			$m->print("</div>");
			next LINE;
		}

		if ($district) { 

			my $school = Tab::School->search(
				name     => $name,
				tourn    => $tourn->id,
				district => $district->id
			)->first;

			if ($school) { 
				$m->print("<span class='half'>School ".$school->name." exists</span>");
			}

			unless ($school) { 

				# Chapter with the same name in the same district? 
				my $chapter;
				
				$chapter = Tab::Chapter->search(
					name     => $name,
					district => $district->id
				)->first;

				unless ($chapter) { 

					my $cs = Tab::ChapterSetting->search(
						tag   => "jot_id",
						value => $web_school_id
					)->first if $web_school_id > 0;

					$chapter = $cs->chapter if $cs;
				}

				my $tabroom_account;

				if ($chapter) {

					$m->print("<span class='greentext half'>Found Tabroom school $chapter ".$chapter->name);
					$m->print(" from a previous import</span>");

				} else {

					$tabroom_account = Tab::Person->search( 
						email => $email
					)->first;

					unless ($tabroom_account) { 

						my $tabroom_login = Tab::Login->search(
							username => $email
						)->first;

						$tabroom_account = $tabroom_login->person 
							if $tabroom_login;
					}


					if ($tabroom_account) { 
					
						my @permissions = $tabroom_account->permissions( tag => "chapter" );

						my $short_name = Tab::short_name($name);

						foreach my $perm (@permissions) { 
							$chapter = $perm->chapter
								if $short_name eq $perm->chapter->short_name;
						}
					}
					
					if ($chapter && $tabroom_account) { 
						$m->print("<span class='greentext half'>Found Tabroom school ");
						$m->print("$chapter ".$chapter->name." belonging ");
						$m->print("to the Tabroom account $email </span>");
					}

					if ($chapter && ($chapter->nsda < 1)) { 

						my $nsda_school = $m->comp(
							"/funclib/nsda_school.mas", 
							name        => $name,
							district_id => $district->id
						);

						$chapter->nsda($nsda_school->school_id) 
							if $nsda_school;

						$chapter->district($district->id);
						$chapter->update();

						push @changes, $chapter->id." linked to this district and NSDA school ".$chapter->nsda;
					}
				}

				unless ($chapter) { 

					my $nsda_school = $m->comp(
						"/funclib/nsda_school.mas", 
						name        => $name,
						district_id => $district->id
					);

					if ($nsda_school) { 

						$chapter = Tab::Chapter->search(
							nsda => $nsda_school->school_id
						)->first;

						unless ($chapter) { 

							my $nome;
							$nome++ unless $tabroom_account;

							$chapter = $m->comp(
								"/funclib/chapter_import.mas",
								nsda_school => $nsda_school,
								person      => $tabroom_account,
								nome        => $nome
							);

							my $change_result = $district->name." imported NSDA chapter $chapter ".$chapter->name;
							$change_result   .= " for NSDA School ID ".$chapter->nsda;

							foreach my $admin ($chapter->admins) { 
								$change_result .= "Account ".$admin->email." (".$admin->first." ".$admin->last.") has access <br />";
							}

							$m->print("<span class='half semibold bluetext'>".$change_result."</span>");
							push @changes, $change_result;

						}
					}
				}

				unless ($chapter) { 

					$chapter = Tab::Chapter->create({
						name     => $name,
						street   => $addr1,
						city     => $city,
						state    => $state,
						zip      => $zip,
						country  => "US",
						coaches  => $coach,
						district => $district_id
					});

					if ($tabroom_account) { 
						Tab::Permission->create({
							person  => $tabroom_account->id,
							tag     => "chapter",
							chapter => $chapter->id
						});
					}

					$m->print("<span class='semibold redtext half'>No school found.");
					$m->print(" Created Tabroom school for $name ");
					$m->print(" and gave admin access to $email") if $tabroom_account;
					$m->print("</span>");

				}

				if ($chapter) { 

					$school = $chapter->schools( 
						tourn   => $tourn->id,
						chapter => $chapter->id
					)->first;

					unless ($school) { 
						$school = Tab::School->create({
							name     => $name,
							code     => $code,
							onsite   => $arrived,
							chapter  => $chapter->id,
							tourn    => $tourn->id,
							state    => $state,
							district => $district->id
						});

						$created++;
					}	
						
					$chapter->setting("jot_id", $web_school_id) if $web_school_id > 0;

					$school->setting("state", $state);
					$school->setting("contact_name", $coach);
					$school->setting("contact_phone", $coach);
					$school->setting("contact_email", $email)

				}

			}

			if ($school) { 
				$school->setting("jot_id", $web_school_id);
				$schools{$web_school_id} = $school;
			} else { 
				$m->print("<span class='half redtext semibold'>Failed utterly with $name $web_school_id</span>");
			}
		}

		$m->print("</div>");
	}

	undef $segments{"schools"};
	$ignore_me{"schools"}++;

	my %tiebreak_sets = 
		map {$_->name => $_}
		$tourn->tiebreak_sets();

	$m->print("<p class='semibold'>$found schools found, $created created</p>");

	my %timeslots = 
		map {$_->start->epoch => $_} 
		$tourn->timeslots();

	undef $counter;
	$counter = scalar(keys %timeslots);

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold martopmore'>Importing rounds and timeblocks</h6>");

	my %rounds;
	my %rounds_by_name;
	my %had_final;

	my %congress_rounds;
	my $congress_counter = 0;

	if ($house) { 
		foreach my $existing ($house->rounds) { 
			next unless $existing->timeslot;
			next unless $existing->timeslot->start;
			$congress_rounds{$existing->timeslot->start->epoch} = $existing;
			$congress_counter++;
		}
	}

	my $runoff;
	my $current_event;

	#Clear Congress because otherwise duplicates happen. 
	if (keys %event_house_section) { 
		foreach my $event ($tourn->events(type => "congress")) { 
			foreach my $round ($event->rounds) { 
				foreach my $section ($round->panels) { 
					$section->delete();
				}
			}
		}
	}

	# ROUNDS TIMEBLOCKS:
	ROUND:
	foreach my $linekey (sort keys %{$segments{"evrd"}}) { 

		my $line = $segments{"evrd"}{$linekey};
		next unless $csv->parse($line);

		my (
			$internal_event_id, $round_id, $no, $idea, $round_name, 
			$date, $time, $draw, 
			$flip, $panel, $flight, $panel_size, 
			$auto_flight, $attr, $user_flags
		) = $csv->fields();

		next if $internal_event_id eq "Event ID";

		$flight = int($flight);
		$round_id = int($round_id);
		$round_name = int($round_name);
		$internal_event_id = int($internal_event_id);

		my $event_id = $event_web_ids{$internal_event_id};
		my $event = $events{$event_id};

		next unless $event && $event->id;

		unless ($event_id eq $current_event) { 
			$m->print("</span></div>") if $current_event;
			$current_event = $event_id;

			$m->print('<div class="full nospace bordertop borderbottom">');
			$m->print("<span class='tenth semibold bluetext'>".$event->abbr);
			$m->print(":</span><span class='ninetenths'>");
		}
		
		if ($event_id eq "HOUSE" && $house) { 

			foreach ($date, $time, $draw) { 
				$_ =~ s/^\s+//;
				$_ =~ s/\s+$//;
			}

			$date =~ s/-/\//g;

			my ($hour, $minutes) = split(":", $time);

			# Motherfucker
			my $ampm = substr($minutes, -2);
			$minutes = substr($minutes, 0, -2);

			my $start_time = eval { 
				return Tab::dtme($date, "$hour:$minutes".uc($ampm), $tz);
			};

			my $end_time = $start_time->clone;
			$end_time->add( hours => 2 );

			my $round = $congress_rounds{$start_time->epoch};

			unless ($round) { 
			
				$congress_counter++;
		
				my $timeslot = Tab::Timeslot->create({ 
					tourn => $tourn,
					name  => "Congress $congress_counter",
					start => $start_time,
					end   => $end_time
				});
					
				$timeslots{$start_time->epoch} = $timeslot;

				my $round_type = "prelim";
				my $tiebreak_set = $tiebreak_sets{"Congress Prelim"};

				$round = Tab::Round->create({
					name         => $congress_counter,
					type         => "prelim",
					flighted     => 1,
					published    => 0,
					post_results => 0,
					start_time   => $start_time,
					event        => $house->id,
					timeslot     => $timeslot->id,
					tiebreak_set => $tiebreak_set->id,
					site         => $event_site{$event_id}
				});

				$m->print("<span class='third'>Created Congress ".$round->realname."</span>");

			}

			$m->comp("/funclib/round_dump.mas", 
				person => $person,
				round  => $round
			);

			$congress_rounds{$start_time->epoch} = $round;
			$congress_rounds{$internal_event_id}{$round_id} = $round;

			next ROUND;

		} 

		unless ($event) { 
			$m->print("<span class='redtext semibold half'>Event $event_id is not found</span>");
			next ROUND;
		}

		foreach ($date, $time, $draw) { 
			$_ =~ s/^\s+//;
			$_ =~ s/\s+$//;
		}

		$date =~ s/-/\//g;
		my ($hour, $minutes) = split(":", $time);

		unless ($rounds_by_name{$event_id}) { 
			%{$rounds_by_name{$event_id}} = 
				map {$_->name => $_} 
				$event->rounds();
		}

		unless ($rounds{$event_id}) { 
			%{$rounds{$event_id}} = 
				map {$_->setting("jot_id") => $_} 
				$event->rounds();
		}

		# Motherfucker
		my $ampm = substr($minutes, -2);
		$minutes = substr($minutes, 0, -2);

		my $start_time = eval { 
			return Tab::dtme($date, "$hour:$minutes".uc($ampm), $tz);
		};

		unless ($timeslots{$start_time->epoch}) { 

			my $end_time = $start_time->clone();
			$end_time->add( hours => 1);

			$counter++;

			my $timeslot = Tab::Timeslot->create({ 
				tourn => $tourn,
				name  => "Timeslot $counter",
				start => $start_time,
				end   => $end_time
			});

			$timeslots{$start_time->epoch} = $timeslot;

		}

		my $round_type; 

		if ($district 
			&& $event->type eq "speech"
			&& $tourn_settings->{"nsda_speech_method"} eq "doubledown"
		) { 

			$round_type = $fucked_joy_rounds{$round_id};
			$round_type = "prelim" if $round_id < 6; 
			$round_type = "elim" if $round_id > 10 && $round_id < 16; 

		} else { 
			$round_type = $fucked_joy_rounds{$round_id};
		}

		my $round;
		my $tiebreak_set;

		my $debate_final;
		my $speech_final;

		if ($event->type eq "congress") { 
		
			$round_type = $section_round_type{$internal_event_id}
				if $section_round_type{$internal_event_id};

			if ($round_type eq "prelim") { 
				$tiebreak_set = $tiebreak_sets{"Congress Prelim"};
			} elsif ($round_type eq "elim") { 
				$tiebreak_set = $tiebreak_sets{"Congress Elim"};
			} elsif ($round_type eq "final") { 
				$tiebreak_set = $tiebreak_sets{"Congress Final"};
			}

		} elsif ($event->type eq "speech") { 

			if ($round_type eq "prelim") { 
				$tiebreak_set = $tiebreak_sets{"IE Prelim"};
			} elsif ($round_type eq "elim") { 
				$tiebreak_set = $tiebreak_sets{"IE Semi"};
				$tiebreak_set = $tiebreak_sets{"IE Elim"} unless $tiebreak_set;
				$tiebreak_set = $tiebreak_sets{"IE Prelim"} unless $tiebreak_set;
			} elsif ($round_type eq "final") { 
				$tiebreak_set = $tiebreak_sets{"IE Final"};
				$tiebreak_set = $tiebreak_sets{"IE Elim"} unless $tiebreak_set;
			}

		} else { 

			if ($round_type eq "elim" || $round_type eq "runoff") { 
				$tiebreak_set = $tiebreak_sets{"Debate Elim"};
				$tiebreak_set = $tiebreak_sets{"Debate Elims"} unless $tiebreak_set;
			} elsif ($round_type eq "final") { 
				$tiebreak_set = $tiebreak_sets{"Debate Final"};
				$tiebreak_set = $tiebreak_sets{"Debate Finals"} unless $tiebreak_set;
				$tiebreak_set = $tiebreak_sets{"Debate Elim"} unless $tiebreak_set;
				$tiebreak_set = $tiebreak_sets{"Debate Elims"} unless $tiebreak_set;
			} else { 
				$tiebreak_set = $tiebreak_sets{"Debate Prelim"};
				$tiebreak_set = $tiebreak_sets{"Debate"} unless $tiebreak_set;
			}

		}

		$m->print('<span class="sixth">');
		$m->print(ucfirst($round_type)." $round_name: ");

		if ($rounds_by_name{$event_id}{$round_name}
			|| $rounds{$event_id}{$round_id}
		) { 

			$round = $rounds{$event_id}{$round_id};

			unless ($round) { 
				$round = $rounds_by_name{$event_id}{$round_name};
				$round->setting("jot_id", $round_id);
			}

			my $timeslot = $timeslots{$start_time->epoch};

			unless ($round->timeslot->id == $timeslot->id) { 
				$round->timeslot($timeslot->id);
			}

			$round->type($round_type);
			$round->site($event_site{$event_id});
			$round->tiebreak_set($tiebreak_set);
			$round->update();

			$m->print("exists");

		} else { 

			$round = Tab::Round->create({
				name         => $round_name,
				type         => $round_type,
				flighted     => $flight,
				published    => 0,
				post_results => 0,
				start_time   => $start_time,
				event        => $event->id,
				tiebreak_set => $tiebreak_set->id,
				timeslot     => $timeslots{$start_time->epoch}->id,
				site         => $event_site{$event_id}
			});

			$m->print($round_type." round $round_name created in ".$event->abbr);

			$round->setting("jot_id", $round_id);
			$rounds{$event_id}{$round_id} = $round;
			$rounds_by_name{$event_id}{$round_name} = $round;

		}

		$m->print("</span>");

		if ($event->type eq "congress") { 
			$congress_rounds{$internal_event_id}{$round_id} = $round;
		}

		# Dump the round's current sections and results if any

		$m->comp("/funclib/round_dump.mas", 
			person => $person,
			round  => $round
		);

		$runoff = $round if $round->type eq "runoff";
		$had_final{$event->id}++ if $round->type eq "final";
	
		$m->flush_buffer();

	}

	$m->print(" </span> </div>");

	if ($district) { 

		foreach my $event_id ( keys %rounds_by_name) { 

			next if $had_final{$event_id};

			my @round_names = sort keys %{$rounds_by_name{$event_id}};
			my $last_round_name  = pop @round_names;

			my $round = $rounds_by_name{$event_id}{$last_round_name};

			unless ($round->event->type eq "congress") { 

				$round->type("final");

				my $tiebreak_set;
			
				if ($round->event->type eq "speech") { 
					$tiebreak_set = $tiebreak_sets{"IE Final"};
					$tiebreak_set = $tiebreak_sets{"IE Elim"} unless $tiebreak_set;
				} else { 
					$tiebreak_set = $tiebreak_sets{"Debate Final"};
					$tiebreak_set = $tiebreak_sets{"Debate Finals"} unless $tiebreak_set;
					$tiebreak_set = $tiebreak_sets{"Debate Elim"} unless $tiebreak_set;
					$tiebreak_set = $tiebreak_sets{"Debate Elims"} unless $tiebreak_set;
				}

				$round->tiebreak_set($tiebreak_set) if $tiebreak_set;
				$round->update;

			}
		}
	}

	$m->print("</span>");

	$m->flush_buffer();

	undef $segments{"evrd"};
	$ignore_me{"evrd"}++;

	undef $counter;

	foreach my $key (sort keys %timeslots) { 
		$counter++;
		$timeslots{$key}->name("Timeslot ".$counter);
		$timeslots{$key}->update();
	}

	my %rooms;
	my %site_rooms;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing rooms and sites </h6>");
	$m->print("<p class='bluetext bigger semibold'>The default site for new rooms ");
	$m->print("is ".$default_site." ".$default_site->name."</p>");

	# ROOMS
	foreach my $linekey (sort keys %{$segments{"rooms"}}) { 
		my $line = $segments{"rooms"}{$linekey};

		next unless $csv->parse($line);

		my (
			$room_id, $room_name, $hall, $notes, $flags, $other_flags
		) = $csv->fields();

		next if $room_id eq "Room ID";

		$room_id = int($room_id);

		# Hunt for an existing room named this:
		foreach my $key (sort keys %sites) { 

			last if $rooms{$room_id};

			my $site = $sites{$key};

			unless ($site_rooms{$key}) { 
				@{$site_rooms{$key}} = $site->rooms();
			}

			foreach my $room (@{$site_rooms{$key}}) { 

				if (
					$room->notes == $room_id
				 	|| $room_name eq $room->name
				) { 
					$rooms{$room_id} = $room;
					last;
				}
			}
		}

		#If it isn't found create one:

		if ($rooms{$room_id}) { 

			if ($rooms{$room_id}->deleted) { 
				$rooms{$room_id}->deleted(0);
				$rooms{$room_id}->update();
			}

			$m->print("<span class='quarter'>Room ".$rooms{$room_id}->name." exists </span>");

		} else { 

			$rooms{$room_id} = eval {
				return Tab::Room->create({
					name     => $room_name,
					site     => $default_site->id,
					notes    => $room_id,
					capacity => 0,
					quality  => 10,
					inactive => 0,
					deleted  => 0
				});
			};

			if ($rooms{$room_id}) { 
				$m->print("<span class='quarter greentext'>Created room $room_name </span>");
			} else { 
				$m->print("<span class='quarter'>No room $room_name</span>");
			}
		}
	}

	$m->print("<br />");

	undef $segments{"rooms"};
	$ignore_me{"rooms"}++;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing judges</h6>");

	my @all_judges = $m->comp("/funclib/tourn_judges.mas", tourn => $tourn);

	my %judges;
	my %judge_category;
	my %judge_web_ids = ();

	foreach my $judge (@all_judges) { 
		my $jot_id = $judge->setting("jot_id");
		push @{$judges{$jot_id}}, $judge if $jot_id;
	}

	foreach my $linekey (sort keys %{$segments{"judges"}}) { 

		my $line = $segments{"judges"}{$linekey};

		next unless $csv->parse($line);

		my (
			$internal_judge_id, $internal_school_id, $name, $message, $options, $round_limit, 
			$flags, $private_note, $phone1, $phone2, $email, $region, $district, 
			$obligation, $base_priority, $rating, $user_flags, $cell_phone, 
			$pager, $code, $judge_id, @bullshit
		) = $csv->fields();


		$judge_id = int($judge_id);
		$internal_judge_id = int($internal_judge_id);
		$internal_school_id = int($internal_school_id);

		next if $internal_judge_id eq "Judge ID";

		$judge_id = $tourn->id."-".$internal_judge_id if $judge_id == -1;
		$judge_web_ids{$internal_judge_id} = $judge_id;

		my @already;
		@already = @{$judges{$judge_id}} if $judges{$judge_id};

		my $chapter_judge;
		my $hired;
		my $school_id;
		my $school;

		if ($internal_school_id == -1) { 
			$hired++;
			$school_id = 0;
		} else { 
			$school_id = $school_web_ids{$internal_school_id};
			$school = $schools{$school_id};
		}

		my $person;

		if ($email) { 

			$person = Tab::Person->search( 
				email => $email
			)->first;

			unless ($person) { 
				my $login = Tab::Login->search( 
					username => $email
				)->first;
				$person = $login->person if $login;
			}
		}

		# So someone who stores middle names and salutations in the database
		# munges them all into one field in the application.  Sigh. 

		# I'm going to only use first and last for searching because otherwise
		# this will reach a higher level of ridiculous than it already has. 

		my @names = split(/\ /, $name);
		my $first;
		my $last;
		my $middle;

		$first = shift @names if @names;
		$last = pop @names if @names;
		$middle = join(" ", @names);

		if ($school) { 

			if (@already) { 

				$chapter_judge = $already[0]->chapter_judge;

			} else { 

				my $chapter = $school->chapter;

				$chapter_judge = $chapter->chapter_judges(
					person => $person->id
				)->first if $person;

				$chapter_judge = $chapter->chapter_judges(
					first => $first,
					last  => $last
				)->first unless $chapter_judge;

				unless ($chapter_judge) { 

					$chapter_judge = Tab::ChapterJudge->create({
						first   => $first,
						middle  => $middle,
						last    => $last,
						retired => 0,
						phone   => $cell_phone,
						email   => $email,
						person  => $person,
						chapter => $chapter
					});

				}

			}

			if ($chapter_judge && $person) { 

				unless ($chapter_judge->person) { 
					$chapter_judge->person($person->id);
					$chapter_judge->update();
				}

			}

		} else { 
			$school = 0;
			$chapter_judge = 0;
		}

		my %already;
		my $judge;

		foreach my $internal_event_id (sort keys %{$judge_pools{$internal_judge_id}}) { 

			my $category_code = $event_categories{$internal_event_id};
			my $category = $categories{$category_code};

			next unless $category;

			unless ($already{$category}++) { 

				$m->print("<span class='greentext quarter'>Judge $judge_id $first $last: ".$category->abbr."</span>");

				$judge = Tab::Judge->search(
					person => $person->id
				)->first if $person;

				$judge = Tab::Judge->search(
					school        => $school,
					category      => $category,
					chapter_judge => $chapter_judge,
					first         => $first,
					middle        => $middle,
					last          => $last,
				)->first unless $judge;

				if ($judge) { 

					if ($person && $person != $judge->person) { 
						$judge->person($person->id);
						$judge->update();
					}
					

				} else { 

					$judge = Tab::Judge->create({
						first         => $first,
						middle        => $middle,
						last          => $last,
						active        => 1,
						obligation    => 9,
						hired         => 0,
						school        => $school,
						category      => $category,
						chapter_judge => $chapter_judge
					});

				}

				if ($judge) { 
					$judge->setting("jot_id", $judge_id);
					push @{$judges{$judge_id}}, $judge;
					$judge_category{$judge_id}{$category->id} = $judge;
				}

			}

		}

		unless (keys %{$judge_pools{$internal_judge_id}}) { 

			$judge = Tab::Judge->search(
				person => $person->id
			)->first if $person;

			$judge = Tab::Judge->search(
				school        => $school,
				category      => $unpooled,
				chapter_judge => $chapter_judge,
				first         => $first,
				middle        => $middle,
				last          => $last,
			)->first unless $judge;

			$judge = Tab::Judge->create({
				first         => $first,
				middle        => $middle,
				last          => $last,
				active        => 1,
				obligation    => 9,
				hired         => 0,
				school        => $school,
				category      => $unpooled,
				chapter_judge => $chapter_judge
			}) unless $judge;

			$judge->setting("jot_id", $judge_id);

			push @{$judges{$judge_id}}, $judge;
			$judge_category{$judge_id}{$unpooled->id} = $judge;
			
			$m->print("<span class='quarter semibold bluetext'>Judge $judge_id $first $last ");
			$m->print("".$unpooled->name." category</span>");

		}

		unless ($judge) { 
			$m->print("<span class='quarter semibold redtext'>Unable to import Judge ".$first." ".$last."</span>");
		}
	}

	$m->print("<br />");

	undef $segments{"judges"};
	$ignore_me{"judges"}++;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing competitors</h6>");

	my @all_students = $m->comp(
		"/funclib/tourn_students.mas", 
		tourn => $tourn
	);

	my %students; 
	my %student_web_ids;
	my %student_tags;

	foreach my $student (@all_students) { 

		my $jot_id = $student->setting("jot_id");

		unless ($student->chapter > 0)  {

			$student->setting("jot_id", 0);

		} else { 

			if ($jot_id) { 
				$students{$jot_id} = $student;
			}
			$student_tags{$student->chapter->id}{$student->first}{$student->last} = $student;
		}
		
	}

	my %name_codes;
	my $notfirst;

	foreach my $linekey (sort keys %{$segments{"names"}}) { 

		my $line = $segments{"names"}{$linekey};

		next unless $csv->parse($line);

		my (
			$internal_student_id, $internal_school_id, $name, $code, $student_id
		) = $csv->fields();

		next if $internal_student_id eq "Name ID";

		$name_codes{int($internal_student_id)} = $code;
		$name_codes{int($internal_student_id)} = $name unless $code;

		# This function filters out some nonsense about pairs/teams:
		next if (index($name, ' - ') != -1);

		$student_id = int($student_id);
		$internal_student_id = int($internal_student_id);
		$student_id = $internal_student_id if $student_id == -1;
		$student_web_ids{$internal_student_id} = $student_id;
		$student_web_ids{$internal_student_id} = $student_id;

		next if $students{$student_id};

		$internal_school_id = int($internal_school_id);
		my $school_id = $school_web_ids{$internal_school_id};
		my $school = $schools{$school_id};

		my @names = split(/\ /, $name);
		my $first;
		my $last;
		my $middle;

		$first = shift @names if @names;
		$last = pop @names if @names;
		$middle = join(" ", @names);

		$m->print("</span>") if $notfirst++;
		$m->print("<span class='third'>");
		$m->print("<p>$student_id $name in from ".$school->name.": ");

		if ($student_tags{$school_id}{$first}{$last}) { 

			my $student = $student_tags{$school_id}{$first}{$last};
			$m->print("Found.</p>");

			$student->setting("jot_id", $student_id);
			$students{$student_id} = $student;

		} else { 

			my $candidate;
			my $chapter = $school->chapter;
			my @students = $chapter->students(
				first => $first,
				last  => $last
			);

			foreach my $student (@students) { 

				next if $student->retired;

				next if $student->grad_year > 1900
					&& $student->grad_year < $this_year; 

				if ($student->ualt_id
					&& $candidate && (not defined $candidate->ualt_id)
				) { 
					$candidate = $student;
				} 

				$candidate = $student unless $candidate;
			}

			my $search_nsda; 

			unless ($candidate) { 

				$m->print("<p class='orangetext semibold'>$first $last Not found.  Creating</p>");

				$first = "Unknown" unless $first;
				$last = "Unknown" unless $last;

				$candidate = Tab::Student->create({
					first   => $first,
					middle  => $middle,
					last    => $last,
					chapter => $chapter,
					novice  => 0,
					retired => 0
				});

				$search_nsda++;
				
				$m->print("<p class='marleft'> &ndash; Linking to NSDA membership:");

			} elsif ($candidate->ualt_id < 1) { 

				$m->print("<p class='marleft'> No NSDA membership linked. Searching: ");
				$search_nsda++;
			}

			if ($search_nsda) { 

				my $nsda = $m->comp(
					"/funclib/nsda_student_search.mas", 
					chapter => $chapter,
					first   => $first,
					last    => $last
				);

				if ($nsda) { 

					$m->print("<span class='inline greentext semibold'>Found NSDA ");
					$m->print("member ".$nsda->ualt_id."</span></p>");

					$candidate->grad_year($nsda->grad_yr);
					$candidate->ualt_id($nsda->ualt_id);
					$candidate->update();

					if ($nsda->paid_status) { 
						$candidate->setting("nsda_paid", 1);
					} else { 
						$candidate->setting("nsda_paid", "X");
					}

					if ($nsda->total_pts) { 
						$candidate->setting("nsda_points", $nsda->total_pts);
					} else { 
						$candidate->setting("nsda_points", "X");
					}

					my $joined = eval{
						return DateTime::Format::MySQL->parse_datetime($nsda->high_joined);
					};

					if ($joined) { 
						$candidate->setting("nsda_joined", "date", $joined);
					} else { 
						$candidate->setting("nsda_joined", "X");
					}

					my $test_person;

					if ($candidate->person) { 

						$candidate->setting("student_email", $candidate->person->email);
					
					} elsif ($nsda->demo) { 

						$candidate->setting("student_email", $nsda->demo);
						$test_person = $nsda->demo;
					
					} elsif ($nsda->login) { 

						$test_person = $nsda->login;
						$candidate->setting("student_email", $nsda->login);

					} else { 
						$candidate->setting("student_email", "X");
					}

					if ($test_person) { 
						my $person = Tab::Person->search( 
							email => $test_person
						)->first;

						unless ($person) { 
							my $login = Tab::Login->search( 
								username => $test_person
							)->first;
						}
					}

				} elsif ($district) { 

					$m->print("<span class='inline redtext semibold'>No matching NSDA member ");
					$m->print("found for $candidate. Reconciliation will be required for Districts.</span></p>");
				}

			} else { 
				
				$m->print("<span class='semibold greentext'>Found competitor $candidate ");
				$m->print("with NSDA membership ".$candidate->ualt_id." linked.</span></p>");

			}

			$candidate->setting("jot_id", $student_id);
			$students{$student_id} = $candidate;

		}

	}

	$m->print("</span>");
	$m->print("<br />");

	undef $segments{"names"};
	$ignore_me{"names"}++;

	my %teams = ();

	foreach my $linekey (sort keys %{$segments{"teams"}}) { 
		my $line = $segments{"teams"}{$linekey};

		next unless $csv->parse($line);

		my ( 
			$internal_entry_id, $internal_student_id 
		) = $csv->fields();

		next if $internal_entry_id eq "Entry ID";

		my $student_id = $student_web_ids{int($internal_student_id)};
		push @{$teams{int($internal_entry_id)}}, $student_id;
	}

	undef $segments{"teams"};
	$ignore_me{"teams"}++;

	my %entry_web_ids;
	my %entries;
	my %entry_tags;
	my %existing;

	my @all_entries = $m->comp(
		"/funclib/tourn_entries.mas", 
		tourn => $tourn,
		all   => 1
	);

	foreach my $entry (@all_entries) { 
		push @{$entry_tags{$entry->school->id}{$entry->event->id}}, $entry;
		$existing{$entry->setting("jot_id")} = $entry;
	}

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing entries</h6>");

	my %already;

	# Can't spell entries apparently. 
	ENTRY:
	foreach my $linekey (sort keys %{$segments{"entrys"}}) { 

		my $line = $segments{"entrys"}{$linekey};

		next unless $csv->parse($line);

		my ( 
			$internal_entry_id, $internal_school_id, $internal_event_id, $squad_seq, 
			$internal_student_id, $flags, $apparently_not_a_code, $user_flags, 
			$entry_id, $seed
		) = $csv->fields();

		next if $internal_entry_id eq "Entry ID";

		my $event_id = $event_web_ids{int($internal_event_id)};
		my $school_id = $school_web_ids{int($internal_school_id)};
		my $student_id = $student_web_ids{int($internal_student_id)};

		unless ($entry_id) { 
			$entry_id = $tourn->id."-".$internal_entry_id;
		} 

		$entry_web_ids{int($internal_entry_id)} = $entry_id;

		my $code = $name_codes{int($internal_student_id)};
		my $event = $events{$event_id};

		next unless $event;

		my $jot_id = $internal_student_id."-".$event->id;
		my $entry = $entries{$entry_id};

		unless ($entry) { 
			$entry = $existing{$jot_id};
			$entries{$entry_id} = $entry;
		}

		unless ($entry) { 

			my %entry_students;
			my $school = $schools{$school_id};

			if ($teams{int($internal_entry_id)}) { 
				foreach my $student_id (@{$teams{int($internal_entry_id)}}) { 
					$entry_students{$students{$student_id}->id} = $students{$student_id}
						if $students{$student_id};
				}
			} else { 
				my $student = $students{$student_id};
				$entry_students{$student->id} = $students{$student_id} if $student;
			}
	
			EXISTS:
			foreach my $existing (@{$entry_tags{$school->id}{$event->id}}) { 

				my %existing_students = 
					map {$_->id => 1} 
					$existing->students;

				foreach my $student_id (keys %existing_students) { 
					next EXISTS unless $entry_students{$student_id};
				}

				foreach my $student_id (keys %entry_students) { 
					next EXISTS unless $existing_students{$student_id};
				}

				$entry = $existing;
				last EXISTS if $entry;
			}

			if ($entry) { 
				$m->print("<p>$internal_entry_id Entry $code already exists! ");
			} else { 

				$m->print("<p>Entry $code in ".$event->abbr." for $internal_entry_id does not exist.  Importing to Tabroom: ");

				$entry = Tab::Entry->create({
					code          => $code,
					tba           => 0,
					dropped       => 0,
					waitlist      => 0,
					unconfirmed   => 0,
					dq            => 0,
					created_at    => $now,
					tourn         => $tourn->id,
					event         => $event->id,
					school        => $school->id,
					registered_by => $person->id,
				});

				foreach my $key (keys %entry_students) { 
					Tab::EntryStudent->create({
						entry   => $entry->id,
						student => $entry_students{$key}->id
					});
				}

				$entry->name(
					$m->comp("/funclib/entry_name.mas", entry => $entry)
				);
			}

			if ($entry) { 

				$entry->code($code);
				$entry->update();
				$entries{$entry_id} = $entry;
				$m->print("<span class='inline semibold greentext marleft'>Succeeded!</p>");
				$entry->setting("jot_id", $jot_id);
				$existing{$jot_id} = $entry;

			} else { 
				$m->print(" <span class='inline semibold redtext'>Import failed!</p>");
			}

		} else { 
			$entry->code($code);
			$entry->update();
		}

		my @flags = parse_flags_bullshit($flags);

		if ($flags[0] && $flags[0] == 1) { 
			#Drops
			$entry->dropped(1);
		} else { 
			$entry->dropped(0);
		}

		if ($flags[1] && $flags[1] == 1) { 
			#DQs
			$entry->dq(1);
			$entry->dropped(1);
		} else { 
			$entry->dq(0);
			unless ($flags[0] && $flags[0] == 1) { 
				$entry->dropped(0);
			}
		}

		# 2 and 3 are "Experienced" and "Novice."  Novice is per-student in
		# Tabroom and there's no Experienced.  Therefore, toss them both. 

		#On sweeps, yes is no and stuff. 
		if ($flags[4] && $flags[4] == 1) { 
			$entry->setting('exclude_from_sweeps', 1);
		} else { 
			$entry->setting('exclude_from_sweeps', 0);
		}

		# 5 means a web entry thinger is missing which I compensate for in an
		# unnecessarily complicated bit of code later

		if ($flags[6] && $flags[6] == 1) { 
			$entry->setting('nsda_vacate', 1);
		} else { 
			$entry->setting('nsda_vacate', 0);
		}

		if ($flags[7] && $flags[7] == 1) { 
			$entry->ada(1);
		} else { 
			$entry->ada(0);
		}

		$entry->update();

	}

	undef $segments{"entrys"};
	$ignore_me{"entrys"}++;

	my %sections;
	my %section_by_id;
	my %section_data;
	my %sections_by_tag;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold marbottom'>Importing sections/debates/chambers</h6>");

	my %event_counter;
	my $overall;

	# I hate that this is necessary.  It looks unnecessary.  But wait until you
	# see the judge nightmare below. 

	my %section_translator;
	my %section_event; 
	my %section_type; 

	SECTION:
	foreach my $linekey (sort keys %{$segments{"sections"}}) { 

		my $line = $segments{"sections"}{$linekey};

		next unless $csv->parse($line);

		my ( 
			$section_id, $internal_event_id, $round_id, $room_id, 
			$letter, $num_judges, $dunno, $noclue
		) = $csv->fields();

		next if $section_id eq "Section ID";

		$section_id = int($section_id);
		$room_id = int($room_id);
		$letter =~ s/\s+//g;

		my $event_id = $event_web_ids{int($internal_event_id)};

		my $room = $rooms{$room_id};
		my $event = $events{$event_id};

		next SECTION unless $event;

		my $round;
		my $round_type;
		my $round_label;

		$round_id = int($round_id);

		if ($event->type eq "congress") { 

			my $internal_round_id = abs($round_id);
			my $actual = $internal_event_id."-".$internal_round_id;

			$section_translator{$section_id} = $actual;	
			$section_id = $actual;

			next SECTION unless($letter == 1 && $round_id > 0);
			
			$letter = $event_house_section{$internal_event_id}
				if $event_house_section{$internal_event_id};
				
			$round = $congress_rounds{$internal_event_id}{$internal_round_id};
			
			$round_label = $house_sections{$internal_event_id};

		} else {

			$round = $rounds{$event_id}{$round_id};
			unless ($round) { 
				next SECTION unless $round;
			} 
		}

		unless ($round) { 
			$m->print("<p class='redtext semibold'> NO ROUND FOUND FOR $round_id of ".$event->name."</p>");
			next SECTION;

		} 

		my $section = Tab::Panel->create({
			round  => $round->id,
			letter => $letter,
			bye    => 0,
			room   => $room,
			label  => $round_label,
			score  => $section_id
		});

		$event_counter{$event->abbr}++;

		$section_by_id{$section->id} = $section;
		$sections{$section_id} = $section;

		$section_event{$section->id} = $event;
		$section_type{$section->id} = $event->type;

		$sections_by_tag{$event_id}{$round_id}{"object"} = $section;
		$sections_by_tag{$event_id}{$round_id}{"id"}     = $section_id;

		$section_data{$section->id}{"room"}      = $room;
		$section_data{$section->id}{"event"}     = $event;
		$section_data{$section->id}{"round"}     = $round;
		$section_data{$section->id}{"roundname"} = $round->name;

	}

	undef $segments{"sections"};
	$ignore_me{"sections"}++;

	foreach my $abbr (sort keys %event_counter) { 
		$m->print("<p class='semibold bluetext'> ");
		$m->print("Created $event_counter{$abbr} sections of $abbr</p>");
	}

	$m->flush_buffer();
	my %section_judges;

	# Sure let's needlessly renumber all the judges for NO APPARENT REASON

	SECTION:
	foreach my $linekey (sort keys %{$segments{"judsects"}}) { 

		my $line = $segments{"judsects"}{$linekey};

		next unless $csv->parse($line);

		my ( 
			$internal_judge_id, $section_id, $yafjid
		) = $csv->fields();

		next if $internal_judge_id eq "Judge ID";

		my $original_section = $section_id;
			
		$section_id = $section_translator{$section_id} 
			if $section_translator{$section_id};

		my $section = $sections{$section_id};

		next unless $section;

		next if $section_judges{$section->id}{"yafj"}{$yafjid};

		my $round = $section->round;
		my $event = $round->event;
		my $category = $event->category;

		my $judge_id = $judge_web_ids{int($internal_judge_id)};

		my $judge = $judge_category{$judge_id}{$category->id};

		$judge = $judge_category{$judge_id}{$unpooled->id} 
			unless $judge;

		unless ($judge) { 
		
			foreach my $other_judge (@{$judges{$judge_id}}) { 
				$judge = $other_judge if $other_judge > 0;
				last if $judge;
			} 
		} 

		unless ($judge) { 

			$judge = $judge_category{$internal_judge_id}{$category->id} = $judge; 

			if ($judge) {
				$judge_web_ids{int($internal_judge_id)} = $judge->id;
				$judge_category{$judge->id}{$category->id} = $judge;
			}
		}

		if ($judge) { 
			$section_judges{$section->id}{"yafj"}{$yafjid} = $judge if $yafjid;
			$section_judges{$section->id}{"real"}{$judge_id} = $judge;
		}
	}

	$ignore_me{"judsects"}++;

	my %section_byes;
	my %section_entries;

	SECTION:
	foreach my $linekey (sort keys %{$segments{"sectents"}}) { 

		my $line = $segments{"sectents"}{$linekey};

		next unless $csv->parse($line);

		my ( 
			$section_id, $internal_entry_id, $speaker_order, $speaker_actual,$id
		) = $csv->fields();

		next if $section_id eq "Section ID";

		$section_id = $section_translator{$section_id}
			if $section_translator{$section_id};

		my $section = $sections{$section_id};
		next unless $section;

		my $entry_id = $entry_web_ids{int($internal_entry_id)};
		my $entry = $entries{$entry_id};
		my $event = $section_event{$section->id};

		if ($event->type eq "congress") { 

			while ($section_entries{$section->id}{$speaker_order}) { 
				$speaker_order++;
			}

			push @{$section_entries{$section->id}{$speaker_order}}, $entry;

		} else { 
			push @{$section_entries{$section->id}{$speaker_order}}, $entry;
			$section_byes{$section->id}++ if $internal_entry_id < 0;
		}

	}

	$ignore_me{"sectents"}++;
	my %section_results;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold marbottom'>Parsing and importing results</h6>");

	my %fake_judges; 

	SECTION:
	foreach my $linekey (sort keys %{$segments{"jse"}}) { 

		my $line = $segments{"jse"}{$linekey};

		next unless $csv->parse($line);

		my ( 
			$internal_judge_id, $section_id, $internal_entry_id, 
			$points, $rank, $points1, $points2
		) = $csv->fields();

		next if $internal_judge_id eq "Judge ID";
		$internal_judge_id = int($internal_judge_id);			

		$section_id = $section_translator{$section_id}
			if $section_translator{$section_id};

		my $section = $sections{$section_id};

		next unless $section;

		my $judge;
		my $judge_id = $judge_web_ids{int($internal_judge_id)};
		$judge = $section_judges{$section->id}{"real"}{$judge_id} if $judge_id;

		unless ($judge) { 
			$judge = $section_judges{$section->id}{"yafj"}{$internal_judge_id};
		}

		my $entry = $entries{$entry_web_ids{int($internal_entry_id)}};
		next unless $entry;

		my $event = $section_event{$section->id};

		if ($event->type eq "congress") { 

			$rank = int($rank) - 1000000;
			$points = int($points);

			next SECTION unless ($rank > 0 || $points > 0); 

			$judge = create_fake_judge($internal_judge_id, $event->category, \%fake_judges)
				unless $judge;
				
			$section_judges{$section->id}{"real"}{"fake-".$internal_judge_id} = $judge;

			next SECTION unless $judge;
		
			$section_results{$section->id}{$judge->id}{$entry->id}{"rank"} = int($points);

			my $actual_points = parse_congress_bullshit($rank);

			$points1 = int($points1);
			my $spare_points;

			if ($points1 > 0) { 
				$spare_points = parse_congress_bullshit($points1);
			}

			if ($spare_points) { 

				my @originals = split(',', $actual_points);
				my @adds = split (',', $spare_points);

				undef $actual_points;

				while (@originals) {
					my $stuff = shift @originals;

					my $extra;
					$extra = shift @adds if @adds;
					$stuff = $stuff + $extra if $extra; 
					$actual_points .= "," if $actual_points;
					$actual_points .= $stuff;
				}
			}

			$section_results{$section->id}{$judge->id}{$entry->id}{"points"} = $actual_points;


		} elsif ($event->type eq "speech") { 

			$judge = create_fake_judge($internal_judge_id, $event->category, \%fake_judges)
				unless $judge;

			next SECTION unless $judge;

			$section_judges{$section->id}{"real"}{"fake-".$internal_judge_id} = $judge;

			if ($rank < 0)  { 
				$section_results{$section->id}{$judge->id}{$entry->id}{"forfeit"}++;
			} else { 
				$section_results{$section->id}{$judge->id}{$entry->id}{"rank"} = int($rank);
				$section_results{$section->id}{$judge->id}{$entry->id}{"points"} = int($points);
			}

		} else { 

			$judge = create_fake_judge($internal_judge_id, $event->category, \%fake_judges)
				unless $judge;

			next SECTION unless $judge;

			$section_judges{$section->id}{"real"}{"fake-".$internal_judge_id} = $judge;
		

			$section_results{$section->id}{$judge->id}{$entry->id}{"winloss"} = 0;

			# The actual value is 65536.  I am not making this up. 
			$section_results{$section->id}{$judge->id}{$entry->id}{"winloss"} = 1
				if $points > 0;
		}

	}

	$ignore_me{"jse"}++;

	my @section_keys = keys %section_entries;

	@section_keys = 
		sort {$section_by_id{$a}->letter <=> $section_by_id{$b}->letter}
		@section_keys;

	@section_keys = 
		sort {$section_data{$a}{"roundname"} <=> $section_data{$b}{"roundname"}}
		@section_keys;

	@section_keys = 
		sort {$section_data{$a}{"event"} cmp $section_data{$b}{"event"}}
		@section_keys;

	my %round_spares;
	my %round_letter;

	my %entry_last_round;
	my @runoff_entries;

	SECTION:
	foreach my $section_id (@section_keys) { 

		my $section = $section_by_id{$section_id};
		next unless $section; 

		my $bye = $section_byes{$section_id};

		my $event = $section_data{$section_id}{"event"};
		my $round = $section_data{$section_id}{"round"};
		my $room  = $section_data{$section_id}{"room"};

		$round_letter{$round->id} = $section->letter 
			if $round_letter{$round->id} < $section->letter;

		my %used;
		my %first_at_order;
		my %actual_judge; 

		$m->print("<span class='semibold bluetext quarter'>Importing ".$event->abbr." ".$round->realname." section ".$section->letter."</span>");

		foreach my $order (
			sort {$a <=> $b} 
			keys %{$section_entries{$section->id}}
		) { 

			next unless $section_entries{$section->id}{$order};

			foreach my $entry (@{$section_entries{$section->id}{$order}}) { 

				next unless $entry;
				next if $used{$entry}++;

				if ($first_at_order{$order}) { 
					push @{$round_spares{$round->id}{"entries"}}, $entry;
				} else { 
					$first_at_order{$order} = $entry;
				}
			}

			my $entry = $first_at_order{$order};
			next unless $entry;

			if ($round->type eq "runoff") { 
				push @runoff_entries, $entry;
			} else { 

				$entry_last_round{$entry->id} = $round 
					unless $entry_last_round{$entry->id};

				$entry_last_round{$entry->id} = $round 
					if $entry_last_round{$entry->id}->name < $round->name;
			}

			if ($section_byes{$section_id}) { 

				$section->bye(1);
				$section->update();

				my $ballot = Tab::Ballot->create({
					entry         => $entry,
					judge         => 0,
					panel         => $section,
					speakerorder  => 0,
					side          => 0,
					chair         => 0,
					bye           => 0,
					forfeit       => 0,
					audit         => 1
				});

			}

			JUDGEKEY:
			foreach my $judgekey (keys %{$section_judges{$section->id}{"real"}}) { 

				my $judge = $section_judges{$section->id}{"real"}{$judgekey};
				next unless $judge;

				next if $used{$judge}{$entry}{$section}++;

				my $fft = $section_results{$section->id}{$judge->id}{$entry->id}{"forfeit"};
				$fft = 0 unless $fft;

				my $bye = $section_byes{$section_id};
				$bye = 0 unless $bye;

				my $ballot = Tab::Ballot->create({
					entry         => $entry,
					judge         => $judge,
					panel         => $section,
					speakerorder  => $order,
					side          => $order,
					bye           => $bye,
					forfeit       => $fft,
					audit         => 1,
				});

				my $win = $section_results{$section->id}{$judge->id}{$entry->id}{"winloss"};
				my $rank = $section_results{$section->id}{$judge->id}{$entry->id}{"rank"};
				my $points = $section_results{$section->id}{$judge->id}{$entry->id}{"points"};

				my $chair;

				if ($section_type{$section_id} eq "congress") { 

					$actual_judge{$judge->id}++ if $rank > 0; 

					if ($rank && $rank > 9 && (not defined $chair)) { 
						$chair++;
						$ballot->chair($chair);
						$ballot->update();
					}

					$rank = 9 unless $rank;
					next JUDGEKEY unless $rank;

					Tab::Score->create({
						ballot => $ballot,
						tag    => "rank",
						value  => $rank
					});

					if ($points) { 

						my $speech;

						my @points = split(',', $points);

						foreach my $point (@points) { 
							next unless $point;
							$speech++;

							Tab::Score->create({
								ballot => $ballot,
								tag    => "congress_speech",
								value  => $point,
								speech => $speech
							});

						}
					}

				} elsif ($section_type{$section_id} eq "speech") { 

					Tab::Score->create({
						ballot => $ballot,
						tag    => "rank",
						value  => $rank
					}) if $rank;

				} else { 

					$win = 0 unless $win;

					Tab::Score->create({
						ballot => $ballot,
						tag    => "ballot",
						value  => $win
					}) if defined $win;
				}
			}
		}


		foreach my $order (
			sort {$a <=> $b} 
			keys %{$section_entries{$section->id}}
		) { 

			next unless $section_entries{$section->id}{$order};
			if ($section_type{$section_id} eq "congress") { 

				foreach my $entry (@{$section_entries{$section_id}{$order}}) { 

					next unless $entry;

					foreach my $judgekey (keys %{$section_judges{$section->id}{"real"}}) { 

						my $judge = $section_judges{$section->id}{"real"}{$judgekey};
						next unless $judge;

						unless ($actual_judge{$judge->id}) { 
							foreach my $ballot ($judge->ballots( panel => $section_id)) { 
								$ballot->delete();
							}
						}
					}
				}
			}
		}
	}

	if ($runoff && @runoff_entries) {

		my $last_round = $entry_last_round{$runoff_entries[0]->id};

		$last_round->runoff($runoff->id);
		$last_round->update();
	}

	foreach my $round_id (sort keys %round_spares) { 

		# These are people who bye through the various rounds

		my $letter = $round_letter{$round_id};

		if ($round_spares{$round_id}{"entries"}) {

			foreach my $spare (@{$round_spares{$round_id}{"entries"}}) {

				$letter++;

				my $section = Tab::Panel->create({
					round  => $round_id,
					letter => $letter,
					bye    => 1,
					room   => 0,
				});

				my $ballot = Tab::Ballot->create({
					judge        => 0,
					entry        => $spare,
					audit        => 1,
					panel        => $section,
					chair        => 0,
					bye          => 0,
					forfeit      => 0,
					audit        => 1,
				});

			}
		}
	}

	Tab::Round->set_sql( delete_empties => "
		delete round.*
			from round, event
			where event.tourn = ? 
			and event.id = round.event
			and not exists (
				select ballot.id
				from ballot, panel
				where panel.round = round.id
				and ballot.panel = panel.id
			)
	");

	Tab::Round->sql_delete_empties->execute($tourn->id);

	foreach my $linekey (sort keys %{$segments{"selections"}}) { 

		my $line = $segments{"selections"}{$linekey};
		next unless $csv->parse($line);

		my (
			$selection_id, $internal_entry_id, $author, $title, $source
		) = $csv->fields();

		my $entry_id = $entry_web_ids{int($internal_entry_id)};
		my $entry = $entries{$entry_id};

		if ($entry) { 
			$entry->setting("author", $author);
			$entry->setting("title", $title);
			$entry->setting("publisher", $source);
		}

		next if $entry_id eq "Entry ID";

	}

	$ignore_me{"selections"}++;

	foreach my $label (sort {$a cmp $b} keys %segments) { 

		next if $ignore_me{$label};

		$m->print("<h5>".$label."</h5>");

		foreach my $linekey (sort keys %{$segments{$label}}) { 

			my $line = $segments{$label}{$linekey};
			$m->print("<pre>".$line."</pre>");
		}

	}

	sub parse_flags_bullshit {
		my $decimal = shift;
		my $binary = sprintf ("%b", $decimal);
		my @flags = reverse split(//, $binary);
		return @flags;
	}

	sub parse_congress_bullshit { 

		my $score = shift;

		my $points = $score;

		my $steps;

		while ($points > 6) { 
			$steps++;
			$points = $points / 7; 
			$points = floor($points);
		}	

		my %results;

		while ($steps) {

			my $points = $score; 

			$points = $points / (7 ** $steps);
			$points = floor($points);

			my $remainder = $score - ((7 ** $steps) * $points);

			$results{$steps} = $points;
			$score = $remainder;
			$steps--;
		}

		$results{0} = $score if defined $score; 

		my $result_string;

		foreach my $key (sort {$a <=> $b} keys %results) { 

			$result_string .= "," if defined $result_string;
			$result_string .= $results{$key};
		}

		return $result_string;

	}

	sub create_fake_judge { 

		my ($internal_id, $category, $fake_judgeref) = @_;

		return $fake_judgeref->{$internal_id}{$category->id}
			if $fake_judgeref->{$internal_id}{$category->id};

		my $judge;

		$judge = Tab::Judge->search( 
			category => $category->id,
			first    => "Unknown",
			last     => "Judge $internal_id"
		)->first;

		$judge = Tab::Judge->create({
			school     => 0,
			category   => $category->id,
			first      => "Unknown",
			last       => "Judge $internal_id",
			code       => $internal_id,
			active     => 0,
			obligation => 9,
			hired      => 0,
		}) unless $judge;

		if ($judge) { 
			$fake_judgeref->{$internal_id}{$category->id} = $judge;
			return $judge;
		}

		return;
	}

</%init>

	</div>

	<div class="menu">

		<div class="sidenote">
		
			<h5>Return</h5>

%			if ($house_section_counter) { 

				<a 
					class = "yellow full martop marbottommore"
					href  = "/tabbing/publish/joydistrict.mhtml?function=Congress Chambers"
				>Return to Districts Import</a>

%			} else { 

				<a 
					class = "yellow full martop marbottommore"
					href  = "/tabbing/publish/joydistrict.mhtml?function=Confirm NSDA Memberships"
				>Return to Districts Import</a>
%			} 

		</div>

	</div>


