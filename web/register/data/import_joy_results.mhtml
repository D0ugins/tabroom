<%args>
	$tourn
	$tourn_settings
	$person
	$person_settings
</%args>
<%init>

	use POSIX;

	use Text::CSV;

    use Tab::NSDA::Login;
    use Tab::NSDA::Person;
    use Tab::NSDA::PersonSchool;
    use Tab::NSDA::MemberSchool;

	my %ignore_me = map {$_ => 1} ( 
		"fees",
		"judcommit",
		"outcomes",
		"pairopts",
		"restrictions",
		"roomavails",
		"rsvps",
		"seeds",
		"seqstrs",
		"sweeps",
		"team4s",
		"todos",
		"actions",
		"bag"
	);

	my %fucked_joy_rounds = (
		1  => "prelim",
		2  => "prelim",
		3  => "prelim",
		4  => "prelim",
		5  => "prelim",
		11 => "prelim",
		12 => "prelim",
		13 => "prelim",
		14 => "prelim",
		15 => "prelim",
		17 => "elim",
		10 => "elim",
		9  => "elim",
		6  => "elim",
		7  => "elim",
		16 => "elim",
		8  => "final"
	);

	my $csv = Text::CSV->new({ sep_char => ',' });

    # Get the upload and create the file handle.
    my $req = Apache2::Request->new($r);
    my @csv_handles = $r->upload; 

    my $csv_file = $req->upload($csv_handles[0]);
    my $io = $csv_file->io;

    my @lines = <$io>;
    my @all_lines;

	my $now = DateTime->now();
	my $this_year = $now->year;
	$this_year++ if $now->month > 7;

    foreach (@lines) { 
        $_ =~ s/[\r]+/\n/g;
        $_ =~ s/[\r\n]+/\n/g;
        $_ =~ s/[\n]+/\n/g;
        push @all_lines, split (/\n/, $_);
    }

	my @results;
	my @changes;

	my %segments;

	my $next_header;
	my $segment_key;
	my $segment_label;

	my $district_id = $tourn_settings->{"nsda_district"};
	my $district = Tab::District->retrieve($district_id);

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	# I cannot believe I have to worry about the order this file is in but in
	# some cases the order of the data actually friggin matters. 

	# I was Hitler in a past life or something. 
	my $order = 0;

	foreach my $line (@lines) { 
		chomp $line;
		if ($line eq '!#:----------:#!') { 
			$next_header++;
		} elsif ($next_header) { 
			($segment_label, $segment_label) = split(':', $line);
			undef $next_header;
		} elsif ($ignore_me{$segment_label}) { 
			# DO NOTHING I TELL YOU.  NOTHING.
		} else { 
			$segments{$segment_label}{$order++} = $line;
		}
	}

	my %tourn_settings;

	foreach my $linekey (sort keys %{$segments{"TRN"}}) { 
		my $line = $segments{"TRN"}{$linekey};
		my ($key, $value) = split("=", $line);
		next unless $value;
		$tourn_settings{$key} = $value;
		$ignore_me{"TRN"}++;
	}

	Tab::TournSite->set_sql( delete_blanks => "
		delete from tourn_site
		where tourn = ? 
		and site = 0
	");

	Tab::TournSite->sql_delete_blanks->execute($tourn->id);

	my @sites = $tourn->sites;

	my $default_site;
	$default_site = shift @sites if @sites;

	my $default_weekend_site;

	unless ($default_site > 0) { 

		$default_site = Tab::Site->create({ 
			name => $tourn->name." site",
			host => $person->id
		});

		Tab::TournSite->create({
			tourn => $tourn->id,
			site  => $default_site->id
		});

	}

	undef $segments{"actions"};
	undef $segments{"bag"};
	undef $segments{"fees"};
	undef $segments{"TRN"};

	my %judge_pools;

	#JUDGE CATEGORIES OR POOLS OR SOMESUCH.
	foreach my $linekey (sort keys %{$segments{"judprefs"}}) { 
		my $line = $segments{"judprefs"}{$linekey};

		next unless $csv->parse($line);

		my (
			$judge_id, $category
		) = $csv->fields();

		next if $judge_id eq "Judge ID";
		$judge_id = int($judge_id);
		$category = int($category);

		$judge_pools{$judge_id}{$category}++;

	}

	$ignore_me{"judprefs"}++;

	my $counter = 0;
	my %event_categories;

	$m->print('<div class="main">');

	$m->print("<h5>Importing for district ".$district->code." ".$district->name." </h5>") if $district;

	foreach my $judge (sort keys %judge_pools) { 

		my $standing_category;

		foreach my $event (sort keys %{$judge_pools{$judge}}) { 

			next if $event eq "Event ID";

			unless ($event_categories{$event}) { 

				unless ($standing_category) { 
					$counter++;
					$standing_category = $counter;
				}

				$event_categories{$event} = $standing_category;
			} 
		}
	}

	foreach my $category (1 .. $counter) { 

		my @events;

		foreach my $key (sort keys %event_categories) { 
			push @events, $event_categories{$key};
		}
	}

	my @all_events = $tourn->events;

	my %events;

	foreach my $test (@all_events) { 
		my $jot_id = int($test->setting('jot_id'));
		$events{$jot_id} = $test;
	}

	my $found = 0;
	my $created = 0;
	my %categories;
	my %event_web_ids;
	my $house;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing events</h6>");

	my %weekends;
	my %sites; 
	my %event_site;
	my %event_house_section;

	#EVENTS CATEGORIES
	LINE:
	foreach my $linekey (sort keys %{$segments{"events"}}) { 
		my $line = $segments{"events"}{$linekey};

		next unless $csv->parse($line);

		my (
			$internal_event_id, $event_name, $attributes, $entry_fee, $pattern, 
			$duration, $copies, $complete, $method, $drop_fee, $team_count,
			$entry_blank, $drop_fee2, $drop_fee3, $drop_fee4, $speaker_goal,
			$flags, $min_points, $max_points, $nfl, $tab_method, $rows, 
			$columns, $event_id, $performance, $web_type, $ballot_style, 
			$type, $prelim_method
		) = $csv->fields();

		next LINE if $internal_event_id eq "Event ID";

		$internal_event_id = int($internal_event_id);

		if ($event_id < 0) { 
			$event_web_ids{$internal_event_id} = $house;
		} else { 
			$event_web_ids{$internal_event_id} = $event_id;
		}

		if ($event_id < 0) { 
			my $section_number = $entry_blank;
			$section_number =~ s/[\D_]//g;
			$event_house_section{$internal_event_id} = $section_number;
			$m->print("<p class='bluetext semibold'>Section $section_number found for House event $internal_event_id</p>");
			next LINE;
		}

		if ($events{$event_id}) { 

			$found++;
			$m->print("<p class='greentext semibold marleft'>");
			$m->print("Yay! Found existing Tabroom event ".$events{$event_id}->abbr);
			$m->print(" with JOT ID $event_id</p>");

			if ($events{$event_id}->abbr eq "HOU") { 
				$house = $event_id;
				my $section_number = $entry_blank;
				$section_number =~ s/[\D_]//g;
				$event_house_section{$internal_event_id} = $section_number;
				$m->print("<p class='bluetext semibold'>Section $section_number found for House event $internal_event_id</p>");
			}

			my $category_code = $event_categories{$internal_event_id};
			$categories{$category_code} = $events{$event_id}->category;
			$categories{$category_code}->setting("jot_id", $category_code);

			$events{$event_id}->setting('code_style', "numbers");
			next LINE;
		}

		my $event;

		$m->print("<p class='marleft'>Searching for existing event $event_name ");
		$m->print("by name and abbreviation:</p>");

		if ($tourn_settings{"NFL"} == 1) { 

			if (substr($event_name, 0, 5) eq "House") { 

				$event = Tab::Event->search(
					tourn => $tourn->id,
					abbr  => "HOU"
				)->first;

				$house = $event_id;

			} else { 

				$event = Tab::Event->search(
					tourn => $tourn->id,
					abbr  => $entry_blank
				)->first;
			}

		} else {

			$event = Tab::Event->search(
				tourn => $tourn->id,
				name  => $event_name
			)->first;

			unless ($event) { 
				$event = Tab::Event->search(
					tourn => $tourn->id,
					abbr => $entry_blank
				)->first;
			}
			
		}

		$found++ if $event;

		my $category;

		unless ($event) { 
		
			$m->print("<p class='semibold orangetext marleft'>No event found for $event_name. ");
			$m->print("Creating an new event in Tabroom</p>");

			my $category_code = $event_categories{$internal_event_id};
			$category = $categories{$category_code};

			unless ($category) { 
				
				$category = Tab::Category->create({
					tourn => $tourn->id,
					name  => "Judges ".$category_code,
					abbr  => "J".$category_code,
				});

				$category->setting('jot_id', $category_code);
				$categories{$category_code} = $category;
			}

			my ($team, $type) = split(",", $attributes);

			if ($type eq "CONGRESS") { 
				$type = "congress";
			} elsif ($type eq "PAIR") { 
				$type = "debate";
			} elsif ($type eq "SECTION") { 
				$type = "speech";
			}

			$entry_fee = $entry_fee / 100;

			$event = Tab::Event->create({
				name     => $event_name,
				abbr     => $entry_blank,
				tourn    => $tourn->id,
				category => $category->id,
				type     => $type,
				fee      => $entry_fee
			});

			if ($team eq "TEAM") { 
				$event->setting("min_entry", 2);
				$event->setting("max_entry", 2);
			} else {
				$event->setting("min_entry", 1);
				$event->setting("max_entry", 1);
			}

			$created++;

		}

		if ($event) { 
		
			$event->setting('code_style', "numbers");

			$m->print("<p class='semibold bluetext'>Tabroom Event $event ".$event->abbr." designated for ");
			$m->print("JOT Event ID $event_id $event_name.</p>");

			my $category = $event->category;

			my $category_code = $event_categories{$internal_event_id};
			$categories{$category_code} = $category;
			$category->setting("jot_id", $category_code);

			$event->setting("jot_id", $event_id);
			$events{$event_id} = $event;

			if ($event->setting('weekend')) { 

				my $weekend = Tab::Weekend->retrieve($event->setting("weekend"));

				if ($weekend) { 

					$weekends{$weekend->id} = $weekend;

					my $site = $weekend->site;

					if ($site && $site > 0) { 

						unless ($default_weekend_site) { 
							$default_site = $site;
							$default_weekend_site++;
						}

						$event_site{$event_id} = $site;
						$sites{$site->id} = $site;
					} 
				}

			}

		} else { 
			$m->print("<p class='semibold redtext'> I was not able to find ");
			$m->print("or create $entry_blank: $event_name in Tabroom.</p>");
		}

	}

	my $unpooled = $tourn->categories(
		abbr => "XX",
		name => "Unpooled Judges"
	)->first;

	unless ($unpooled) { 
		$unpooled = Tab::Category->create({
			tourn => $tourn->id,
			abbr  => "XX",
			name  => "Unpooled Judges"
		});
	}

	# Fill in any un-sited events
	foreach my $event_id (sort keys %events) { 
		unless ($event_site{$event_id}) { 
			$event_site{$event_id} = $default_site;
			$sites{$default_site->id} = $default_site;
		}
	}

	undef $segments{"events"};
	$ignore_me{"events"}++;

	$m->print("<p class='semibold'>$found events found, $created events created</p>");

	$m->print("<h6 class='redtext semibold'>Importing schools</h6>");

	my %schools = map{ $_->setting("jot_id") => $_} $tourn->schools;
	my %school_web_ids;

	$found = 0;
	$created = 0;

	LINE:
	foreach my $linekey (sort keys %{$segments{"schools"}}) { 
		my $line = $segments{"schools"}{$linekey};

		next unless $csv->parse($line);

		my (
			$school_id, $code, $name, $coach, $squad_count, 
			$arrived, $division, $city, $phone, $fax, $coach_phone, 
			$notes, $status, $addr1, $addr2, $state, $zip, $email, 
			$flags, $district_code, $region, $other_coaches, $trophy_points, 
			$web_school_id, $cell_phone, $alt_email
		) = $csv->fields();

		next LINE if $school_id eq "School ID";

		$web_school_id = int($web_school_id);
		$found++ if $schools{$web_school_id};

		$school_id = int($school_id);
		$school_web_ids{$school_id} = $web_school_id;

		$m->print("<p class='semibold padleft martop'>Importing school ");
		$m->print("$name $web_school_id into this tournament.  Tagged to $school_id.</p>");

		next LINE if $schools{$web_school_id};

		if ($district) { 

			my $school = Tab::School->search(
				name     => $name,
				tourn    => $tourn->id,
				district => $district->id
			)->first;

			if ($school) { 
				$m->print("<p>School ".$school->name." found in ");
				$m->print("tournament for $name $web_school_id</p>");
			}

			unless ($school) { 

				# Chapter with the same name in the same district? 
				my $chapter;
				
				$chapter = Tab::Chapter->search(
					name     => $name,
					district => $district->id
				)->first;

				unless ($chapter) { 

					my $cs = Tab::ChapterSetting->search(
						tag   => "jot_id",
						value => $web_school_id
					)->first;

					$chapter = $cs->chapter if $cs;
				}

				my $tabroom_account;

				if ($chapter) {

					$m->print("<p class='greentext'>Found Tabroom school $chapter ".$chapter->name);
					$m->print(" from a previous import</p>");

				} else {

					$tabroom_account = Tab::Person->search( 
						email => $email
					)->first;

					unless ($tabroom_account) { 

						my $tabroom_login = Tab::Login->search(
							username => $email
						)->first;

						$tabroom_account = $tabroom_login->person 
							if $tabroom_login;
					}


					if ($tabroom_account) { 
					
						my @permissions = $tabroom_account->permissions( tag => "chapter" );

						my $short_name = Tab::short_name($name);

						foreach my $perm (@permissions) { 
							$chapter = $perm->chapter
								if $short_name eq $perm->chapter->short_name;
						}

					}
					
					if ($chapter && $tabroom_account) { 
						$m->print("<p class='greentext'>Found Tabroom school ");
						$m->print("$chapter ".$chapter->name." belonging ");
						$m->print("to the Tabroom account $email </p>");
					}

					if ($chapter && ($chapter->nsda < 1)) { 

						my $nsda_school = $m->comp(
							"/funclib/nsda_school.mas", 
							name        => $name,
							district_id => $district->id
						);

						$chapter->nsda($nsda_school->school_id) 
							if $nsda_school;

						$chapter->district($district->id);
						$chapter->update();

						push @changes, $chapter->id." linked to this district and NSDA school ".$chapter->nsda;

					}

				}

				unless ($chapter) { 

					my $nsda_school = $m->comp(
						"/funclib/nsda_school.mas", 
						name        => $name,
						district_id => $district->id
					);

					if ($nsda_school) { 

						$chapter = Tab::Chapter->search(
							nsda => $nsda_school->school_id
						)->first;

						unless ($chapter) { 

							my $nome;
							$nome++ unless $tabroom_account;

							$chapter = $m->comp(
								"/funclib/chapter_import.mas",
								nsda_school => $nsda_school,
								person      => $tabroom_account,
								nome        => $nome
							);

							my $change_result = $district->name." imported NSDA chapter $chapter ".$chapter->name;
							$change_result   .= " for NSDA School ID ".$chapter->nsda;

							if ($tabroom_account) { 
								$change_result .= " with person $tabroom_account (".$tabroom_account->email.") ";
								$change_result .= " with access" 
							} else { 
								$change_result .= " <br />No tabroom account found for $coach:  $email";
								$change_result .= " so no coach access granted.";
							}

							$m->print("<p class='semibold bluetext'>".$change_result."</p>");
							push @changes, $change_result;

						}
					}
				}

				unless ($chapter) { 

					$chapter = Tab::Chapter->create({
						name     => $name,
						street   => $addr1,
						city     => $city,
						state    => $state,
						zip      => $zip,
						country  => "US",
						coaches  => $coach,
						district => $district_id
					});

					if ($tabroom_account) { 
						Tab::Permission->create({
							person  => $tabroom_account->id,
							tag     => "chapter",
							chapter => $chapter->id
						});
					}

					$m->print("<p class='semibold redtext'>No school found in Tabroom or the NSDA.");
					$m->print(" Created new Tabroom school ID $chapter for $name $web_school_id");
					$m->print(" and granted admin access to $tabroom_account $email") if $tabroom_account;
					$m->print("</p>");

				}

				if ($chapter) { 

					$school = $chapter->schools( 
						tourn   => $tourn->id,
						chapter => $chapter->id
					)->first;

					unless ($school) { 
						$school = Tab::School->create({
							name     => $name,
							code     => $code,
							onsite   => $arrived,
							chapter  => $chapter->id,
							tourn    => $tourn->id,
							state    => $state,
							district => $district->id
						});

						$created++;
					}	
						
					$chapter->setting("jot_id", $web_school_id);

					$school->setting("state", $state);
					$school->setting("contact_name", $coach);
					$school->setting("contact_phone", $coach);
					$school->setting("contact_email", $email)

				}

			}

			if ($school) { 
				$school->setting("jot_id", $web_school_id);
				$schools{$web_school_id} = $school;
			} else { 
				$m->print("<p class='redtext semibold'>Failed utterly with $name $web_school_id</p>");
			}
		}
	}

	undef $segments{"schools"};
	$ignore_me{"schools"}++;

	my %tiebreak_sets = 
		map {$_->name => $_}
		$tourn->tiebreak_sets();

	$m->print("<p class='semibold'>$found schools found, $created created</p>");

	my %timeslots = 
		map {$_->start->epoch => $_} 
		$tourn->timeslots();

	undef $counter;
	$counter = scalar(keys %timeslots);

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing rounds and timeblocks</h6>");

	my %rounds;
	my %rounds_by_name;

	# ROUNDS TIMEBLOCKS:
	foreach my $linekey (sort keys %{$segments{"evrd"}}) { 
		my $line = $segments{"evrd"}{$linekey};

		next unless $csv->parse($line);

		my (
			$internal_event_id, $round_id, $no, $idea, $round_name, 
			$date, $time, $draw, 
			$flip, $panel, $flight, $panel_size, 
			$auto_flight, $attr, $user_flags
		) = $csv->fields();

		next if $internal_event_id eq "Event ID";

		$internal_event_id = int($internal_event_id);
		$round_name = int($round_name);
		$round_id = int($round_id);
		$flight = int($flight);

		my $event_id = $event_web_ids{$internal_event_id};
		my $event = $events{$event_id};

		unless ($event) { 
			$m->print("<p>Event $event_id is not found</p>");
			$m->abort();
		}

		foreach ($date, $time, $draw) { 
			$_ =~ s/^\s+//;
			$_ =~ s/\s+$//;
		}

		$date =~ s/-/\//g;
		my ($hour, $minutes) = split(":", $time);

		unless ($rounds_by_name{$event_id}) { 
			%{$rounds_by_name{$event_id}} = 
				map {$_->name => $_} 
				$event->rounds();
		}

		unless ($rounds{$event_id}) { 
			%{$rounds{$event_id}} = 
				map {$_->setting("jot_id") => $_} 
				$event->rounds();
		}

		# Motherfucker
		my $ampm = substr($minutes, -2);
		$minutes = substr($minutes, 0, -2);

		my $start_time = eval { 
			return Tab::dtme($date, "$hour:$minutes".uc($ampm), $tz);
		};

		$m->print("<p class='marleftmore'>".$event->abbr);
		$m->print(" Round $round_name started at $start_time: ");

		unless ($timeslots{$start_time->epoch}) { 

			my $end_time = $start_time->clone();
			$end_time->add( hours => 1);

			$counter++;

			my $timeslot = Tab::Timeslot->create({ 
				tourn => $tourn,
				name  => "Timeslot $counter",
				start => $start_time,
				end   => $end_time
			});

			$timeslots{$start_time->epoch} = $timeslot;

		}

		unless ($event) { 
			$m->print("<p class='redtext semibold'>No event found for $event_id.  House is $house</p>");
			$m->abort();
		}

		my $round_type; 

		if ($district 
			&& $event->type eq "speech"
			&& $tourn_settings->{"nsda_speech_method"} eq "doubledown"
		) { 
			$round_type = $fucked_joy_rounds{$round_name};
			$round_type = "elim" if $round_name > 2 && $round_name < 6; 
			$round_type = "elim" if $round_name > 10 && $round_name < 16; 
		} else { 
			$round_type = $fucked_joy_rounds{$round_name};
		}

		my $round;

		my $tiebreak_set;

		if ($event->type eq "congress") { 

			if ($round_type eq "prelim") { 
				$tiebreak_set = $tiebreak_sets{"Congress Prelim"};
			} elsif ($round_type eq "elim") { 
				$tiebreak_set = $tiebreak_sets{"Congress Elim"};
			} elsif ($round_type eq "final") { 
				$tiebreak_set = $tiebreak_sets{"Congress Final"};
			}
		} elsif ($event->type eq "speech") { 
			if ($round_type eq "prelim") { 
				$tiebreak_set = $tiebreak_sets{"IE Prelim"};
			} elsif ($round_type eq "elim") { 
				$tiebreak_set = $tiebreak_sets{"IE Semi"};
				$tiebreak_set = $tiebreak_sets{"IE Elim"} unless $tiebreak_set;
				$tiebreak_set = $tiebreak_sets{"IE Prelim"} unless $tiebreak_set;
			} elsif ($round_type eq "final") { 
				$tiebreak_set = $tiebreak_sets{"IE Final"};
				$tiebreak_set = $tiebreak_sets{"IE Elim"} unless $tiebreak_set;
			}

		} else { 

			if ($round_type eq "elim") { 
				$tiebreak_set = $tiebreak_sets{"Debate Elim"};
				$tiebreak_set = $tiebreak_sets{"Debate Elims"} unless $tiebreak_set;
			} elsif ($round_type eq "final") { 
				$tiebreak_set = $tiebreak_sets{"Debate Final"};
				$tiebreak_set = $tiebreak_sets{"Debate Finals"} unless $tiebreak_set;
				$tiebreak_set = $tiebreak_sets{"Debate Elim"} unless $tiebreak_set;
				$tiebreak_set = $tiebreak_sets{"Debate Elims"} unless $tiebreak_set;
			} else { 
				$tiebreak_set = $tiebreak_sets{"Debate Prelim"};
				$tiebreak_set = $tiebreak_sets{"Debate"} unless $tiebreak_set;
			}

		}

		if ($rounds_by_name{$event_id}{$round_name}
			|| $rounds{$event_id}{$round_id}
		) { 

			$round = $rounds{$event_id}{$round_id};

			unless ($round) { 
				$round = $rounds_by_name{$event_id}{$round_name};
				$round->setting("jot_id", $round_id);
			}

			my $timeslot = $timeslots{$start_time->epoch};

			unless ($round->timeslot->id == $timeslot->id) { 
				$round->timeslot($timeslot->id);
			}

			$round->type($round_type);
			$round->site($event_site{$event_id});
			$round->tiebreak_set($tiebreak_set);
			$round->update();

			$m->print(" Round already exists with ID ".$round->id."</p>");

		} else { 

			$round = Tab::Round->create({
				name         => $round_name,
				type         => $round_type,
				flighted     => $flight,
				published    => 0,
				post_results => 0,
				start_time   => $start_time,
				event        => $event->id,
				timeslot     => $timeslots{$start_time->epoch}->id,
				site         => $event_site{$event_id}
			});


			$m->print(" Created round ".$round->name." as a ");
			$m->print($round_type." round in ".$event->abbr."</p>");

			$round->setting("jot_id", $round_id);
			$rounds{$event_id}{$round_id} = $round;
			$rounds_by_name{$event_id}{$round_name} = $round;

		}

		# Dump the round's current sections and results if any

		$m->comp("/funclib/round_dump.mas", 
			person => $person,
			round  => $round
		);
	}

	undef $segments{"evrd"};
	$ignore_me{"evrd"}++;

	undef $counter;

	foreach my $key (sort keys %timeslots) { 
		$counter++;
		$timeslots{$key}->name("Timeslot ".$counter);
		$timeslots{$key}->update();
	}

	my %rooms;
	my %site_rooms;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing rooms and sites </h6>");
	$m->print("<p class='bluetext bigger semibold'>The default site for new rooms ");
	$m->print("is ".$default_site." ".$default_site->name."</p>");

	# ROOMS
	foreach my $linekey (sort keys %{$segments{"rooms"}}) { 
		my $line = $segments{"rooms"}{$linekey};

		next unless $csv->parse($line);

		my (
			$room_id, $room_name, $hall, $notes, $flags, $other_flags
		) = $csv->fields();

		next if $room_id eq "Room ID";

		$room_id = int($room_id);

		# Hunt for an existing room named this:
		foreach my $key (sort keys %sites) { 

			last if $rooms{$room_id};

			my $site = $sites{$key};

			unless ($site_rooms{$key}) { 
				@{$site_rooms{$key}} = $site->rooms();
			}

			foreach my $room (@{$site_rooms{$key}}) { 

				if (
					$room->notes == $room_id
				 	|| $room_name eq $room->name
				) { 
					$rooms{$room_id} = $room;
					last;
				}
			}
		}

		#If it isn't found create one:

		if ($rooms{$room_id}) { 

			if ($rooms{$room_id}->deleted) { 
				$rooms{$room_id}->deleted(0);
				$rooms{$room_id}->update();
			}

			$m->print("<p> Room JOT ID $room_id: ".$rooms{$room_id}->name." ".$rooms{$room_id}->id);
			$m->print(" found in site ".$rooms{$room_id}->site->name."</p>");

		} else { 

			$rooms{$room_id} = eval {
				return Tab::Room->create({
					name     => $room_name,
					site     => $default_site->id,
					notes    => $room_id,
					capacity => 0,
					quality  => 10,
					inactive => 0,
					deleted  => 0
				});
			};

			if ($rooms{$room_id}) { 
				$m->print("<p class='greentext'>No room $room_name found.");
				$m->print(" Created one in Tabroom site ".$default_site->name."</p>");
			} else { 
				$m->print("<p class='redttext'>No room $room_name found and I was unable to create one</p>");
			}
		}
	}

	undef $segments{"rooms"};
	$ignore_me{"rooms"}++;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing judges</h6>");

	my @all_judges = $m->comp("/funclib/tourn_judges.mas", tourn => $tourn);

	my %judges;
	my %judge_category;
	my %judge_web_ids = ();

	foreach my $judge (@all_judges) { 
		my $jot_id = $judge->setting("jot_id");
		push @{$judges{$jot_id}}, $judge if $jot_id;
	}

	foreach my $linekey (sort keys %{$segments{"judges"}}) { 

		my $line = $segments{"judges"}{$linekey};

		next unless $csv->parse($line);

		my (
			$internal_judge_id, $internal_school_id, $name, $message, $options, $round_limit, 
			$flags, $private_note, $phone1, $phone2, $email, $region, $district, 
			$obligation, $base_priority, $rating, $user_flags, $cell_phone, 
			$pager, $code, $judge_id, @bullshit
		) = $csv->fields();


		$judge_id = int($judge_id);
		$internal_judge_id = int($internal_judge_id);
		$internal_school_id = int($internal_school_id);

		next if $internal_judge_id eq "Judge ID";

		$judge_id = $tourn->id."-".$internal_judge_id if $judge_id == -1;
		$judge_web_ids{$internal_judge_id} = $judge_id;

		my @already;
		@already = @{$judges{$judge_id}} if $judges{$judge_id};

		my $chapter_judge;
		my $hired;
		my $school_id;
		my $school;

		if ($internal_school_id == -1) { 
			$hired++;
			$school_id = 0;
		} else { 
			$school_id = $school_web_ids{$internal_school_id};
			$school = $schools{$school_id};
		}

		my $person;

		if ($email) { 

			$person = Tab::Person->search( 
				email => $email
			)->first;

			unless ($person) { 
				my $login = Tab::Login->search( 
					username => $email
				)->first;
				$person = $login->person if $login;
			}
		}

		# So someone who stores middle names and salutations in the database
		# munges them all into one field in the application.  Sigh. 

		# I'm going to only use first and last for searching because otherwise
		# this will reach a higher level of ridiculous than it already has. 

		my @names = split(/\ /, $name);
		my $first;
		my $last;
		my $middle;

		$first = shift @names if @names;
		$last = pop @names if @names;
		$middle = join(" ", @names);

		if ($school) { 

			if (@already) { 

				$chapter_judge = $already[0]->chapter_judge;

			} else { 

				my $chapter = $school->chapter;

				$chapter_judge = $chapter->chapter_judges(
					person => $person->id
				)->first if $person;

				$chapter_judge = $chapter->chapter_judges(
					first => $first,
					last  => $last
				)->first unless $chapter_judge;

				unless ($chapter_judge) { 

					$chapter_judge = Tab::ChapterJudge->create({
						first   => $first,
						middle  => $middle,
						last    => $last,
						retired => 0,
						phone   => $cell_phone,
						email   => $email,
						person  => $person,
						chapter => $chapter
					});

				}

			}

			if ($chapter_judge && $person) { 

				unless ($chapter_judge->person) { 
					$chapter_judge->person($person->id);
					$chapter_judge->update();
				}

			}

		} else { 
			$school = 0;
			$chapter_judge = 0;
		}

		my %already;
		my $judge;

		foreach my $internal_event_id (sort keys %{$judge_pools{$internal_judge_id}}) { 

			my $category_code = $event_categories{$internal_event_id};
			my $category = $categories{$category_code};

			unless ($already{$category}++) { 

				$m->print("<p class='greentext'>Judge $judge_id $first $last entered into judge category ".$category->abbr."</p>");

				$judge = Tab::Judge->search(
					person => $person->id
				)->first if $person;

				$judge = Tab::Judge->search(
					school        => $school,
					category      => $category,
					chapter_judge => $chapter_judge,
					first         => $first,
					middle        => $middle,
					last          => $last,
				)->first unless $judge;

				if ($judge) { 

					if ($person && $person != $judge->person) { 
						$judge->person($person->id);
						$judge->update();
					}
					

				} else { 

					$judge = Tab::Judge->create({
						first         => $first,
						middle        => $middle,
						last          => $last,
						active        => 1,
						obligation    => 9,
						hired         => 0,
						school        => $school,
						category      => $category,
						chapter_judge => $chapter_judge
					});

				}

				if ($judge) { 
					$judge->setting("jot_id", $judge_id);
					push @{$judges{$judge_id}}, $judge;
					$judge_category{$judge_id}{$category->id} = $judge;
				}

			}

		}

		unless (keys %{$judge_pools{$internal_judge_id}}) { 

			$judge = Tab::Judge->search(
				person => $person->id
			)->first if $person;

			$judge = Tab::Judge->search(
				school        => $school,
				category      => $unpooled,
				chapter_judge => $chapter_judge,
				first         => $first,
				middle        => $middle,
				last          => $last,
			)->first unless $judge;

			$judge = Tab::Judge->create({
				first         => $first,
				middle        => $middle,
				last          => $last,
				active        => 1,
				obligation    => 9,
				hired         => 0,
				school        => $school,
				category      => $unpooled,
				chapter_judge => $chapter_judge
			}) unless $judge;

			$judge->setting("jot_id", $judge_id);

			push @{$judges{$judge_id}}, $judge;
			$judge_category{$judge_id}{$unpooled->id} = $judge;
			
			$m->print("<p class='semibold bluetext'>Judge $judge_id $first $last ");
			$m->print("had no event pools; entered into the ".$unpooled->name." category</p>");

		}

		unless ($judge) { 
			$m->print("<p class='semibold redtext'>Unable to import Judge ".$first." ".$last."</p>");
		}
	}

	undef $segments{"judges"};
	$ignore_me{"judges"}++;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing competitors</h6>");

	my @all_students = $m->comp(
		"/funclib/tourn_students.mas", 
		tourn => $tourn
	);

	my %students; 
	my %student_web_ids;
	my %student_tags;

	foreach my $student (@all_students) { 

		my $jot_id = $student->setting("jot_id");

		if ($jot_id) { 
			$students{$jot_id} = $student;
		}

		$student_tags{$student->chapter->id}{$student->first}{$student->last} = $student;
		
	}

	my %name_codes;

	foreach my $linekey (sort keys %{$segments{"names"}}) { 
		my $line = $segments{"names"}{$linekey};

		next unless $csv->parse($line);

		my (
			$internal_student_id, $internal_school_id, $name, $code, $student_id
		) = $csv->fields();

		next if $internal_student_id eq "Name ID";
		$name_codes{int($internal_student_id)} = $code;

		# This function filters out some nonsense about pairs/teams:
		next if (index($name, ' - ') != -1);

		$student_id = int($student_id);
		$internal_student_id = int($internal_student_id);
		$student_web_ids{$internal_student_id} = $student_id;

		next if $students{$student_id};

		$internal_school_id = int($internal_school_id);
		my $school_id = $school_web_ids{$internal_school_id};
		my $school = $schools{$school_id};

		my @names = split(/\ /, $name);
		my $first;
		my $last;
		my $middle;

		$first = shift @names if @names;
		$last = pop @names if @names;
		$middle = join(" ", @names);

		$m->print("<p>Seeking competitor $student_id $name in school $school_id ".$school->name.": ");

		if ($student_tags{$school_id}{$first}{$last}) { 

			my $student = $student_tags{$school_id}{$first}{$last};
			$m->print("Found ".$student->id." already in the tournament.</p>");

			$student->setting("jot_id", $student_id);
			$students{$student_id} = $student;

		} else { 

			my $candidate;

			my $chapter = $school->chapter;

			my @students = $chapter->students(
				first => $first,
				last  => $last
			);

			foreach my $student (@students) { 

				next if $student->retired;

				next if $student->grad_year > 1900
					&& $student->grad_year < $this_year; 

				if ($student->ualt_id
					&& $candidate && (not defined $candidate->ualt_id)
				) { 
					$candidate = $student;
				} 

				$candidate = $student unless $candidate;
			}

			my $search_nsda; 

			unless ($candidate) { 

				$m->print("<p class='orangetext semibold'>No competitor found with name $first $last.");
				$m->print(" Creating in Tabroom</p>");

				$candidate = Tab::Student->create({
					first   => $first,
					middle  => $middle,
					last    => $last,
					chapter => $chapter,
					novice  => 0,
					retired => 0
				});

				$search_nsda++;
				
				$m->print("<p class='marleft'> &ndash; Trying to link ");
				$m->print("new competitor to NSDA membership: ");

			} elsif ($candidate->ualt_id < 1) { 

				$m->print("<p class='marleft'> &ndash; Existing competitor does ");
				$m->print("not have an NSDA membership linked. Searching: ");
				$search_nsda++;
			}

			if ($search_nsda) { 

				my $nsda = $m->comp(
					"/funclib/nsda_student_search.mas", 
					chapter => $chapter,
					first   => $first,
					last    => $last
				);

				if ($nsda) { 

					$m->print("<span class='inline greentext semibold'>Found NSDA ");
					$m->print("member ".$nsda->ualt_id." and linking.</p>");

					$candidate->grad_year($nsda->grad_yr);
					$candidate->ualt_id($nsda->ualt_id);
					$candidate->update();

					if ($nsda->paid_status) { 
						$candidate->setting("nsda_paid", 1);
					} else { 
						$candidate->setting("nsda_paid", "X");
					}

					if ($nsda->total_pts) { 
						$candidate->setting("nsda_points", $nsda->total_pts);
					} else { 
						$candidate->setting("nsda_points", "X");
					}

					my $joined = eval{
						return DateTime::Format::MySQL->parse_datetime($nsda->high_joined);
					};

					if ($joined) { 
						$candidate->setting("nsda_joined", "date", $joined);
					} else { 
						$candidate->setting("nsda_joined", "X");
					}

					my $test_person;

					if ($candidate->person) { 

						$candidate->setting("student_email", $candidate->person->email);
					
					} elsif ($nsda->demo) { 

						$candidate->setting("student_email", $nsda->demo);
						$test_person = $nsda->demo;
					
					} elsif ($nsda->login) { 

						$test_person = $nsda->login;
						$candidate->setting("student_email", $nsda->login);

					} else { 
						$candidate->setting("student_email", "X");
					}

					if ($test_person) { 
						my $person = Tab::Person->search( 
							email => $test_person
						)->first;

						unless ($person) { 
							my $login = Tab::Login->search( 
								username => $test_person
							)->first;
						}
					}

				} elsif ($district) { 

					$m->print("<span class='inline redtext semibold'>No matching NSDA member ");
					$m->print("found.  Reconciliation will be required for Districts.</p>");
				}

			} else { 
				
				$m->print("<span class='semibold greentext'>Found competitor $candidate ");
				$m->print("with NSDA membership ".$candidate->ualt_id." linked.</p>");

			}

			$candidate->setting("jot_id", $student_id);
			$students{$student_id} = $candidate;

		}
	}

	undef $segments{"names"};
	$ignore_me{"names"}++;

	my %teams = ();

	foreach my $linekey (sort keys %{$segments{"teams"}}) { 
		my $line = $segments{"teams"}{$linekey};

		next unless $csv->parse($line);

		my ( $internal_entry_id, $internal_student_id 
		) = $csv->fields();

		next if $internal_entry_id eq "Entry ID";

		my $student_id = $student_web_ids{int($internal_student_id)};
		push @{$teams{int($internal_entry_id)}}, $student_id;
	}

	undef $segments{"teams"};
	$ignore_me{"teams"}++;

	my %entry_web_ids;
	my %entries;
	my %entry_tags;

	my @all_entries = $m->comp(
		"/funclib/tourn_entries.mas", 
		tourn => $tourn
	);

	foreach my $entry (@all_entries) { 
		my $jot_id = $entry->setting("jot_id");
		$entries{$jot_id} = $entry if $jot_id;
		push @{$entry_tags{$entry->school->id}{$entry->event->id}}, $entry;
	}

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing entries</h6>");

	# Can't spell entries apparently. 
	ENTRY:
	foreach my $linekey (sort keys %{$segments{"entrys"}}) { 
		my $line = $segments{"entrys"}{$linekey};

		next unless $csv->parse($line);

		my ( 
			$internal_entry_id, $internal_school_id, $internal_event_id, $squad_seq, 
			$internal_student_id, $flags, $apparently_not_a_code, $user_flags, 
			$entry_id, $seed
		) = $csv->fields();

		next if $internal_entry_id eq "Entry ID";

		my $event_id = $event_web_ids{int($internal_event_id)};
		my $school_id = $school_web_ids{int($internal_school_id)};
		my $student_id = $student_web_ids{int($internal_student_id)};

		unless ($entry_id) { 
			$entry_id = $tourn->id."-".$internal_entry_id;
		} 

		$entry_web_ids{int($internal_entry_id)} = $entry_id;

		my $entry = $entries{$entry_id};
		my $code = $name_codes{int($internal_student_id)};

		unless ($entry) { 

			my $event = $events{$event_id};
			my $school = $schools{$school_id};

			my %entry_students;

			if ($teams{int($internal_entry_id)}) { 

				foreach my $student_id (@{$teams{int($internal_entry_id)}}) { 
					$entry_students{$students{$student_id}->id} = $students{$student_id};
				}
			} else { 

				my $student = $students{$student_id};
				$entry_students{$students{$student_id}->id} = $students{$student_id};
			}
	
			EXISTS:
			foreach my $existing (@{$entry_tags{$school->id}{$event->id}}) { 

				my %existing_students = map {$_->id => 1} $existing->students;

				foreach my $key (keys %existing_students) { 
					next EXISTS unless $entry_students{$key};
				}
				foreach my $key (keys %entry_students) { 
					next EXISTS unless $existing_students{$key};
				}

				$entry = $existing;
				last EXISTS if $entry;
			}

			if ($entry) { 
				$m->print("<p>$internal_entry_id Entry $code already exists! ");
			} else { 

				$m->print("<p>Entry $code does not exist.  Importing to Tabroom: ");

				$entry = Tab::Entry->create({
					code          => $code,
					tba           => 0,
					dropped       => 0,
					waitlist      => 0,
					unconfirmed   => 0,
					dq            => 0,
					created_at    => $now,
					tourn         => $tourn->id,
					event         => $event->id,
					school        => $school->id,
					registered_by => $person->id,
				});

				foreach my $key (keys %entry_students) { 
					Tab::EntryStudent->create({
						entry   => $entry->id,
						student => $entry_students{$key}->id
					});
				}

				$entry->name($m->comp("/funclib/entry_name.mas", entry => $entry));
			}

			if ($entry) { 

				$entry->code($code);
				$entry->update();
				$entries{$entry_id} = $entry;
				$m->print("<span class='inline semibold greentext marleft'>Succeeded!</p>");

			} else { 
				$m->print(" <span class='inline semibold redtext'>Import failed!</p>");
			}
		}
	}

	undef $segments{"entrys"};
	$ignore_me{"entrys"}++;

	my %sections;
	my %section_by_id;
	my %section_data;
	my %sections_by_tag;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold marbottom'>Importing sections/debates/chambers</h6>");

	my %event_counter;
	my $overall;

	# I hate that this is necessary.  It looks unnecessary.  But wait until you
	# see the judge nightmare below. 

	my %section_translator;
	my %section_event; 
	my %section_type; 

	my %congress_round_section;

	SECTION:
	foreach my $linekey (sort keys %{$segments{"sections"}}) { 

		my $line = $segments{"sections"}{$linekey};

		next unless $csv->parse($line);

		my ( 
			$section_id, $internal_event_id, $round_id, $room_id, 
			$letter, $num_judges, $dunno, $noclue
		) = $csv->fields();

		next if $section_id eq "Section ID";

		$section_id = int($section_id);
		$room_id = int($room_id);
		$letter =~ s/\s+//g;

		my $event_id = $event_web_ids{int($internal_event_id)};
		my $room = $rooms{$room_id};
		my $event = $events{$event_id};

		if ($event->type eq "congress") { 

			$round_id = abs($round_id);
			my $actual = $internal_event_id."-".$round_id;

			$section_translator{$section_id} = $actual;
			$section_id = $actual;

			next SECTION if $room_id == -1;
			
			$letter = $event_house_section{$internal_event_id}
				if $event_house_section{$internal_event_id};

		} elsif ($round_id < 0) { 
			next SECTION;
		} 

		$round_id = int($round_id);
		my $round = $rounds{$event_id}{$round_id};

		my $section = Tab::Panel->create({
			round  => $round->id,
			letter => $letter,
			bye    => 0,
			room   => $room,
			score  => $section_id
		});

		$event_counter{$event->abbr}++;

		$section_by_id{$section->id} = $section;
		$sections{$section_id} = $section;

		$section_event{$section->id} = $event;
		$section_type{$section->id} = $event->type;

		$sections_by_tag{$event_id}{$round_id}{"object"} = $section;
		$sections_by_tag{$event_id}{$round_id}{"id"}     = $section_id;

		$section_data{$section->id}{"room"}      = $room;
		$section_data{$section->id}{"event"}     = $event;
		$section_data{$section->id}{"round"}     = $round;
		$section_data{$section->id}{"roundname"} = $round->name;

	}

	undef $segments{"sections"};
	$ignore_me{"sections"}++;

	foreach my $abbr (sort keys %event_counter) { 
		$m->print("<p class='semibold bluetext'> ");
		$m->print("Created $event_counter{$abbr} sections of $abbr</p>");
	}

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold marbottom'>Assigning judges and entries to sections</h6>");

	my %section_judges;

	# Sure let's needlessly renumber all the judges for NO APPARENT REASON

	SECTION:
	foreach my $linekey (sort keys %{$segments{"judsects"}}) { 

		my $line = $segments{"judsects"}{$linekey};

		next unless $csv->parse($line);

		my ( 
			$internal_judge_id, $section_id, $yet_another_fucking_judge_id
		) = $csv->fields();

		next if $internal_judge_id eq "Judge ID";

		$section_id = $section_translator{$section_id} 
			if $section_translator{$section_id};

		my $section = $sections{$section_id};

		next unless $section;

		my $round = $section->round;
		my $event = $round->event;
		my $category = $event->category;

		my $judge_id = $judge_web_ids{int($internal_judge_id)};

		my $judge = $judge_category{$judge_id}{$category->id};

		$judge = $judge_category{$judge_id}{$unpooled->id} 
			unless $judge;

		unless ($judge) { 
		
			foreach my $other_judge (@{$judges{$judge_id}}) { 
				$judge = $other_judge if $other_judge > 0;
				last if $judge;
			} 
		} 

		if ($judge) { 

			$section_judges{$section->id}{"yafj"}{$yet_another_fucking_judge_id} = $judge
				if $yet_another_fucking_judge_id;
			$section_judges{$section->id}{"real"}{$judge_id} = $judge;
		}
	}

	$ignore_me{"judsects"}++;

	my %section_entries;
	my %section_byes;

	SECTION:
	foreach my $linekey (sort keys %{$segments{"sectents"}}) { 

		my $line = $segments{"sectents"}{$linekey};

		next unless $csv->parse($line);

		my ( 
			$section_id, $internal_entry_id, $speaker_order, $speaker_actual,$id
		) = $csv->fields();

		next if $section_id eq "Section ID";

		$section_id = $section_translator{$section_id}
			if $section_translator{$section_id};

		my $section = $sections{$section_id};
		next unless $section;

		my $entry_id = $entry_web_ids{int($internal_entry_id)};
		my $entry = $entries{$entry_id};

		$section_byes{$section->id}++ if $internal_entry_id < 0;

		my $event = $section_event{$section->id};

		if ($event->type eq "congress") { 

			while ($section_entries{$section->id}{$speaker_order}) { 
				$speaker_order++;
			}

			push @{$section_entries{$section->id}{$speaker_order}}, $entry;

		} else { 
			push @{$section_entries{$section->id}{$speaker_order}}, $entry;
		}

	}

	$ignore_me{"sectents"}++;
	my %section_results;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold marbottom'>Parsing actual results</h6>");

	my %section_chair;

	SECTION:
	foreach my $linekey (sort keys %{$segments{"jse"}}) { 

		my $line = $segments{"jse"}{$linekey};

		next unless $csv->parse($line);

		my ( 
			$internal_judge_id, $section_id, $internal_entry_id, $points, $rank, $points1, $points2
		) = $csv->fields();

		next if $internal_judge_id eq "Judge ID";
		$internal_judge_id = int($internal_judge_id);

		$section_id = $section_translator{$section_id}
			if $section_translator{$section_id};

		my $section = $sections{$section_id};

		next unless $section;

		my $judge_id = $judge_web_ids{int($internal_judge_id)};

		my $judge;

		$judge = $section_judges{$section->id}{"real"}{$judge_id} if $judge_id;

		unless ($judge) { 
			$judge = $section_judges{$section->id}{"yafj"}{$internal_judge_id};
		}

		next unless $judge;

		my $entry = $entries{$entry_web_ids{int($internal_entry_id)}};
		my $event = $section_event{$section->id};

		if ($event->type eq "congress") { 

			$section_results{$section->id}{$judge->id}{$entry->id}{"rank"} = int($points);

			$rank = int($rank) - 1000000;
			my $actual_points = parse_congress_bullshit($rank);

			$points1 = int($points1);
			my $spare_points;

			if ($points1 > 0) { 
				$spare_points = parse_congress_bullshit($points1);
			}

			if ($spare_points) { 

				my @originals = split(',', $actual_points);
				my @adds = split (',', $spare_points);

				undef $actual_points;

				while (@originals) {
					my $stuff = shift @originals;

					my $extra;
					$extra = shift @adds if @adds;
					$stuff = $stuff + $extra if $extra; 
					$actual_points .= "," if $actual_points;
					$actual_points .= $stuff;
				}
			}

			$section_results{$section->id}{$judge->id}{$entry->id}{"points"} = $actual_points;
			$section_chair{$section->id}{$judge->id}++ if $internal_judge_id == 1;

		} elsif ($event->type eq "speech") { 

			if ($rank < 0)  { 
				$section_results{$section->id}{$judge->id}{$entry->id}{"forfeit"}++;
			} else { 
				$section_results{$section->id}{$judge->id}{$entry->id}{"rank"} = int($rank);
				$section_results{$section->id}{$judge->id}{$entry->id}{"points"} = int($points);
			}

		} else { 

			$section_results{$section->id}{$judge->id}{$entry->id}{"winloss"} = 0;

			# The actual value is 65536.  I am not making this up. 
			$section_results{$section->id}{$judge->id}{$entry->id}{"winloss"} = 1
				if $points > 0;
		}

	}

	$ignore_me{"jse"}++;

	my @section_keys = keys %section_entries;

	@section_keys = 
		sort {$section_by_id{$a}->letter <=> $section_by_id{$b}->letter}
		@section_keys;

	@section_keys = 
		sort {$section_data{$a}{"roundname"} <=> $section_data{$b}{"roundname"}}
		@section_keys;

	@section_keys = 
		sort {$section_data{$a}{"event"} cmp $section_data{$b}{"event"}}
		@section_keys;

	my %round_spares;
	my %round_letter;

	SECTION:
	foreach my $section_id (@section_keys) { 

		my $section = $section_by_id{$section_id};
		next unless $section; 

		my $bye = $section_byes{$section_id};

		my $event = $section_data{$section_id}{"event"};
		my $round = $section_data{$section_id}{"round"};
		my $room  = $section_data{$section_id}{"room"};

		$round_letter{$round->id} = $section->letter 
			if $round_letter{$round->id} < $section->letter;

		my %used;
		my %first_at_order;

		$m->print("<p class='semibold bluetext'>Importing results for ".$event->abbr." ".$round->realname." section ".$section->letter."</p>");

		foreach my $order (sort {$a <=> $b} keys %{$section_entries{$section->id}}) { 

			next unless $section_entries{$section->id}{$order};

			foreach my $entry (@{$section_entries{$section->id}{$order}}) { 

				next unless $entry;
				next if $used{$entry}++;

				if ($first_at_order{$order}) { 
					push @{$round_spares{$round->id}{"entries"}}, $entry;
				} else { 
					$first_at_order{$order} = $entry;
				}
			}

			my $entry = $first_at_order{$order};
			next unless $entry;

			foreach my $judgekey (keys %{$section_judges{$section->id}{"real"}}) { 

				my $judge = $section_judges{$section->id}{"real"}{$judgekey};
				next unless $judge;

				my $chair = 0;
				$chair++ if $section_chair{$section->id}{$judge->id}
					&& $section_type{$section_id} eq "congress";

				my $fft = $section_results{$section->id}{$judge->id}{$entry->id}{"forfeit"};
				$fft = 0 unless $fft;

				my $bye = $section_byes{$section_id};
				$bye = 0 unless $bye;

				my $ballot = Tab::Ballot->create({
					entry         => $entry,
					judge         => $judge,
					panel         => $section,
					speakerorder  => $order,
					side          => $order,
					chair         => $chair,
					bye           => $bye,
					forfeit       => $fft,
					audit         => 1,
				});

				my $win = $section_results{$section->id}{$judge->id}{$entry->id}{"winloss"};
				my $rank = $section_results{$section->id}{$judge->id}{$entry->id}{"rank"};
				my $points = $section_results{$section->id}{$judge->id}{$entry->id}{"points"};

				if ($section_type{$section_id} eq "congress") { 

					$rank = 9 unless $rank;

					Tab::Score->create({
						ballot => $ballot,
						tag    => "rank",
						value  => $rank
					});

					if ($points) { 

						my $speech;

						my @points = split(',', $points);

						foreach my $point (@points) { 

							$speech++;

							Tab::Score->create({
								ballot => $ballot,
								tag    => "congress_speech",
								value  => $point,
								speech => $speech
							});

						}
					}

				} elsif ($section_type{$section_id} eq "speech") { 

					Tab::Score->create({
						ballot => $ballot,
						tag    => "rank",
						value  => $rank
					});

				} else { 

					$win = 0 unless $win;

					Tab::Score->create({
						ballot => $ballot,
						tag    => "ballot",
						value  => $win
					});

				}

			}

		}

	}

	foreach my $round_id (sort keys %round_spares) { 

		# These are people who bye through the various rounds

		my $letter = $round_letter{$round_id};

		foreach my $spare (@{$round_spares{$round_id}}) {

			$letter++;

			my $section = Tab::Panel->create({
				round  => $round_id,
				letter => $letter,
				bye    => 1,
				room   => 0,
			});

			my $ballot = Tab::Ballot->create({
				judge        => 0,
				entry        => $spare,
				audit        => 1,
				panel        => $section,
				chair        => 0,
				bye          => 0,
				forfeit      => 0,
				audit        => 1,
			});

		}
	}

	foreach my $label (sort {$a cmp $b} keys %segments) { 

		next if $ignore_me{$label};

		$m->print("<h5>".$label."</h5>");

		foreach my $linekey (sort keys %{$segments{$label}}) { 

			my $line = $segments{$label}{$linekey};
			$m->print("<pre>".$line."</pre>");
		}

	}

	sub parse_congress_bullshit { 

		my $score = shift;

		my $points = $score;

		my $steps;

		while ($points > 6) { 
			$steps++;
			$points = $points / 7; 
			$points = floor($points);
		}	

		my %results;

		while ($steps) {

			my $points = $score; 

			$points = $points / (7 ** $steps);
			$points = floor($points);

			my $remainder = $score - ((7 ** $steps) * $points);

			$results{$steps} = $points;
			$score = $remainder;
			$steps--;
		}

		$results{0} = $score if defined $score; 

		my $result_string;

		foreach my $key (sort {$a <=> $b} keys %results) { 

			$result_string .= "," if defined $result_string;
			$result_string .= $results{$key};
		}

		return $result_string;

	}

</%init>

	</div>

	<div class="menu">

		<div class="sidenote">

			<h5>Results</h5>

%			foreach my $result (@results) { 
				<div class="row padless">
					<% $result %>
				</div>
%			}

		</div>

		<div class="sidenote">

			<h5>Changes</h5>

%			foreach my $change (@changes) { 

				<div class="row padless">
					<% $change %>
				</div>
%			}

		</div>

	</div>
