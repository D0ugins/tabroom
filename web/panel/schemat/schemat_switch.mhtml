<%args>
	$person
	$tourn
	$target_id      => undef
	$setting_name   => undef
	$property_name  => undef
	$other_value    => 0
	$property_value => 0
</%args>
<%init>

	$m->clear_buffer();
	$r->content_type('application/json');

	unless ($target_id) {
		$m->print('{ "error": true, "message": "No round ID sent"}');
		$m->abort();
	}

	unless ($property_name || $setting_name) {
		$m->print('{ "error": true, "message": "No property to change sent"}');
		$m->abort();
	}

	my $round = Tab::Round->retrieve($target_id);

	unless ($round) {
		$m->print('{ "error": true, "message": "No round found for ID '.$target_id.'"}');
		$m->abort();
	}

	my $message;

	if ($setting_name) {

		$round->setting($setting_name, $other_value);
		$message = "Setting $setting_name changed to $other_value";

	} elsif ($property_name eq "published") {

		if ($other_value == 4) {

			$round->setting("publish_entry_list_no_byes", 1);
			$message = "List of clearing entries has been published without showing byes";
			$round->published(0);

		} elsif ($other_value == 3) {

			$round->setting("publish_entry_list", 1);
			$message = "List of clearing entries has been published";
			$round->published(0);

		} else {

			$property_name = 0 unless $property_name;
			$round->setting("publish_entry_list", 0);

			if ($other_value > 0) {
				$message = "Schematic has been published";
			} else {
				$message = "Schematic has been unpublished";
			}

			if ($other_value == 2) {
				$message .= " without judges";
			}
			$round->published($other_value);
		}

		if ($other_value == 1) {

			my $dbh = Tab::DBI->db_Main();

			my $sth = $dbh->prepare("
				select round.flighted, event.id,
					flip_online.value,
					flip_autopublish.value,
					flip_split_flights.value,
					flight_offset.value,
					flip_published.value
				from (round, event)

					left join event_setting flip_online
						on flip_online.event = event.id
						and flip_online.tag = 'flip_online'

					left join event_setting flip_autopublish
						on flip_autopublish.event = event.id
						and flip_autopublish.tag = 'flip_autopublish'

					left join event_setting flight_offset
						on flight_offset.event = event.id
						and flight_offset.tag = 'flight_offset'

					left join event_setting flip_split_flights
						on flip_split_flights.event = event.id
						and flip_split_flights.tag = 'flip_split_flights'

					left join round_setting flip_published
						on flip_published.round = round.id
						and flip_published.tag = 'flip_published'

				where round.id = ?
					and round.event = event.id
			");

			$sth->execute($round->id);

			my ($flighted, $event_id, $online, $autopublish, $split, $offset, $posted) = $sth->fetchrow_array();

			$sth->finish();
			$dbh->disconnect();

			unless ($posted) {

				if ($online && $autopublish) {

					my $now = DateTime->now();
					my $then = $now->clone();
					$then->add(minutes => $autopublish);

					if ($flighted > 1 && $offset && $split) {

						my $aq1 = Tab::Autoqueue->create({
							tag        => "flip_1",
							round      => $round->id,
							active_at  => $then,
							created_at => $now
						});

						$message .= " and flips scheduled to happen in ".$autopublish."/".$offset." minutes";
						$then->add(minutes => $offset);

						my $aq2 = Tab::Autoqueue->create({
							tag        => "flip_2",
							round      => $round->id,
							active_at  => $then,
							created_at => $now
						});

					} else {

						$message .= " and flips scheduled to happen in ".$autopublish." minutes";

						my $aq = Tab::Autoqueue->create({
							tag        => "flip",
							round      => $round->id,
							active_at  => $then,
							created_at => $now
						});
					}

				}
			}
		}

		$round->update();
		$m->comp('/funclib/cache_invalidate.mas', round => $round);

	} elsif ($property_name eq "start_time") {

		my $timeslot = $round->timeslot;
		my $start_date = $timeslot->start;
		my $tz = $tourn->tz;

		my $start_dt = eval {
			return Tab::dtme( $start_date->mdy('/'), $other_value, $tz);
		};

		my $datestring;

		if ($start_dt) {
			$round->start_time($start_dt);
			$datestring = $m->comp("/funclib/showtime.mas", dt => $start_dt, return => 1);
		} elsif ($start_date) {
			$round->start_time($start_date);
			$datestring = $m->comp("/funclib/showtime.mas", dt => $start_date, return => 1);
		}

		$round->update();

		$message = "Round start changed to ".$datestring;

	} elsif ($property_name eq "post_results") {

		if (not defined $other_value) {
			$other_value = 0;
		}

		if ($other_value > 2) {
			$message .= "RFDs and results published";
			$round->setting("public_feedback", 1);
			$round->post_results(1);
		} else {
			$message .= "Results published";
			$round->setting("public_feedback", 0);
			$round->post_results($other_value);
		}

		$round->update();

	} elsif ($property_name) {

		$round->$property_name($other_value);
		$round->update();
		$message = "Property $property_name changed to $other_value";

	}

    my %response = (
		error   => 0,
		message => $message
    );

    $m->print(JSON::encode_json(\%response));
	$m->abort();

</%init>
