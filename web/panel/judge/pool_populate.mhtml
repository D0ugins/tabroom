<%args>
	$tourn
	$tourn_settings
	$person
	$person_settings
	$perms
	$parent_id => undef
</%args>
<%init>

	my $now = DateTime->now();

	if ($now > $tourn->start) {
		$m->comp('/funclib/abort.mas',
			warn => "Tournament started.  I'm not letting you do that.  For your own good"
		);
	}

	my %scores = (
		strikes   => 1000000,
		states    => 100000,
		diversity => 1000,
		diamonds  => 100,
		remaining => 50,
		already   => 10
	);

	my $parent = Tab::JPool->retrieve($parent_id);

	unless ($parent) {
		$m->comp("/funclib/abort.mas",
			message => "No judge pool found with ID $parent_id"
		);
	}

	# Strap in and lube up, this is gonna be rough.

	my $dbh = Tab::DBI->db_Main();

	my $clear_children_sth = $dbh->prepare("
		delete jpj.*
		from jpool, jpool_judge jpj
		where jpool.parent = ?
		and jpj.jpool = jpool.id
	");

	$clear_children_sth->execute($parent_id);

	my $children_sth = $dbh->prepare("
		select jpool.id, jpool.name,
			pool_target.value, pool_priority.value,
			rounds.value

		from jpool
			left join jpool_setting pool_target
				on pool_target.tag = 'pool_target'
				and pool_target.jpool = jpool.id

			left join jpool_setting pool_priority
				on pool_priority.tag = 'pool_priority'
				and pool_priority.jpool = jpool.id

			left join jpool_setting rounds
				on rounds.tag = 'rounds'
				and rounds.jpool = jpool.id

		where jpool.parent = ?

			and not exists (
				select pool_ignore.id
				from jpool_setting pool_ignore
					where pool_ignore.tag = 'pool_ignore'
					and pool_ignore.jpool = jpool.id
			)

		group by jpool.id
	");

	my %targets;
	my $target_total;

	$children_sth->execute($parent_id);

	while (
		my (
			$jpool_id, $jpool_name,
			$pool_target, $pool_priority,
			$rounds
		) = $children_sth->fetchrow_array()
	) {
		$pool_priority = 99 unless $pool_priority;
		$targets{$jpool_id}{"name"}          = $jpool_name;
		$targets{$jpool_id}{"pool_target"}   = $pool_target;
		$targets{$jpool_id}{"pool_priority"} = $pool_priority;
		$targets{$jpool_id}{"rounds"}        = $rounds;
		$target_total += $pool_target;
	}

	$children_sth->finish();

	my $rounds_sth = $dbh->prepare("
		select
			jpool.id, min(timeslot.start), max(timeslot.end)
		from jpool, jpool_round jpr, round, timeslot
		where jpool.parent = ?
			and jpool.id = jpr.jpool
			and jpr.round = round.id
			and round.timeslot = timeslot.id
		group by jpool.id
	");

	$rounds_sth->execute($parent_id);

	my $obligation_total;

	while (
		my (
			$jpool_id, $start, $end
		) = $rounds_sth->fetchrow_array()
	) {

		next unless $targets{$jpool_id};

		$targets{$jpool_id}{"raw_start"} = $start;
		$targets{$jpool_id}{"raw_end"} = $end;

		$targets{$jpool_id}{"start"} = eval {
			return DateTime::Format::MySQL->parse_datetime($start);
		};
		$targets{$jpool_id}{"end"} = eval {
			return DateTime::Format::MySQL->parse_datetime($end);
		};

		$targets{$jpool_id}{"epoch_start"} = $targets{$jpool_id}{"start"}->epoch;
		$targets{$jpool_id}{"epoch_end"} = $targets{$jpool_id}{"end"}->epoch;
	}

	my $entries_sth = $dbh->prepare("
		select
			jpool.id, entry.id, entry.school, school.region,
			event.type
		from (entry, event, round, jpool_round jpr, jpool)
			left join school on entry.school = school.id

		where jpool.parent = ?
			and jpool.id     = jpr.jpool
			and jpr.round    = round.id
			and round.event  = event.id
			and event.id     = entry.event
			and entry.active = 1
		group by entry.id
	");

	$entries_sth->execute($parent_id);

	my $i_can_haz_congress;

	while (
		my (
			$jpool_id, $entry_id, $entry_school, $school_region,
			$event_type
		) = $entries_sth->fetchrow_array()
	) {
		next unless $targets{$jpool_id};

		if ($school_region) {
			$targets{$jpool_id}{"state"}{$school_region}++;
		}
		$targets{$jpool_id}{"school"}{$entry_school}++;
		$targets{$jpool_id}{"entries"}++;

		if ($event_type eq "congress") {
			$i_can_haz_congress++;
		}
	}

	# Calculate the percentage of the field that is from a given state, which
	# later will be used to make sure the pool reflects that percentage as
	# well.

	my %states;

	foreach my $jpool_id (keys %targets) {

		next unless $targets{$jpool_id};

		foreach my $region_id (keys %{$targets{$jpool_id}{"state"}}) {
			next unless $region_id > 0;
			$states{$region_id} = ($targets{$jpool_id}{"state"}{$region_id} / $targets{$jpool_id}{"entries"});
		}
	}

	$entries_sth->finish();

	my $limit;

	unless ($i_can_haz_congress) {

		$limit .= "
			and not exists (
				select pref_congress.id
				from judge_setting pref_congress
				where pref_congress.judge = judge.id
				and pref_congress.tag = 'prefers_congress'
			)
		";
	}

	my $judge_sth = $dbh->prepare("
		select
			judge.id, judge.school, school.region,
			judge.obligation, judge.hired,
			diverse.value, diamonds.value, nsda_points.value,
			strike.id, strike.type, strike.start, strike.end, strike.event

		from (judge, jpool_judge jpj, jpool)

			left join school on judge.school = school.id

			left join person on judge.person = person.id

			left join judge_setting diverse
				on diverse.tag = 'diverse'
				and diverse.judge = judge.id

			left join person_setting diamonds
				on diamonds.tag = 'diamonds'
				and diamonds.person = person.id

			left join person_setting nsda_points
				on nsda_points.tag = 'nsda_points'
				and nsda_points.person = person.id

			left join strike on strike.judge = judge.id

		where jpool.id = ?
			and jpool.id     = jpj.jpool
			and jpj.judge    = judge.id
			and judge.active = 1

			$limit

		group by judge.id, strike.id
	");

	my %judges;
	$judge_sth->execute($parent->id);

	while (
		my (
			$jid, $judge_school, $school_region,
			$judge_obligation, $judge_hired,
			$diverse, $diamonds, $nsda_points,
			$strike_id, $strike_tag, $strike_start, $strike_end, $strike_event
		) = $judge_sth->fetchrow_array()
	) {

		unless ($judges{$jid}{"school"}) {
			$judges{$jid}{"school"}      = $judge_school;
			$judges{$jid}{"state"}       = $school_region;
			$judges{$jid}{"obligation"}  = $judge_obligation + $judge_hired;
			$obligation_total            += $judge_obligation + $judge_hired;
			$judges{$jid}{"diverse"}     = $diverse;
			$judges{$jid}{"diamonds"}    = $diamonds;
			$judges{$jid}{"nsda_points"} = $nsda_points;
		}

		if ($diamonds) {
			$judges{$jid}{"priority"} += $diamonds * $scores{"diamonds"};
		}

		if ($diverse) {
			$judges{$jid}{"priority"} += $scores{"diversity"};
		}

		if ($judges{$jid}{"obligation"}) {
			$judges{$jid}{"priority"} += $scores{"remaining"} * $judges{$jid}{"obligation"};
		}

		if ($strike_tag) {
			$judges{$jid}{"strike_count"}++;

			if ($strike_tag eq "time") {
				$judges{$jid}{"strike"}{$strike_id}{"start"} = eval {
					return DateTime::Format::MySQL->parse_datetime($strike_start);
				};
				$judges{$jid}{"strike"}{$strike_id}{"end"} = eval {
					return DateTime::Format::MySQL->parse_datetime($strike_end);
				};

				$judges{$jid}{"strike"}{$strike_id}{"epoch_start"} = $judges{$jid}{"strike"}{$strike_id}{"start"}->epoch;
				$judges{$jid}{"strike"}{$strike_id}{"epoch_end"} = $judges{$jid}{"strike"}{$strike_id}{"end"}->epoch;
			}
		}
	}

	$judge_sth->finish();

	$judge_sth = $dbh->prepare("
		select
			judge.id,
			jpool.id,
			other.id, rounds.value, min(timeslot.start), max(timeslot.end)

		from (judge, jpool_judge jpj, jpool,
				jpool_judge ojpj, jpool other, jpool_round jpr,
				round, timeslot
			)

			left join jpool_setting rounds
				on rounds.tag = 'rounds'
				and rounds.jpool = other.id

		where
			(jpool.parent = ? or jpool.id = ?)
			and jpool.id = jpj.jpool
			and jpj.judge = judge.id

			and ojpj.jpool != jpool.id
			and ojpj.judge = judge.id
			and ojpj.jpool = other.id

			and other.id = jpr.jpool
			and jpr.round = round.id
			and round.timeslot = timeslot.id

			$limit

		group by judge.id, other.id
	");

	$judge_sth->execute($parent_id, $parent_id);
					    #shut up I'm tired.

	my %dt_cache;

	while (
		my (
			$jid,
			$jpool_id,
			$other_id, $rounds, $timeslot_start, $timeslot_end
		) = $judge_sth->fetchrow_array()
	) {

		unless ($judges{$jid}{"already"}{$jpool_id}) {

			if ($rounds) {
				$judges{$jid}{"obligation"} -= $rounds;
				$judges{$jid}{"priority"} -= $scores{"remaining"} * $rounds;
			}

			$judges{$jid}{"priority"} += $rounds * $scores{"already"};

			unless (defined $dt_cache{$timeslot_start}) {

				$dt_cache{$timeslot_start} = eval {
					my $dt = DateTime::Format::MySQL->parse_datetime($timeslot_start);
					return $dt->epoch;
				};
			}
			unless (defined $dt_cache{$timeslot_end}) {
				$dt_cache{$timeslot_end} = eval {
					my $dt = DateTime::Format::MySQL->parse_datetime($timeslot_end);
					return $dt->epoch;
				};
			}

			foreach my $tid (keys %targets) {
				if (
					$targets{$tid}{"epoch_start"} <= $dt_cache{$timeslot_end}
					&& $targets{$tid}{"epoch_end"} >= $dt_cache{$timeslot_start}
				) {
					$judges{$jid}{"exclude"}{$tid}++;
				}
			}
		}
	}

	$judge_sth->finish();

	# OK now that you've scored the entire friggin world, how about some
	# pooling

	my $pool_count = scalar(keys %targets);
	my $counter = 0;

	POOL:
	foreach my $tid (
		sort {
			$targets{$a}{"pool_priority"} <=> $targets{$b}{"pool_priority"}
			|| $targets{$b}{"rounds"} <=> $targets{$a}{"rounds"}
		} keys %targets
	) {

		my $left = $pool_count - $counter;
		my $target_count = $targets{$tid}{"pool_target"};

		my @jids;

		@jids = sort {
			$judges{$b}{"priority"} <=> $judges{$a}{"priority"}
		} keys %judges;

		if ($obligation_total  * .8 <= $target_total) {

			foreach my $jid (@jids) {
				$judges{$jid}{"max"} = 0;
				next if $judges{$jid}{"obligation"} < 1;

				if ($judges{$jid}{"obligation"} >= $left) {
					$judges{$jid}{"max"} = 10;
				}
			}

			@jids = sort {
				$judges{$b}{"max"} <=> $judges{$a}{"max"}
				|| $judges{$b}{"priority"} <=> $judges{$a}{"priority"}
			} @jids;

		} elsif ($left == 1) {

			foreach my $jid (@jids) {
				$judges{$jid}{"max"} = 0;
				next if $judges{$jid}{"in_pools"};
				$judges{$jid}{"max"} = 10;
			}

			@jids = sort {
				$judges{$b}{"max"} <=> $judges{$a}{"max"}
			} @jids;
		}

		JUDGE:
		foreach my $jid (@jids) {

			next unless $judges{$jid}{"obligation"} >= $targets{$tid}{"rounds"};

			my $track;

			if ($left > 1) {
				if ($judges{$jid}{"max"}) {
					$track++;
				}
			}

			next if $judges{$jid}{"exclude"}{$tid};

			my $jstate = $judges{$jid}{'state'};

			unless ($judges{$jid}{"max"}) {
				if ($jstate) {

					my $state_quota = POSIX::ceil($target_count * $states{$jstate});

					if ($targets{$tid}{"pool_priority"} == 99) {
						$state_quota = $state_quota * 2;
					}

					if ($targets{$tid}{"state_count"}{$jstate} > $state_quota) {
						next JUDGE;
					}
				}
			}

			# Congratulations. You have been drafted.
			$targets{$tid}{"judges"}{$jid}++;
			$targets{$tid}{"judge_count"}++;
			if ($jstate) {
				$targets{$tid}{"state_count"}{$jstate}++;
			}

			if ($judges{$jid}{"diverse"}) {
				$targets{$tid}{"diverse_count"}++;
			}

			if ($judges{$jid}{"diamonds"}) {
				$targets{$tid}{"diamond_count"}++;
			}

			$judges{$jid}{"obligation"} -= $targets{$tid}{"rounds"};
			$judges{$jid}{"priority"} -= $scores{"remaining"} * $targets{$tid}{"rounds"};
			$judges{$jid}{"in_pools"}++;

			if ($targets{$tid}{"judge_count"} >= $target_count) {
				$counter++;
				next POOL;
			}

			$judges{$jid}{"pools"}{$tid}++;
		}

		$counter++;
	}

</%init>

	<div class="main">

		<h5>Results against <% $parent->name %></h5>

		<& "/funclib/tablesorter.mas",
			table     => "pool_results",
			nobuttons => 1
		&>

		<table id="pool_results">
			<thead>

				<tr class="smallish yellowrow">
					<th>
						ID
					</th>

					<th>
						Pool
					</th>

					<th>
						Priority
					</th>

					<th>
						Target
					</th>

					<th>
						Judge Count
					</th>

					<th>
						Diverse Count
					</th>

					<th>
						Diamonds Count
					</th>

				</tr>

			</thead>

			<tbody>
<%perl>

			foreach my $tid (
				sort {
					$targets{$a}{"pool_priority"} <=> $targets{$b}{"pool_priority"}
					|| $targets{$a}{"name"} cmp $targets{$b}{"name"}
					|| $a <=> $b
				} keys %targets
			) {

				next unless $targets{$tid}{"name"};
</%perl>
				<tr>

					<td>
						<% $tid %>
					</td>

					<td>
						<% $targets{$tid}{"name"} %>
					</td>

					<td>
						<% $targets{$tid}{"pool_priority"} %>
					</td>

					<td>
						<% $targets{$tid}{"pool_target"} %>
					</td>

					<td>
						<% $targets{$tid}{"judge_count"} %>
					</td>

					<td>
						<% $targets{$tid}{"diverse_count"} %>
					</td>

					<td>
						<% $targets{$tid}{"diamond_count"} %>
					</td>

				</tr>
%			}

			</tbody>
		</table>

		<h4>Judge rounds</h4>

		<table>
<%perl>
			my $add_sth = $dbh->prepare("
				insert into jpool_judge (jpool, judge) values (?, ?)
			");

			my $zero;

			foreach my $jid (
				sort {
					$judges{$b}{"obligation"} <=> $judges{$a}{"obligation"}
				} keys %judges
			) {

				unless ($judges{$jid}{"in_pools"}) {
					$zero++;
				}

				foreach my $pid (sort keys %{$judges{$jid}{"pools"}}) {
					$add_sth->execute($pid, $jid);
				}
</%perl>
				<tr class="row">
					<td>
						<% $jid %>
					</td>

					<td>
						<% $judges{$jid}{"state"} %>
					</td>
					<td>
						div
						<% $judges{$jid}{"diverse"} %>
					</td>
					<td>
						dia
						<% $judges{$jid}{"diamonds"} %>
					</td>

					<td>
						<% $judges{$jid}{"in_pools"} %> Pools
					</td>

					<td>
						<% $judges{$jid}{"obligation"} %> Left
					</td>

					<td>
%						foreach my $pid (sort keys %{$judges{$jid}{"pools"}}) {
							<span class="third nospace smallish">
								<% $targets{$pid}{"name"} %>
							</span>
%						}
					</td>
				</tr>
%			}
		</table>
	</div>

	<div class="menu">
		<div class="sidenote">
			Zeros: <% $zero %>
		</div>
	</div>
