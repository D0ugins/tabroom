<%args>
	$round
	$num_panels
	$nsda        => undef
	$entries_ref => undef
	$limit_to    => undef
	$seed_basis  => undef
</%args>
<%perl>

	return unless $round > 0;

	my %round_settings = $round->all_settings;
	return if $round_settings{"flight_a_round"};

	use POSIX;
	my $event = $round->event;
	my $tourn = $event->tourn;

	my %tourn_settings = $tourn->all_settings;
	my %event_settings = $event->all_settings;

	my $percent_limit = $event_settings{"school_percent_limit"};

	my $dbh = Tab::DBI->db_Main();

	my $previous_round = Tab::Round->search(
		event => $event->id,
		name  => ($round->name - 1)
	)->first;

	my %entries_by_section = ();

	my %hits = ();
	my %entries = ();
	my %size_of_school = ();

	my $sth = $dbh->prepare("
		select ballot.id, ballot.entry, ballot.speakerorder,
			panel.id, round.id, round.name

		from ballot, panel, round
			where ballot.panel = panel.id
			and panel.round = round.id
			and round.name < ?
			and round.event = ?
	");

	$sth->execute($round->name, $event->id);

	my $previous_round_id;
	$previous_round_id = $previous_round->id if $previous_round;

	while (

		my ($ballot_id, $entry_id, $speakerorder, $panel_id, $round_id, $round_name) = $sth->fetchrow_array()

	) {

		push (@{$entries_by_section{$panel_id}}, $entry_id);
		push (@{$entries{$entry_id}{"sections"}}, $panel_id);

		$entries{$entry_id}{"order_count"}{$speakerorder}++;
		$entries{$entry_id}{"order_total"} += $speakerorder;

		if ($round_id == $previous_round_id) {
			$entries{$entry_id}{"last_order"} = $speakerorder;
		}
	}

	my $speaker_priority_first = $event_settings{"speaker_priority_first"};

	my @schools;

	$sth = $dbh->prepare("
		select entry.id, entry.code, entry.name, school.id,
			school.region, school.state
		from entry, school
		where entry.event = ?
		and entry.active = 1
		and entry.school = school.id
	");

	$sth->execute($event->id);
	my @all_entries;

	while (
		my ($entry_id, $entry_code, $entry_name, $school_id, $region_id, $state) = $sth->fetchrow_array()
	) {

		push @all_entries, $entry_id;

		$entries{$entry_id}{"code"} = $entry_code;
		$entries{$entry_id}{"name"} = $entry_name;

		if ($tourn_settings{"ncfl"} || $event_settings{"region_conflict"}) {

			$entries{$entry_id}{'school'} = $region_id;

		} else {

			$entries{$entry_id}{'school'} = $school_id;
			$size_of_school{$school_id}++;

			if ($event_settings{"region_avoid"}) {
				$entries{$entry_id}{"region"} = $region_id;
			}

			if ($tourn_settings{"nsda_nats"}) {
				$entries{$entry_id}{"region"} = $region_id;
				$entries{$entry_id}{"state"} = $state;
			}

		}
	}

	my $section_size = ceil(scalar @all_entries / $num_panels);

	$sth->finish();

	foreach my $entry_id (@all_entries) {

		foreach my $section_id (@{$entries{$entry_id}{"sections"}}) {

			foreach my $other_id (@{$entries_by_section{$section_id}}) {

				next if $other_id <= $entry_id;
				# Avoid myself and double counting

				my $other_school = $entries{$other_id}{"school"};
				my $other_region = $entries{$other_id}{"region"};
				my $other_state  = $entries{$other_id}{"state"};

				next unless $other_school;

				$hits{$entry_id}{"entry"}{$other_id}++;
				$hits{$entry_id}{"school"}{$other_school}++;
				$hits{$entry_id}{"region"}{$other_region}++ if $other_region;
				$hits{$entry_id}{"state"}{$other_state}++ if $other_state;

				if ($other_school == $entries{$entry_id}{"school"}) {
					$hits{$entry_id}{"ownschool"}++;
				}

				if ($other_region == $entries{$entry_id}{"region"}) {
					$hits{$entry_id}{"ownregion"}++;
				}

				if ($other_state eq $entries{$entry_id}{"state"}) {
					$hits{$entry_id}{"ownstate"}++;
				}
			}
		}
	}

	if ($tourn_settings{"nsda_district"}) {

		$hits{"nsda"}++;

		if ($event_settings{"ask_for_titles"}) {

			my @titles = $m->comp(
				"/funclib/event_entry_settings.mas",
				event => $event,
				tag   => "title"
			);

			foreach my $title (@titles) {
				my $value = $title->value;
				$value =~ s/[\W_]//g;
				$entries{$title->entry->id}{"title"} = $value;
			}
		}
	}

	if ($tourn_settings{"nsda_nats"}) {
		$hits{"regions"}++;
		$hits{"states"}++;
		$hits{"nats"}++;
	} elsif ($event_settings{"region_avoid"}) {
		$hits{"regions"}++;
	}

	if ($limit_to > 0 && $limit_to != (scalar @all_entries)) {

		# Removes anyone who hasn't made it to this round; mostly for the
		# NSDA double-drop system.

		my @results = $m->comp(
			"/tabbing/results/order_entries.mas",
				round => $previous_round,
		) if $previous_round;

		$entries_ref = pop @results if @results;

		my $counter;

		my %cleared = ();

		if (${$entries_ref}{"by_place"}) {

			foreach my $key (sort {$a <=> $b} keys %{${$entries_ref}{"by_place"}}) {

				foreach my $entry_id (@{${${$entries_ref}{"by_place"}}{$key}}) {

					unless ($counter++ >= $limit_to) {
						$cleared{$entry_id}++;
					}
				}
			}
		}

		my @entries_temp;

		foreach my $entry_id (@all_entries) {
			push @entries_temp, $entry_id if $cleared{$entry_id};
		}

		@all_entries = @entries_temp;

	}


	if ($seed_basis) {

		my %pairing_seeds = ();

		if ($seed_basis eq "prelims") {

			%pairing_seeds =
				map {$_->entry->id => $_->value}

				$m->comp("/funclib/event_entry_settings.mas",
					event => $event->id,
					tag   => "pairing_seed"
				);

		} elsif ($previous_round) {

			my $seeding_tiebreak_set = Tab::TiebreakSet->retrieve($seed_basis);

			my $entries_ref;

			if ($seeding_tiebreak_set) {

				my @seed_results = $m->comp(
					"/tabbing/results/order_entries.mas",
					round        => $previous_round,
					tiebreak_set => $seeding_tiebreak_set
				);

				$entries_ref = pop @seed_results if @seed_results;
			}

			foreach my $entry_id (keys %entries) {
				$entries{$entry_id}{"seed"} = ${$entries_ref}{"tiebreak"}{1}{$entry_id};
			}

		}

		my $total_seeds;
		my $seed_count;

		foreach my $entry_id (keys %entries) {
			next unless $entries{$entry_id}{"seed"};
			$total_seeds += $entries{$entry_id}{"seed"};
			$seed_count++;
		}

		$hits{"seed_average"} = $total_seeds / $seed_count if $seed_count;
	}

	my $second_round_id = $round_settings{"flight_b_round"};

	my $second_round =
		Tab::Round->retrieve($second_round_id)
		if $second_round_id;

	undef $second_round
		unless $second_round
		&& $second_round->event->id == $round->event->id;

    my $double_entry_sth = $dbh->prepare("

        select distinct thisentry.id,
			thatballot.entry,
			thatballot.speakerorder,
			thatsetting.value

        from (entry thisentry, entry_student thises, round thisround,
             round thatround, panel thatpanel, ballot thatballot, entry_student thates)

		left join event_setting thatsetting
			on thatsetting.event = thatround.event
			and thatsetting.tag = 'speaker_priority_first'

        where thisround.id = ?
        and thisround.event = thisentry.event
        and thisentry.id = thises.entry
        and thises.student = thates.student
        and thises.entry != thates.entry
        and thates.entry = thatballot.entry
        and thatballot.panel = thatpanel.id
        and thatpanel.round = thatround.id
        and thatround.timeslot = thisround.timeslot
	");

	$double_entry_sth->execute($round->id);

	while ( my ($this_entry, $that_entry, $that_order, $speaklate)
		= $double_entry_sth->fetchrow_array()
	) {

		$entries{$this_entry}{$round}{"order"} = $that_order;
		$entries{$this_entry}{$round}{"late"} = $speaklate;
	}

	if ($second_round) {

		$double_entry_sth->execute($second_round);

		while ( my ($this_entry, $that_entry, $that_order, $speaklate)
			= $double_entry_sth->fetchrow_array()
		) {
			$entries{$this_entry}{$round}{"order"} = $that_order;
			$entries{$this_entry}{$round}{"late"} = $speaklate;
		}

	}

	my %sseen = ();
	@schools = grep { ! $sseen{$_} ++ } @schools;
	@schools = sort {$size_of_school{$b} <=> $size_of_school{$a}} @schools;
	my %school_rank = ();

	my $ranker = 1;
	foreach (@schools) {
		$school_rank{$_} = $ranker++;
	}

	#Set up the initial sections

	my $max_size = ceil(scalar @all_entries / $num_panels);
	my $min_size = floor(scalar @all_entries/ $num_panels);
	my $remainder = (scalar @all_entries - ($num_panels * $min_size));

	my %sections = ();

	use List::Util 'shuffle';
	my @keys =  shuffle( 1 .. $num_panels);

	my %forbidden_sections = ();

	my $limit_count =  (scalar @keys) * $percent_limit * .01;


	if ($limit_count > 0) {

		foreach my $school (@schools) {

			next if $size_of_school{$school} < $limit_count;

			my $counter;
			my $limited;

			foreach my $key (shuffle @keys) {
				next if $counter++ <= $limit_count;
				$forbidden_sections{$school}{$key}++;
				$limited++;
			}

		}

		@all_entries =
			sort { $size_of_school{$entries{$b}{"school"}}
				<=> $size_of_school{$entries{$a}{"school"}} }
			@all_entries;

	}


	foreach my $entry_id (@all_entries) {

		my $score = "3141592653";   #Shut up.
		my $picked_key;

		KEY:
		foreach my $key (@keys) {

			next if $score == 0;
			next if $forbidden_sections{$entries{$entry_id}{"school"}}{$key};

			my @section = @{$sections{$key}} if $sections{$key};

			next KEY if (scalar @section) >= $max_size;

			if ((scalar @section) == $min_size) {
				next KEY unless $remainder > 0;
			}

			if (@section) {

				push (@section, $entry_id);

				my $new_score = score_section(
					\@section,
					\%hits,
					\%entries
				);

				if ($new_score < $score) {
					$picked_key = $key;
					$score = $new_score;
					last KEY if $score == 0;
				}

			} else {

				$picked_key = $key;
				$score = 0;
				last KEY;
			}

		}

		$remainder-- if $sections{$picked_key}
			&& scalar @{$sections{$picked_key}} == $min_size;

		push (@{$sections{$picked_key}}, $entry_id);

		my $k = shift @keys;
		push (@keys, $k);

	}

	my @section_keys = sort keys %sections;

	foreach my $section_key (@section_keys) {

		@{$sections{$section_key}} =
			sort {$school_rank{$entries{$a}{"school"}}
				<=> $school_rank{$entries{$b}{"school"}} }
				@{$sections{$section_key}};
	}

	my $no_improvement = 1;

	unless ($num_panels == 1) {

		foreach my $counter (1 .. 7) {

			my $total;

			next if $no_improvement == 0;
			$no_improvement = 0;

			foreach my $section_key (@section_keys) {

				my @section = @{$sections{$section_key}};
				my $entry_section1_score = score_section(
					\@section,
					\%hits,
					\%entries
				);

				next if $entry_section1_score < 1;

				ENTRY:
				foreach my $entry_id (@section) {

					next if $entry_section1_score < 1;

					# Remove the candidate for a test array of original section
					my @section1 = @section;
					my $index = 0;

					$index++ until $section1[$index] == $entry_id;
					splice(@section1, $index, 1);

					my $swap_section;
					my $swap_entry;
					my $current_diff;

					my @new_entry_section;
					my @new_swap_section;

					my $count;

					OTHERPANEL:
					foreach my $other_key (@section_keys) {

						next if $forbidden_sections{$entries{$entry_id}{"school"}}{$other_key};

						# Can't switch to the same section
						next if $other_key == $section_key;

						# Find the other section for scoring
						my @section2 = @{$sections{$other_key}};

						my $other_section2_score = score_section(
							\@section2,
							\%hits,
							\%entries
						);

						# Put me into this section for testing
						push (@section2, $entry_id);

						OTHERENTRY:
						foreach my $other_entry_id (@{$sections{$other_key}}) {

							next if $forbidden_sections{$entries{$other_entry_id}{"school"}}{$section_key};

							# Add swap candidate to original section
							push (@section1, $other_entry_id);

							$count++;

							my $other_section1_score = score_section(
								\@section1,
								\%hits,
								\%entries
							);

							# Remove swap candidate from the section
							my $index = 0;

							$index++ until $section2[$index] == $other_entry_id;
							splice(@section2, $index, 1);

							my $entry_section2_score = score_section(
								\@section2,
								\%hits,
								\%entries
							);

							my $squo_score = $entry_section1_score + $other_section2_score;
							my $swap_score = $entry_section2_score + $other_section1_score;
							my $diff = $squo_score - $swap_score;

							my $replace = pop(@section1);  #remove me from this section
							push (@section2, $replace);    #put me back from whence I came

							if ( $diff > 0 && $diff > $current_diff) {
								$current_diff = $diff;
								$swap_entry = $other_entry_id;
								$swap_section = $other_key;
							}

						}

					}

					if ($swap_entry) {

						my @section2 = @{$sections{$swap_section}};

						push (@section1, $swap_entry);

						my $swapdex = 0;
						$swapdex++ until $section2[$swapdex] == $swap_entry;
						splice(@section2, $swapdex, 1);

						push (@section2, $entry_id);

						$no_improvement++;  # Fail
						@{$sections{$section_key}} = @section1;
						@{$sections{$swap_section}} = @section2;

						@section = @section1;

						$entry_section1_score = score_section(
							\@section1,
							\%hits,
							\%entries
						);

						my $other_score = score_section(
							\@section2,
							\%hits,
							\%entries
						);

					}
				}
			}

			last if $no_improvement < 1;

		}

	}

	my @judges = $m->comp(
		"/funclib/round_judges.mas",
		round => $round
	);

	my @judge_keys;

	my %judge_section = ();

	foreach my $judge (@judges) {
		push (@{$judge_section{$judge->panelid}}, $judge->id);
		push (@judge_keys, $judge->panelid);
	}

	my %jseen = ();
	@judge_keys = grep { ! $jseen{$_} ++ } @judge_keys;

	my @rooms = $m->comp(
		"/funclib/round_rooms.mas",
		round => $round
	);

	my @clean_rooms = $m->comp(
		"/funclib/clean_rooms.mas",
		round => $round
	);

	#Clear out the old

	Tab::Score->set_sql( delete_round => "
		delete score from score, ballot, panel
		where panel.round = ?
		and panel.id = ballot.panel
		and ballot.id = score.ballot
	");

	Tab::Ballot->set_sql( delete_round => "
		delete ballot from ballot, panel
		where panel.round = ?
		and panel.id = ballot.panel
	");

	Tab::Panel->set_sql( delete_round => "
		delete from panel where round = ?
	");

	Tab::Score->sql_delete_round->execute($round->id);
	Tab::Ballot->sql_delete_round->execute($round->id);
	Tab::Panel->sql_delete_round->execute($round->id);

	my $letter = 1;
	$letter = "A" if $event_settings{"panel_labels"} eq "letters";

	# If I have a second flighted situation, track half my sections into the
	# second flight timeblock.

	my %section_second;

	if ($second_round) {

		my $switch;

		foreach my $section_key (@section_keys) {
			next if $switch++ % 2;
			$section_second{$section_key}++;
		}

	}

	#Set speaker order

	foreach my $section_key (@section_keys) {

		my @entries = @{$sections{$section_key}};

		@entries = shuffle(@entries);

		@entries = sort { $entries{$b}{"order_total"} <=> $entries{$a}{"order_total"} } @entries;

		my $size_of_section = scalar @entries;

		my $moved = 1;

		my $this_round = $round;
		$this_round = $second_round
			if $section_second{$section_key}
			&& $second_round;

		foreach (1 .. 10) {

			next unless $moved;

			undef $moved;
			my $position;

			foreach my $entry_id (@entries) {

				$position++;

				# If I've already spoken in this position move me please

				if ($entries{$entry_id}{"order_count"}{$position}) {

					# Remove from place in line

					my $place;

					# Find a new home

					$place = $position;

					while ($place == $position) {
						$place = int(rand($size_of_section));
					}

					$place--;
					$place = 1 if $place < 0;
					splice(@entries,($place - 1),0,$entry_id);
					$moved++;
				}
			}

			foreach my $entry_id (@entries) {

				$position++;

				# If I spoke in this position in the last round, definitely move me

				if ($entries{$entry_id}{"last_order"} == $position) {

					#Remove from place in line

					my $place;

					#Find a new home

					$place = $position;

					while ($place == $position) {
						$place = int(rand($size_of_section));
					}

					$place--;
					$place = 1 if $place < 0;
					splice(@entries,($place - 1),0,$entry_id);
					$moved++;
				}
			}

			my %seen;
			@entries = grep { ! $seen{$_} ++ } @entries;

			foreach my $entry_id (@entries) {

				if (
					$entries{$entry_id}{$this_round}{"order"}
					|| $entries{$entry_id}{$this_round}{"late"}
				) {

					my $speakdex = 0;
					$speakdex++ until $entries[$speakdex] == $entry_id;

					splice(@entries, $speakdex, 1);

					my $place;

					if ($speaker_priority_first) {
						$place = 1;
					} elsif ($entries{$entry_id}{$this_round}{"late"}) {
						$place = 7;
					} elsif ($entries{$entry_id}{$this_round}{"order"} > 3) {
						$place = 1;
					} else {
						$place = 7;
					}

					$place = 1 if $place < 0;

					splice(@entries,($place - 1),0,$entry_id);

				}

			}

		}

		@{$sections{$section_key}} = @entries;

	}

	foreach my $section_key (sort keys %sections) {

		my $room = shift @rooms if @rooms;
		my $room_id = 0;
		$room_id = $room->id if $room;

		my $jsection = shift @judge_keys if @judge_keys;
		my @judge_ids = @{$judge_section{$jsection}} if $jsection;
		@judge_ids = ("0") unless @judge_ids;

		my @section = @{$sections{$section_key}};

		my $score = score_section(
			\@section,
			\%hits,
			\%entries,
			"yup"
		);

		my $this_round = $round;
		$this_round = $second_round if $section_second{$section_key};

		my $section = Tab::Panel->create({
			round  => $this_round->id,
			room   => $room_id,
			letter => $letter,
			score  => $score,
			flight => 1
		});


		foreach my $judge_id (@judge_ids) {

			my $position;

			foreach my $entry_id (@section) {

				$position++;

				next unless $entry_id;

				my $ballot = Tab::Ballot->create({
					panel        => $section->id,
					judge        => $judge_id,
					entry        => $entry_id,
					speakerorder => $position
				});

			}

		}

		if ($letter eq "Z") {
			$letter = "AA";
		} else {
			$letter++;
		}

	}

	my $now = DateTime->now;
	$round->created($now);
	$round->update;

	return;

	sub score_section {

		my ($panref, $hitsref, $entref, $verbose) = @_;

		my @pan_entries = @$panref;

		my $score = 0;
		my $tick;

		my %scores ;

		if (${$hitsref}{"nsda"}) {

			$scores{school}        = 1000000000;
			$scores{title}         = 10000;
			$scores{repeat}        = 100;
			$scores{repeat_school} = 10;

		} elsif (${$hitsref}{"nats"}) {

			$scores{school}        = 1000000000;
			$scores{region}        = 1000000000;
			$scores{state}         = 1000000;
			$scores{repeat}        = 1000;
			$scores{repeat_region} = 50;
			$scores{repeat_state}  = 10;

		} else {
			$scores{school}        = 100000000;
			$scores{region}        = 1000 if ${$hitsref}{"regions"};
			$scores{average}       = 100 if ${$hitsref}{"seed_average"};
			$scores{repeat}        = 100;
			$scores{repeat_school} = 10;
			$scores{repeat_region} = 1 if ${$hitsref}{"regions"};
		}

		my $panel_total;

		foreach my $entry_id (@pan_entries) {

			$panel_total += ${$entref}{$entry_id}{"seed"};

			foreach my $other (@pan_entries) {

				next unless $other > $entry_id;

				my $local_score;

				if (${$entref}{$other}{"school"} == ${$entref}{$entry_id}{"school"}) {
					$local_score += $scores{school};
					$local_score += $scores{school} if ${$hitsref}{$entry_id}{"ownschool"};
				}

				if ($scores{region} && ${$entref}{$entry_id}{"region"}) {
					if (${$entref}{$other}{"region"} == ${$entref}{$entry_id}{"region"}) {
						$local_score += $scores{region};
						$local_score += $scores{region} if ${$hitsref}{$entry_id}{"ownregion"};
					}
				}

				if ($scores{state} && ${$entref}{$entry_id}{"state"}) {
					if (${$entref}{$other}{"state"} eq ${$entref}{$entry_id}{"state"}) {
						$local_score += $scores{state};
						$local_score += $scores{state} if ${$hitsref}{$entry_id}{"ownstate"};
					}
				}

				if ($scores{title} && ${$entref}{$entry_id}{"title"}) {
					if (${$entref}{$other}{"title"} eq ${$entref}{$entry_id}{"title"}) {
						$local_score += $scores{title};
					}
				}

				$local_score += $scores{repeat} if ${$hitsref}{$entry_id}{"entry"}{$other};

				if ($scores{repeat_school}) {
					my $other_school = ${$entref}{$other}{"school"};
					if (${$hitsref}{$entry_id}{"school"}{$other_school}) {
						$local_score += $scores{repeat_school}
					}
				}

				if ($scores{repeat_region}) {
					my $other_region = ${$entref}{$other}{"region"};
					if (${$hitsref}{$entry_id}{"region"}{$other_region}) {
						$local_score += $scores{repeat_region}
					}
				}

				if ($scores{repeat_state}) {
					my $other_state = ${$entref}{$other}{"state"};
					if (${$hitsref}{$entry_id}{"state"}{$other_state}) {
						$local_score += $scores{repeat_state}
					}
				}

				$score += $local_score;

			}
		}

		my $average = ($panel_total / (scalar @pan_entries)) if $panel_total;
		$score += abs($average - ${$hitsref}{"seed_average"})  * $scores{average};
		return $score;
	}

</%perl>
