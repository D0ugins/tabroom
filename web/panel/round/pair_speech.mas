<%args>
	$round
	$num_panels
	$nsda        => undef
	$entries_ref => undef
	$limit_to    => undef
	$seed_basis  => undef
</%args>
<%perl>
	
	return unless $round > 0;

	my %round_settings = $round->all_settings;
	return if $round_settings{"flight_a_round"};

	use POSIX;
	my $event = $round->event;
	my $tourn = $event->tourn;

	my %tourn_settings = $tourn->all_settings;
	my %event_settings = $event->all_settings;

	my $percent_limit = $event_settings{"school_percent_limit"};

	my @all_entries;

	@all_entries = ${$entries_ref} if $entries_ref;
	@all_entries = $event->entries( active => 1 ) unless @all_entries;

	my $section_size = ceil(scalar @all_entries / $num_panels);

	#Prime the section scorer 
	my @other_ballots = $m->comp(
		"/funclib/other_ballots.mas", 
			round => $round
	);

	my %entries_by_section = ();

	my %hits = ();
	my %entries = ();
	my %size_of_school = ();

	foreach my $ob (@other_ballots) { 
		next unless $ob && $ob->id;
		next unless $ob->entry && $ob->panel;

		my $entry   = $ob->entry->id;
		my $section = $ob->panel->id;

		push (@{$entries_by_section{$section}}, $entry);
		push (@{$entries{$entry}{"sections"}}, $section);

		$entries{$entry}{"order_count"}{$ob->speakerorder}++;
		$entries{$entry}{"order_total"} += $ob->speakerorder;
	}

	my $speaker_priority_first = $event_settings{"speaker_priority_first"};

	my @schools;

	if ($tourn_settings{"ncfl"}) { 

		my %school_region = ();

		foreach my $entry (@all_entries) { 

			my $entry_id = $entry->id;

			my $region = $school_region{$entry->school->id};

			unless ($region) { 
				$region = $entry->school->region;
				$school_region{$entry->school->id} = $region;
				push (@schools, $region);
				$size_of_school{$region}++;
			}

			$entries{$entry_id}{'school'} = $region->id;

		}

	} elsif ($event_settings{"region_avoid"}) { 

		my %school_region = ();

		foreach my $entry (@all_entries) { 

			my $entry_id = $entry->id;

			my $school = $entry->school;

			my $region = $school_region{$school->id};

			unless ($region) { 
				$region = $school->region;
				$school_region{$school->id} = $region;
			}

			push (@schools, $school);
			$size_of_school{$school->id}++;

			$entries{$entry_id}{'school'} = $school->id;
			$entries{$entry_id}{"region"} = $region->id;

		}

	} else { 

		foreach my $entry (@all_entries) { 

			my $entry_id = $entry->id;
			my $school = $entry->school;

			$entries{$entry_id}{'school'} = $school->id;

			push (@schools, $school);
			$size_of_school{$school->id}++;
		}
	}

	foreach my $entry (@all_entries) { 

		my $entry_id = $entry->id;

		foreach my $section_id (@{$entries{$entry_id}{"sections"}}) {

			foreach my $other_id (@{$entries_by_section{$section_id}}) { 
				
				next if $other_id <= $entry_id; 
				# Avoid myself and double counting

				my $other_school = $entries{$other_id}{"school"};
				my $other_region = $entries{$other_id}{"region"};

				$hits{$entry_id}{"entry"}{$other_id}++;
				$hits{$entry_id}{"school"}{$other_school}++;
				$hits{$entry_id}{"region"}{$other_region}++;

				if ($other_school == $entries{$entry_id}{"school"}) { 
					$hits{$entry_id}{"ownschool"}++;
				}

				if ($other_region == $entries{$entry_id}{"region"}) { 
					$hits{$entry_id}{"ownregion"}++;
				}

			}
		}
	}

	if ($tourn_settings{"nsda_district"}) { 

		$hits{"nsda"}++;

		if ($event_settings{"ask_for_titles"}) { 
		
			my @titles = $m->comp(
				"/funclib/event_entry_settings.mas",
				event => $event,
				tag   => "title"
			);

			foreach my $title (@titles) { 
				my $value = $title->value;
				$value =~ s/[\W_]//g;
				$entries{$title->entry->id}{"title"} = $value;
			}

		}

	}

	if ($limit_to) { 

		# Removes anyone who hasn't made it to this round; mostly for the
		# NSDA double-drop system.

		my $previous_round = Tab::Round->search( 
			event => $event->id,
			name  => ($round->name - 1)
		)->first;

		my @results = $m->comp(
			"/tabbing/results/order_entries.mas",
				round => $previous_round,
		) if $previous_round; 
		
		$entries_ref = pop @results if @results;

		my $counter;

		if (${$entries_ref}{"by_place"}) { 
			foreach my $key (sort {$a <=> $b} keys %{${$entries_ref}{"by_place"}}) {
				foreach my $entry_id (@{${${$entries_ref}{"by_place"}}{$key}}) {
					next unless $counter++ > $limit;
					delete($entries{$entry_id});
				}
			}
		}

	}

	if ($seed_basis) { 

		my %pairing_seeds = ();

		if ($seed_basis eq "prelims") { 

			%pairing_seeds = 

				map {$_->entry->id => $_->value} 
			
				$m->comp("/funclib/event_entry_settings.mas",
					event => $event->id,
					tag   => "pairing_seed"
				);

		} else { 

			$seeding_tiebreak_set = Tab::TiebreakSet->retrieve($seed_basis);

			my $entries_ref;

			if ($seeding_tiebreak_set) { 

				my @seed_results = $m->comp(
					"/tabbing/results/order_entries.mas",
					round        => $previous_round,
					tiebreak_set => $seeding_tiebreak_set
				);

				$entries_ref = pop @seed_results if @seed_results;
			}

			foreach my $entry_id (keys %entries) { 
				$entries{$entry_id}{"seed"} = ${$entries_ref}{"tiebreak"}{1}{$entry_id};
			}

		}

		my $total_seeds;
		my $seed_count;

		foreach my $entry (keys %entries) {
			next unless $entries{$entry_id}{"seed"};
			$total_seeds += $entries{$entry_id}{"seed"};
			$seed_count++;
		}

		$hits{"seed_average"} = $total_seeds / $seed_count if $seed_count;

	}

	my $dbh = Tab::DBI->db_Main();

	my $second_round_id = $round_settings{"flight_b_round"};

	my $second_round = 
		Tab::Round->retrieve($second_round_id) 
		if $second_round_id;

	undef $second_round 
		unless $second_round 
		&& $second_round->event->id == $round->event->id;

    my $double_entry_sth = $dbh->prepare("

        select distinct thisentry.id, 
			thatballot.entry, 
			thatballot.speakerorder, 
			thatsetting.value

        from (entry thisentry, entry_student thises, round thisround,
             round thatround, panel thatpanel, ballot thatballot, entry_student thates)

		left join event_setting thatsetting 
			on thatsetting.event = thatround.event
			and thatsetting.tag = 'speaker_priority_first'

        where thisround.id = ?
        and thisround.event = thisentry.event
        and thisentry.id = thises.entry
        and thises.student = thates.student
        and thises.entry != thates.entry
        and thates.entry = thatballot.entry
        and thatballot.panel = thatpanel.id
        and thatpanel.round = thatround.id
        and thatround.timeslot = thisround.timeslot
	");

	$double_entry_sth->execute($round->id);

	while ( my ($this_entry, $that_entry, $that_order, $speaklate) 
		= $double_entry_sth->fetchrow_array() 
	) { 
		$entries{$this_entry}{$round}{"order"} = $that_order;
		$entries{$this_entry}{$round}{"late"} = $speaklate;
	}

	if ($second_round) { 

		$double_entry_sth->execute($second_round);

		while ( my ($this_entry, $that_entry, $that_order, $speaklate) 
			= $double_entry_sth->fetchrow_array() 
		) { 
			$entries{$this_entry}{$round}{"order"} = $that_order;
			$entries{$this_entry}{$round}{"late"} = $speaklate;
		}

	}

	my %sseen = (); 
	@schools = grep { ! $sseen{$_} ++ } @schools;
	@schools = sort {$size_of_school{$b} <=> $size_of_school{$a}} @schools;
	my %school_rank = ();

	my $ranker = 1;
	foreach (@schools) { 
		$school_rank{$_} = $ranker++;
	}

	#Set up the initial sections

	my $max_size = ceil(scalar @all_entries / $num_panels);
	my $min_size = floor(scalar @all_entries/ $num_panels);
	my $remainder = (scalar @all_entries - ($num_panels * $min_size));

	my %sections = ();

	use List::Util 'shuffle';
	my @keys =  shuffle( 1 .. $num_panels);

	my %forbidden_sections = ();

	my $limit_count =  (scalar @keys) * $percent_limit * .01;

	if ($limit_count) { 

		foreach my $school (@schools) { 

			next if $size_of_school{$school} < $limit_count;

			my $counter;
			my $limited;

			foreach my $key (shuffle @keys) { 
				next if $counter++ <= $limit_count;
				$forbidden_sections{$school}{$key}++;
				$limited++;
			}

		}

		@all_entries = 
			sort { $size_of_school{$entries{$b}{"school"}} 
				<=> $size_of_school{$entries{$a}{"school"}} } 
			@all_entries;

	}

	foreach my $entry (@all_entries) { 

		my $score = "3141592653";   #Shut up.
		my $picked_key;

		KEY:
		foreach my $key (@keys) { 

			next if $score == 0;
			next if $forbidden_sections{$entries{$entry->id}{"school"}}{$key};

			my @section = @{$sections{$key}} if $sections{$key};

			next KEY if (scalar @section) >= $max_size;

			if ((scalar @section) == $min_size) {
				next KEY unless $remainder > 0;
			}

			if (@section) { 

				push (@section, $entry->id);

				my $new_score = score_section(
					\@section,
					\%hits,
					\%entries
				);
			
				if ($new_score < $score) { 
					$picked_key = $key;
					$score = $new_score;
					last KEY if $score == 0;
				}

			} else {
					
				$picked_key = $key;
				$score = 0;
				last KEY;
			}

		}

		$remainder-- if $sections{$picked_key} 
			&& scalar @{$sections{$picked_key}} == $min_size;

		push (@{$sections{$picked_key}}, $entry->id);

		my $k = shift @keys;
		push (@keys, $k);

	}

	my @section_keys = sort keys %sections;

	foreach my $section_key (@section_keys) { 
		@{$sections{$section_key}} = 
			sort {$school_rank{$entries{$a}{"school"}} 
				<=> $school_rank{$entries{$b}{"school"}} } 
				@{$sections{$section_key}};
	}

	my $no_improvement = 1;

	foreach my $counter (1 .. 7) { 

		my $total;

		next if $no_improvement == 0;
		$no_improvement = 0;

		foreach my $section_key (@section_keys) { 
		
			my @section = @{$sections{$section_key}};
			my $entry_section1_score = score_section(
				\@section, 
				\%hits, 
				\%entries
			);

			next if $entry_section1_score < 1;

			ENTRY:
			foreach my $entry_id (@section) { 
			
				next if $entry_section1_score < 1;

				# Remove the candidate for a test array of original section
				my @section1 = @section; 	
				my $index = 0;

				$index++ until $section1[$index] == $entry_id;
				splice(@section1, $index, 1);

				my $swap_section;
				my $swap_entry;
				my $current_diff;

				my @new_entry_section;
				my @new_swap_section;

				my $count;
	
				OTHERPANEL:
				foreach my $other_key (@section_keys) { 

					next if $forbidden_sections{$entries{$entry_id}{"school"}}{$other_key};

					# Can't switch to the same section
					next if $other_key == $section_key; 				

					# Find the other section for scoring
					my @section2 = @{$sections{$other_key}}; 			

					my $other_section2_score = score_section(
						\@section2, 
						\%hits, 
						\%entries
					);

					# Put me into this section for testing
					push (@section2, $entry_id);					

					OTHERENTRY:
					foreach my $other_entry_id (@{$sections{$other_key}}) {
					
						next if $forbidden_sections{$entries{$other_entry_id}{"school"}}{$section_key};

						# Add swap candidate to original section
						push (@section1, $other_entry_id);				

						$count++;

						my $other_section1_score = score_section(
							\@section1, 
							\%hits, 
							\%entries
						);

						# Remove swap candidate from the section
						my $index = 0;									

						$index++ until $section2[$index] == $other_entry_id;
						splice(@section2, $index, 1);

						my $entry_section2_score = score_section(
							\@section2, 
							\%hits, 
							\%entries
						);

						my $squo_score = $entry_section1_score + $other_section2_score;
						my $swap_score = $entry_section2_score + $other_section1_score;
						my $diff = $squo_score - $swap_score;

						my $replace = pop(@section1);  #remove me from this section
						push (@section2, $replace);    #put me back from whence I came

						if ( $diff > 0 && $diff > $current_diff) { 
							$current_diff = $diff;
							$swap_entry = $other_entry_id;
							$swap_section = $other_key;
						}

					}

				}

				if ($swap_entry) { 

					my @section2 = @{$sections{$swap_section}};

					push (@section1, $swap_entry);

					my $swapdex = 0;
					$swapdex++ until $section2[$swapdex] == $swap_entry;
					splice(@section2, $swapdex, 1);

					push (@section2, $entry_id);

					$no_improvement++;  # Fail
					@{$sections{$section_key}} = @section1;
					@{$sections{$swap_section}} = @section2;

					@section = @section1;

					$entry_section1_score = score_section(
						\@section1, 
						\%hits, 
						\%entries
					);

					my $other_score = score_section(
						\@section2,
						\%hits, 
						\%entries
					);

				}
			}
		}

		last if $no_improvement < 1;

	}

	my @judges = $m->comp(
		"/funclib/round_judges.mas", 
		round => $round
	);

	my @judge_keys;

	my %judge_section = ();

	foreach my $judge (@judges) { 
		push (@{$judge_section{$judge->panelid}}, $judge->id);
		push (@judge_keys, $judge->panelid);
	}

	my %jseen = (); 
	@judge_keys = grep { ! $jseen{$_} ++ } @judge_keys;

	my @rooms = $m->comp(
		"/funclib/round_rooms.mas", 
		round => $round
	);

	my @clean_rooms = $m->comp(
		"/funclib/clean_rooms.mas", 
		round => $round
	);

	#Clear out the old

	Tab::Score->set_sql( delete_round => "
		delete score from score, ballot, panel
		where panel.round = ?
		and panel.id = ballot.panel
		and ballot.id = score.ballot
	");

	Tab::Ballot->set_sql( delete_round => "
		delete ballot from ballot, panel
		where panel.round = ?
		and panel.id = ballot.panel
	");

	Tab::Panel->set_sql( delete_round => "
		delete from panel where round = ?
	");

	Tab::Score->sql_delete_round->execute($round->id);
	Tab::Ballot->sql_delete_round->execute($round->id);
	Tab::Panel->sql_delete_round->execute($round->id);

	my $letter = 1;
	$letter = "A" if $event_settings{"panel_labels"} eq "letters";

	# If I have a second flighted situation, track half my sections into the
	# second flight timeblock. 

	my %section_second; 

	if ($second_round) { 

		my $switch;
	
		foreach my $section_key (@section_keys) { 
			next if $switch++ % 2;
			$section_second{$section_key}++;
		}

	}

	#Set speaker order
	foreach my $section_key (@section_keys) { 

		my @entries = @{$sections{$section_key}};

		@entries = shuffle(@entries);

		@entries = sort { $entries{$b}{"order_total"} <=> $entries{$a}{"order_total"} } @entries;

		my $size_of_section = scalar @entries;

		my $moved = 1;

		my $this_round = $round;
		$this_round = $second_round 
			if $section_second{$section_key}
			&& $second_round;

		foreach (1 .. 10) { 
			
			next unless $moved;

			undef $moved;
			my $position;

			foreach my $entry (@entries) { 

				$position++;

				if ($entries{$entry}{"order_count"}{$position}) { 

					#Remove from place in line

					my $place;

					#Find a new home

					$place = $position;

					while ($place == $position) { 
						$place = int(rand($size_of_section));
					}
	
					$place--;
					$place = 1 if $place < 0;
					splice(@entries,($place - 1),0,$entry);
					$moved++;
				}
			}
			
			my %seen;
			@entries = grep { ! $seen{$_} ++ } @entries;

			foreach my $entry (@entries) { 

				if (
					$entries{$entry}{$this_round}{"order"}
					|| $entries{$entry}{$this_round}{"late"} 
				) { 

					my $speakdex = 0;
					$speakdex++ until $entries[$speakdex] == $entry;

					splice(@entries, $speakdex, 1);

					my $place;

					if ($speaker_priority_first) { 
						$place = 1;
					} elsif ($entries{$entry}{$this_round}{"late"}) { 
						$place = 7;
					} elsif ($entries{$entry}{$this_round}{"order"} > 3) { 
						$place = 1;
					} else { 
						$place = 7;
					}

					$place = 1 if $place < 0;

					splice(@entries,($place - 1),0,$entry);

				}

			}

		}

		@{$sections{$section_key}} = @entries;
	}

	unless ($num_panels == 1) { 

		foreach my $section_key (@section_keys) { 

			my $room = shift @rooms if @rooms;
			my $room_id = 0;
			$room_id = $room->id if $room;

			my $jsection = shift @judge_keys if @judge_keys;
			my @judge_ids = @{$judge_section{$jsection}} if $jsection;
			@judge_ids = ("0") unless @judge_ids;

			my @section = @{$sections{$section_key}};
			
			my $score = score_section(
				\@section,
				\%hits, 
				\%entries
			);

			my $this_round = $round;
			$this_round = $second_round if $section_second{$section_key};

			my $section = Tab::Panel->create({
				round  => $this_round->id,
				room   => $room_id,
				letter => $letter,
				score  => $score,
				flight => 1
			});


			foreach my $judge_id (@judge_ids) { 

				my $position;

				foreach my $entry (@section) { 

					$position++;

					next unless $entry;

					my $ballot = Tab::Ballot->create({
						panel        => $section->id,
						judge        => $judge_id,
						entry        => $entry,
						speakerorder => $position
					});

				}
			
			}

			if ($letter eq "Z") { 
				$letter = "AA";
			} else { 
				$letter++;
			}

		}

	}

	my $now = DateTime->now;
	$round->created($now);
	$round->update;

	return;

	sub score_section {

		my ($panref, $hitsref, $entref) = @_; 

		my @pan_entries = @$panref;

		my $score = 0;
		my $tick;

		my $hitscore = 100000;
		$hitscore = 10000000 if ${$hitsref}{"nsda"};

		my $regionscore = 1000;
		undef $regionscore if ${$hitsref}{"nsda"};

		my $titlescore = 100000 if ${$hitsref}{"nsda"};

		my $seed_average = ${$hitsref}{"seed_average"};
		my $average_score = 100 if $seed_average;

		my $panel_total;

		foreach my $entry (@pan_entries) { 

			$panel_total += ${$entrref}{$entry}{"seed"};

			foreach my $other (@pan_entries) { 

				next unless $other > $entry;

				if (${$entref}{$other}{"school"} == ${$entref}{$entry}{"school"}) { 
					$score += $hitscore;
					$score += $hitscore if ${$hitsref}{$entry}{"ownschool"};
				}

				if ($regionscore) { 

					if (${$entref}{$other}{"region"} == ${$entref}{$entry}{"region"}) { 
						$score += $regionscore;
						$score += $regionscore if ${$hitsref}{$entry}{"ownregion"};
					}

				}

				if ($titlescore) { 

					if (${$entref}{$other}{"title"} eq ${$entref}{$entry}{"title"}) { 
						$score += $titlescore;
					}

				}

				$score += 100 if ${$hitsref}{$entry}{"entry"}{$other};

				$score += 1 if ${$hitsref}{"school"}{${$entref}{$other}{"school"}};
				$score += 1 if ${$hitsref}{"region"}{${$entref}{$other}{"region"}};
		
			}

		}

		my $average = ($panel_total / (scalar @pan_entries)) if $panel_total;
		$score += $average * $average_score;

		return $score;

	}

</%perl>
