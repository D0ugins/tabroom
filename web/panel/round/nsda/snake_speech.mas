<%args>
	$round
	$limit_to
	$num_panels
</%args>
<%init>

	use List::Util 'shuffle';

	my $event = $round->event;
	my %event_settings = $event->all_settings;
	my $tourn = $event->tourn;

	my $previous_round = Tab::Round->search( 
		event => $event->id,
		name => ($round->name - 1)
	)->first;

	return unless $previous_round;

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;
	my $now = DateTime->now(time_zone => $tz);

	my (@results) = $m->comp(
		"/tabbing/results/order_entries.mas", 
			round => $from 
	);

	return unless @results;

	my $entries_ref = pop @results;

	my @advancing;

	foreach my $seed (sort {$a <=> $b} keys %{$entries_ref->{"by_place"}}) { 

		push @advancing, @{${$entries_ref->{"by_place"}{$seed}}};
		last if scalar @advancing >= $limit_to;
	}

	my @already_panels = $round->panels;
	my @panels;

	my $letter = 1;
	$letter = "A" if $event_settings{'panel_labels'} eq "letters";

	foreach my $tick (1 .. $num_panels) {

		my $panel = shift @panel_panels if @panel_panels;

		unless ($panel) { 

			$panel = Tab::Panel->create({
				letter => $letter,
				round  => $round,
				flight => 1
			});

		}

		push @panels, $panel;

	}

	my %panel_entries;
	my $max_seed = 1; 

	my @next_panels = sort {$a->id <=> $b->id} @panels;
	my @now_panels;

	my $max_panelsize = POSIX::ceil( (scalar @advancing) / $num_panels );

	if ($num_panels == 1) { 

		# this is a final round, no snaking or adjustment possible!

		my $panel = $panels[0];
		push @{$panel_entries{$panel->id}}, @advancing;

	} else {

		# Perform the initial snake; 

		foreach my $entry (@advancing) {

			$entries_ref->{"entry_by_seed"}{$max_seed} = $entry_id;
			$entries_ref->{"seed_position"}{$entry_id} = $max_seed++;

			unless (@now_panels) { 
				@now_panels = @next_panels;
				undef @next_panels;
			}

			my $panel = shift @now_panels;
			push @{$panel_entries{$panel->id}}, $entry if $panel;
			$entries_ref->{"panel"}{$entry_id} = $panel->id;

			#Put at the start of the next row
			unshift @next_panels, $panel; 

		}

	}

	my @panels = (@next_panels, @now_panels);

	my %seen = ();
	@panels = grep { ! $seen{$_->id} ++ } @panels;
	@panels = sort {$a->id <=> $b->id} @panels;

	if ($round->type eq "prelim") { 
		
		# In the NSDA CA plan, entries are moved forward if necessary to avoid
		# school conflicts

		my %school_count = ();

		foreach my $panel (@panels) { 

			foreach my $entry (@{$panel_entries{$panel->id}}) { 

				my $school_id = $entries_ref->{"school"}{$entry_id};

				if ($school_count{$panel->id}{$school_id}++) { 

					# There's a school conflict here!  Find the next available
					# position.

					my $seed = $entries_ref->{"seed"}{$entry_id};
					my $target_seed;

					foreach my $test_seed ($seed .. $max_seed) { 

						my $test_entry = $entries_ref->{"entry_by_seed"}{$test_seed};
						my $test_panel = $entries_ref->{"panel"}{$test_entry};
						my $test_school = $entries_ref->{"school"}{$test_entry};

						next if ( 
							$school_count{$test_panel}{$school_id} 
							>= $entries_ref->{"school"}{$entry_id} );

						next if (
							$entries_ref->{"school"}{$test_entry}
							>= $school_count{$panel->id}{$test_school} );

						$target_seed = $test_seed;
						last if $target_seed;
					}

					if ($target_seed) { 

						my @swap_train;

						foreach my $snake_seed ($seed .. $target_seed) { 
							push @swap_train, $entries_ref->{"entry_by_seed"}{$snake_seed};
						}

						my $myself = shift @swap_train;  # This is me! 
						push @swap_train, $myself;       # To the end of the line;

						my $current_panel = $entries_ref->{"panel"}{$myself};
						my $new_seed = $seed;

						foreach my $swap_entry (@swap_train) { 

							# Add to current panel
							push @{$panel_entries{$current_panel}}, $swap_entry;

							# Change my seed position to the new one
							$entries_ref->{"entry_by_seed"}{$swap_entry} = $seed++;

							# Find my old panel
							my $old_panel = $entries_ref->{"panel"}{$myself}; 

							# Change my current panel setting
							$entries_ref->{"panel"}{$myself} = $current_panel;

							# Remove me from my old panel
							my $index = 0; 
							$index++ until ${$panel_entries{$old_panel}}[$index] == $swap_entry; 
		                    splice(@{$panel_entries{$old_panel}}, $index, 1); 

							# Make the old panel the next entry's destination
							$current_panel = $old_panel;

						}

					}

				}

			}

		}

	}

	# Save the panels


</%init>
