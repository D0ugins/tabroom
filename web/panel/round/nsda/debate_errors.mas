<%args>
	$round
</%args>
<%doc>

	Check the bottom for simplified display code.  There's no need to create a
	separate module file for code that will never be called by something other
	than this screen and it slows down the app considerably.

</%doc>
<%init>

	return unless $round;

    my $timeslot = $round->timeslot;
    my $tourn = $timeslot->tourn;
    my $event = $round->event;

	my $aff_string = $event->setting("aff_string");
	$aff_string = "Aff" unless $aff_string;

	my $neg_string = $event->setting("neg_string");
	$neg_string = "Neg" unless $neg_string;

    my %tags; 
    my %problems;
    my $dbh = Tab::DBI->db_Main();
    
    # RIGHT NUMBER OF AFF/NEGS

    my $side_locked;
    my $side_lock_against = $round->setting("sidelock_against");

    if ($side_lock_against) { 

        if ($side_lock_against ne "NONE") { 
            $side_locked++;
        }

    } else { 
        $side_locked++ unless ($round->name % 2);  
        undef $side_locked if $event->setting("no_side_constraints");
    }    

	undef $side_locked if $round->type eq "elim" || $round->type eq "final";
                
	if ($side_locked) { 

		$tags{"sides_uneven"} = "Entries on the wrong side";

		my $round_number = $round->name;

		while ( (not defined $side_lock_against) && ($round_number > 0)) { 
			#Find previous round
			$round_number--;
			my $sla = Tab::Round->search( event => $event->id, name => $round_number)->first;
			$side_lock_against = $sla->id if $sla;
		}

		if ($side_lock_against) { 
        
			my $sides_sth = $dbh->prepare("
				select entry.code, b1.side, b2.side 
				from entry,
					ballot b1, panel p1,
					ballot b2, panel p2

					where b1.entry = entry.id
					and b1.panel = p1.id
					and p1.bye != 1

					and b2.entry = entry.id
					and b2.panel = p2.id
					and p2.bye != 1

					and p1.round = ".$round->id."
					and p2.round = ".$side_lock_against."

			");
			
			$sides_sth->execute(); 
			
			while (my ($entry, $side1, $side2)  = $sides_sth->fetchrow_array() ) {
				$problems{"sides_uneven"} .= '<p class="warning padless marno">'. $entry." should be on the opposite side this round!</p>" if $side1 == $side2;
			}

		}

    }

	if ($event->setting("round_robin")) { 

		#SIDES WORK OUT IN A ROUND ROBIN
		$tags{"round_robin_side_count"} = "Round Robin: Inequal numbers of ".$aff_string."s/".$neg_string."s";
		$tags{"round_robin_side_order"} = "Round Robin: Too many of the same side in a row";

		my $sth = $dbh->prepare("
			select distinct round.name, ballot.side as side, ballot.bye as bye, panel.bye as pbye
			from round, ballot, panel
			where ballot.entry = ?
			and ballot.panel = panel.id
			and panel.round = round.id
			group by round.name
			order by round.name
		");

		foreach my $entry ($m->comp("/funclib/round_entries.mas", round => $round)) { 

			$sth->execute($entry->id);

			my $aff_count;
			my $neg_count;

			my $in_a_row;
			my $current_side;

			while (my ($name, $side, $bye, $pbye) = $sth->fetchrow_array() ) { 

				next if $bye;
				next if $pbye;

				if ($side == $current_side) { 
					$in_a_row++;
				} else { 
					$in_a_row = 1;
					$current_side = $side;
				}

				if ($in_a_row > 2) { 
					my $sidename = $aff_string;
					$sidename = $neg_string if $side == 2;
					$problems{"round_robin_side_order"} .= '<p class="warning padless marno">'. $entry->code." debates on $sidename $in_a_row times in a row</p>";
				}

				$aff_count++ if $side == 1;
				$neg_count++ if $side == 2;

			}

			next if $aff_count == $neg_count;
			next if ($aff_count + 1) == $neg_count;
			next if ($neg_count + 1) == $aff_count;
			
			$problems{"round_robin_side_count"} .= '<p class="warning padless marno">'. $entry->code." has a side imbalance.  $aff_count on $aff_string, $neg_count on $neg_string</p>";

		}

	}
    
    # UNSCHEDULED ENTRIES
    
    $tags{"unscheduled_entries"} = "Entries not on the pairing";

    unless ($round->type eq "elim" || $round->type eq "final") {

		Tab::Entry->set_sql( not_debating => "
			select entry.*
			from entry
			where entry.event = ?
                        and dropped = 0
			and entry.dropped = 0
			and entry.dq = 0
			and entry.waitlist = 0
			and not exists (
				select ballot.id
				from ballot, panel
				where panel.round = ? 
				and ballot.panel = panel.id
				and ballot.entry = entry.id)" );

        foreach my $entry (Tab::Entry->search_not_debating( $event->id, $round->id )) { 
			$problems{"unscheduled_entries"}.= '<p class="warning padless marno">'. $entry->code. " is not scheduled</p>";
        }
    }

	# ENTRIES SCHEDULED TOO MANY TIMES
	$tags{"double_scheduled_entries"} = "Entries on the pairing twice";

	Tab::Entry->set_sql( debating_twice => "
		select entry.*
		from entry, ballot b1, panel p1, ballot b2, panel p2

		where entry.id = b1.entry
		and b1.panel = p1.id
		and entry.id = b2.entry
		and b2.panel = p2.id

		and p1.id > p2.id
		and p1.round = ? 
		and p1.round = p2.round 
	");

	foreach my $entry (Tab::Entry->search_debating_twice($round->id )) { 
		$problems{"double_scheduled_entries"}.= '<p class="warning padless marno">'. $entry->code. " is scheduled twice in the same round</p>";
	}
    
    #MEETING OWN SCHOOL
	$tags{"same_school_sections"} = "Entries debating their own school";

	Tab::Entry->set_sql( same_school_sections => "
		select entry.*, opp.code as othername
		from entry, ballot, panel, 
		entry opp, ballot oballot

			where entry.id = ballot.entry
			and ballot.panel = oballot.panel
			and oballot.entry = opp.id
			and ballot.panel = panel.id
			and panel.round = ? 
			and opp.school = entry.school
			and opp.id < entry.id
	");

	foreach my $entry (Tab::Entry->search_same_school_sections($round->id )) { 
		$problems{"same_school_sections"}.= '<p class="warning padless marno">'. $entry->code." and ".$entry->othername." are from the same school!</p>";
	}


    #ENTRIES PREVIOUS MET
    
    $tags{"hit_before"} = "Entries who have debated before";

    my $second_hit_sth = $dbh->prepare("
		select distinct me.code, opp.code othername, otherround.name roundname, me_b1.side side1, me_b2.side side2, otherround.type

		from entry me, entry opp, round otherround,

			ballot me_b1, ballot opp_b1, panel p1, 
			ballot me_b2, ballot opp_b2, panel p2

			where me_b1.entry = me.id
			and opp_b1.entry = opp.id
			and me_b1.panel = opp_b1.panel
			and me_b1.panel = p1.id

			and p1.round = ? 

			and me_b2.entry = me.id
			and opp_b2.entry = opp.id
			and me_b2.panel = opp_b2.panel
			and me_b2.panel = p2.id
			and p2.round != p1.round
			and p2.round = otherround.id

			and me.id > opp.id
	");

	$second_hit_sth->execute($round->id);
		
	while (my ($entry, $opp, $round, $side1, $side2, $type)  = $second_hit_sth->fetchrow_array() ) {

		$problems{"hit_before"}.= '<p class="warning padless marno">'. "Entry $entry debated $opp already in round $round ";
		$problems{"hit_before"}.= "on the SAME SIDE </p>" if $side1 == $side2;
		$problems{"hit_before"}.= "on the OPPOSITE SIDE </p>" if $side1 != $side2;
	}

	#

    # ENTRY: HIT SAME SCHOOL TWICE IN PRESETS
    
	if ($round->type eq "prelim") { 

		$tags{"same_school_twice"} = "Entries debating a school twice in presets";

		Tab::Entry->set_sql( "same_school_twice" => "

			select distinct me.*, otherschool.name othername

			from entry me, school otherschool,
				entry opp1, ballot b1, panel p1, ballot ob1,
				entry opp2, ballot b2, panel p2, ballot ob2, round r2

				where me.id = b1.entry
				and b1.panel = p1.id
				and ob1.panel = p1.id
				and opp1.id = ob1.entry
				and ob1.entry != me.id

				and me.id = b2.entry
				and b2.panel = p2.id
				and ob2.panel = p2.id
				and opp2.id = ob2.entry
				and ob2.entry != me.id
			
				and p1.round != p2.round
				and p1.round = ?
				and p2.round = r2.id
				and r2.type = \"prelim\"

				and opp1.id != opp2.id
				and opp1.school = opp2.school
				and opp1.school = otherschool.id

		");

		foreach my $entry (Tab::Entry->search_same_school_twice($round->id)) { 
			$problems{"same_school_twice"} .= '<p class="warning padless marno">'. $entry->code." debates against entries from  ".$entry->othername." twice in presets. </p>";
		}

	}

  
</%init>

	<h4><% $round->realname %> potential errors:</h4>

%	my @tags = sort {$tags{$a} cmp $tags{$b}} keys %tags;

%	@tags = sort {length $problems{$b} <=> length $problems{$a}} @tags;

%	foreach my $tag (@tags) {

		<div class="row full">

			<span class="half">
				<% $tags{$tag} %> 
			</span>

			<span class="half nospace padleft">
				<% 
					$problems{$tag} 
					?  $problems{$tag} 
					: '<span class="centeralign nospace full strong greentext"> OK! </span>' 
				%>
			</span>
		</div>

% 	}

