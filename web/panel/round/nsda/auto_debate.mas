<%args>
	$round
	$limit_to
	$debug => 1
</%args>
<%init> 

	use List::Util 'shuffle';

	my $event = $round->event;
	my %event_settings = $event->all_settings;

	my $previous_round = Tab::Round->search( 
		event => $event->id, 
		name => ($round->name - 1)
	)->first;

	my @results = $m->comp(
		 "/tabbing/results/order_entries.mas",
		 round => $previous_round,
	) if $previous_round; 
	

	my $ref = pop @results if @results;

	my %entries = %{$ref};

	# Acquire the relevant opponent data

	my $dbh = Tab::DBI->db_Main();

	my $scores = ({
		bracket => "1000000000000",
		school  => "1000000000",
		repeat  => "1000000",
		side    => "1000"
	});

	$entries{"scores"} = $scores;
	$entries{"scores"}{"side"} = 0 if $event_settings{"no_side_constraints"};

	foreach my $key (sort {$a <=> $b} keys %{$entries{"by_place"}}) {

		foreach my $entry_id (@{${$entries{"by_place"}}{$key}}) {

			next if (scalar (keys %{$entries{"unpaired"}}) >= $limit_to );

			$entries{"unpaired"}{$entry_id}++;

			$entries{"school_size"}{$entries{"school_id"}{$entry_id}}++;
			
			my $losses = $entries{"tiebreak"}{1}{$entry_id};

			push @{$entries{"brackets"}{$losses}}, $entry_id;
			$entries{$entry_id}{"losses"} = $losses;

		}

	}

    my $school_debates_self++ 
		if $event_settings{"school_debates_self"};


	my $ballot_sth = $dbh->prepare('
		select distinct 
			entry.id, 
			opponent.id, opponent.school,
			round.name,
			ballot.bye, panel.bye, ballot.side

		from (entry, ballot, panel, round)

		left join ballot opp_ballot on 
			opp_ballot.panel = panel.id
			and opp_ballot.entry != entry.id

		left join entry opponent on 
			opponent.id = opp_ballot.entry
			and opponent.id != entry.id

		where entry.event = ?
		and entry.active = 1
		and entry.id = ballot.entry
		and ballot.panel = panel.id
		and panel.round = round.id
		and round.name < ? 
	');

	$ballot_sth->execute($event->id, $round->name);

	while( 
		my (
			$entry_id, $opp_id, $opp_school, 
			$round_name, 
			$ballot_bye, $panel_bye, 
			$ballot_side
		)
		= $ballot_sth->fetchrow_array() 
	) {

		$entries{$entry_id}{"byes"}++ if $panel_bye;
		next if ($panel_bye);

		$entries{$entry_id}{"hits"}{$opp_id}++;
		$entries{$entry_id}{"hit_school"}{$opp_school}++;
		$entries{$entry_id}{"side_count"}{$ballot_side}++;

		$entries{$entry_id}{$round_name}{"opp"} = $opp_id;
		$entries{$entry_id}{$round_name}{"side"} = $ballot_side;
		push @{$entries{$entry_id}{"opponents"}}, $opp_id;


	}

	our $round_log;
	our $step_counter;

	# STEP ONE: DRAW THE BYE
	my $num_entries = scalar (keys %{$entries{"unpaired"}});

	my %panels;

	my $selected_bye;

	if ($num_entries % 2) {

		if ($num_entries > 3) { 

			logMe("Drawing a bye; $num_entries is odd:");

			my @bye_eligible;

			# First, one-loss teams who lost to an undefeated and have not
			# drawn a bye.

			ENTRY:
			foreach my $entry_id (@{$entries{"brackets"}{1}}) { 

				next if $entries{$entry_id}{"byes"} > 0;

				my $undefeated_loss;

				foreach my $opponent (@{$entries{$entry_id}{"opponents"}}) { 
					$undefeated_loss++ unless $entries{$opponent}{"losses"} > 0;
					last if $undefeated_loss;
				}

				next unless $undefeated_loss;
				push @bye_eligible, $entry_id;
				
			}

			unless (@bye_eligible) { 

				my $message = " No entries without a bye have lost to an undefeated entry.";
				$message .= "Drawing from all entries without a bye";

				logMe($message);

				ENTRY:
				foreach my $entry_id (@{$entries{"brackets"}{1}}) { 

					next if $entries{$entry_id}{"byes"};
					push @bye_eligible, $entry_id;
				
				}
			}

			my $eligibles;

			foreach my $entry_id (@bye_eligible) {
				$eligibles .= ", " if $eligibles;
				$eligibles .= $entries{"code"}{$entry_id};
			}

			logMe("Entries eligible for byes: $eligibles");

			@bye_eligible = shuffle(@bye_eligible);
			$selected_bye = shift @bye_eligible;

			logMe("Randomly selected ".$entries{"code"}{$selected_bye}." as the BYE");

			$panels{$selected_bye}{"opponent"} = "BYE"; 
			$panels{$selected_bye}{"bracket"} = "1";

		}

		# Remove bye from the brackets;

		delete($entries{"unpaired"}{$selected_bye});

		my $index;  

		my $bye_bracket = $entries{$selected_bye}{"losses"};

		$index++ until (
			(${$entries{"brackets"}{$bye_bracket}}[$index] == $selected_bye)
			|| ($index > scalar @{$entries{"brackets"}{$bye_bracket}})
		);

		splice(@{$entries{"brackets"}{$bye_bracket}}, $index, 1); 

		foreach my $bracket (0 .. 1) { 

			my $bracket_string;

			foreach my $id (@{$entries{"brackets"}{$bracket}}) { 
				$bracket_string .= ", " if $bracket_string;
				$bracket_string .= $entries{"code"}{$id};

			}

			$bracket_string = " $bracket loss bracket is now: ".$bracket_string;
			logMe($bracket_string);

		}

	} else { 

		logMe("No bye need be drawn; $num_entries entries");

	}

	# STEP TWO: PAIR THE BRACKETS!

	# Score every entry against every opponent:

	foreach my $bracket (0 .. 1) { 

		foreach my $entry (@{$entries{"brackets"}{$bracket}}) {

			my $notfirst;

			foreach my $opponent (keys %{$entries{"unpaired"}}) { 

				# Me on the aff
				unless ($entries{"scores"}{$entry}{$opponent})  { 
					$entries{"scores"}{$entry}{$opponent} 
						= scoreDebate($entry, $opponent, \%entries);
				}

				# Me on the neg
				unless ($entries{"scores"}{$opponent}{$entry})  { 
					$entries{"scores"}{$opponent}{$entry} 
						= scoreDebate($opponent, $entry, \%entries);
				}
				
				unless ($notfirst++) { 

					Tab::debuglog($entries{"code"}{$entry}
						." side differential is ".
						( $entries{"scores"}{$entry}{$opponent} 
							- $entries{"scores"}{$opponent}{$entry}
						)
					);


				}

			}

		} 

	} 

	foreach my $bracket (0 .. 1) { 

		logMe(" Pairing $bracket loss bracket into debates ");

		# Assign initial opponents

		foreach my $entry (shuffle (@{$entries{"brackets"}{$bracket}}) ) { 

			next if $panels{$entry}{"opponent"};

			my $chosen;
			my $entry_side;

			# First, find the best possible matchup left on the aff. 

			my @opponents = 
				sort { 
					$entries{"scores"}{$entry}{$a} 
						<=> 
					$entries{"scores"}{$entry}{$b} 
				} keys (%{$entries{"unpaired"}});

			my $aff_opponent;

			foreach my $opp (@opponents) { 
				next if $opp == $entry;
				next if $panels{$opp}{"opponent"};
				$aff_opponent = $opp;
				last;
			}

			if ($event_settings{"no_side_constraints"}) { 

				$chosen = $aff_opponent;
				$entry_side = 1;

			} else { 

				# Now try the other side

				my @opponents = 
					sort { 
						$entries{"scores"}{$a}{$entry} 
							<=> 
						$entries{"scores"}{$b}{$entry}
					} keys (%{$entries{"unpaired"}});

				my $neg_opponent;

				foreach my $opp (@opponents) { 
					next if $opp == $entry;
					next if $panels{$opp}{"opponent"};
					$neg_opponent = $opp;
					last;
				}

				$chosen = $aff_opponent unless $neg_opponent;
				$chosen = $neg_opponent unless $aff_opponent;

				unless ($chosen) { 

					$chosen = $aff_opponent;

					if ($entries{"scores"}{$entry}{$aff_opponent} 
						< $entries{"scores"}{$neg_opponent}{$entry}
					) { 

						$chosen = $aff_opponent;
						$entry_side = 1;

					} elsif ($entries{"scores"}{$entry}{$aff_opponent} 
						> $entries{"scores"}{$neg_opponent}{$entry}
					) { 

						$chosen = $neg_opponent;
						$entry_side = 2;

					} else { 

						# Flip the proverbial coin, all else being equal

						if (int(rand(100)) > 50) { 

							$chosen = $aff_opponent;
							$entry_side = 1;

						} else { 

							$chosen = $neg_opponent;
							$entry_side = 2;

						}
					}
				}

				unless ($chosen) { 

					logMe("Something has gone wrong: no opponent found for ".$entries{"code"}{$entry});

				} else { 

					$panels{$entry}{"side"} = $entry_side;
					$panels{$entry}{"opponent"} = $chosen;
					$panels{$entry}{"bracket"} = $bracket;

					my $chosen_side = $entry_side - 1;
					$chosen_side = 2 if $chosen_side < 1;

					$panels{$chosen}{"side"} = $chosen_side;
					$panels{$chosen}{"opponent"} = $entry;
					$panels{$chosen}{"bracket"} = $bracket;


				}

			}

		}

		foreach my $entry (shuffle (@{$entries{"brackets"}{$bracket}}) ) { 

			my $opp = $panels{$entry}{"opponent"};
			my $entry_side = $panels{$entry}{"side"};

			my $score = $entries{"scores"}{$entry}{$opp} if $entry_side == 1;
			$score = $entries{"scores"}{$opp}{$entry} if $entry_side == 2;

			logMe($entries{"code"}{$entry}." debates ".$entries{"code"}{$opp}." on ".$entry_side." with score $score");

		}

		logMe("Trying double shuffles to see if any improvements can be made");

		# Do swapping to ensure the best overall scoring of pairings 

		foreach my $pass ( 1 .. 20) { 
		
			my $swap_counter; 

			foreach my $entry (shuffle (@{$entries{"brackets"}{$bracket}}) ) { 

				my $entry_side = $panels{$entry}{"side"};
				my $entry_opponent = $panels{$entry}{"opponent"};

				# This shouldn't happen but what the hell, let's check. 
				next if $entry_opponent eq "BYE";

				my $entry_opponent_side = $panels{$entry_opponent}{"side"};

				my $entry_baseline = $entries{"scores"}{$entry}{$entry_opponent} if $entry_side == 1;
				$entry_baseline = $entries{"scores"}{$entry_opponent}{$entry} if $entry_side == 2;

				# Do this because the 0 loss bracket can pull up different debaters
				# to solve conflicts; but the 1 loss bracket cannot solve conflicts
				# from the 0 loss bracket. 

				my $swap_candidate; 
				my $current_diff;

				my $entry_bracket = $entries{$entry}{"losses"};

				foreach my $other (shuffle (@{$entries{"brackets"}{$entry_bracket}}) ) { 

					next if $other == $entry;
					next if $other == $entry_opponent;

					my $other_opponent = $panels{$other}{"opponent"};
					next if $other_opponent eq "BYE";

					# This is the point of comparison for any swapping

					# How does the candidate score if they go into my spot?

					my $other_swap;
					$other_swap = $entries{"scores"}{$other}{$entry_opponent} if $entry_side == 1;
					$other_swap = $entries{"scores"}{$entry_opponent}{$other} if $entry_side == 2;

					my $entry_swap;
					my $other_baseline;

					# If the swapee already has an opponent, test the converse too

					if ($other_opponent) { 
					
						my $other_side = $panels{$other}{"side"};

						$other_baseline = $entries{"scores"}{$other}{$other_opponent} if $other_side == 1;
						$other_baseline = $entries{"scores"}{$other_opponent}{$other} if $other_side == 2;

						$entry_swap = $entries{"scores"}{$entry}{$other_opponent} if $entry_side == 1;
						$entry_swap = $entries{"scores"}{$other_opponent}{$entry} if $entry_side == 2;

					} 

					my $swap_total = $entry_swap + $other_swap;
					my $baseline_total = $entry_baseline + $other_baseline;

					my $swap_diff = $baseline_total - $swap_total;

					# Only track swaps that improve scores because
					# there's no reason to keep going if we're only doing
					# zero-score swaps. 

					if ($swap_diff > $current_diff) { 
						$swap_counter++;
					}

					# If the swapped scores are equal better than the current
					# baseline, nominate the entry for a swap. 

					# The swapping if the scores are equal is order to set up
					# some random rematching for future swap attempts 

					if ($swap_diff >= $current_diff) { 
					
						$swap_candidate = $other; 
						$current_diff = $swap_diff;
					}

				}

				# An entry was found which improves the overall score, so swap
				# them. 

				if ($swap_candidate) { 
				
					my $swap_opponent = $panels{$swap_candidate}{"opponent"};
					my $swap_side = $panels{$swap_candidate}{"side"};
					my $swap_bracket = $panels{$swap_candidate}{"bracket"};
					my $entry_bracket = $panels{$entry}{"bracket"};

					if ($swap_opponent) { 

						$panels{$entry}{"opponent"} = $swap_opponent;
						$panels{$entry}{"bracket"} = $swap_bracket;
						$panels{$entry}{"side"} = $swap_side;
						$panels{$swap_opponent}{"opponent"}  = $entry;

					} else { 
						undef $panels{$entry}{"opponent"};
						undef $panels{$entry}{"bracket"};
						undef $panels{$entry}{"side"};
					}

					if ($entry_opponent) { 

						$panels{$swap_candidate}{"opponent"} = $entry_opponent;
						$panels{$swap_candidate}{"bracket"} = $entry_bracket;
						$panels{$swap_candidate}{"side"} = $entry_side;
						$panels{$entry_opponent}{"opponent"}  = $swap_candidate;

					} else { 

						undef $panels{$swap_candidate}{"opponent"};
						undef $panels{$swap_candidate}{"bracket"};
						undef $panels{$swap_candidate}{"side"};

					}

				}
			}

			last unless $swap_counter > 0;

		}
	}
	
	
	# Write out the resulting debates

	my %done; 

	# Oh the irony!
	my $letter = 1; 

	foreach my $entry (sort {$panels{$a}{"bracket"} <=> $panels{$b}{"bracket"} } keys %panels) { 

		next if $done{$entry}++;
		next if $done{$panels{$entry}{"opponent"}}++;

		my $side = $panels{$entry}{"side"};
		my $opp  = $panels{$entry}{"opponent"};

		if ($side == 1) { 

			my $score = $entries{"aff_scores"}{$opp}{$entry};
			$score += $entries{"neg_scores"}{$entry}{$opp};

			logMe($entries{"code"}{$opp}." aff vs ".$entries{"code"}{$entry}." on neg scores $score");


		} else { 

			my $score = $entries{"neg_scores"}{$opp}{$entry};
			$score += $entries{"aff_scores"}{$entry}{$opp};

			logMe($entries{"code"}{$entry}." aff vs ".$entries{"code"}{$opp}." on neg scores $score");

		}

		my $bye = 0;
		$bye = 1 if $opp eq "BYE";
		$side = 1 if $opp eq "BYE";

		my $panel = Tab::Panel->create({
			letter  => $letter,
			round   => $round->id,
			flight  => 1,
			bye     => $bye,
			bracket => $panels{$entry}{"bracket"}
		});

		$letter++;

		Tab::Ballot->create({
			panel        => $panel,
			entry        => $entry,
			side         => $side,
			judge        => 0,
			audit        => 0,
			speakerorder => 0
		});

		unless ($bye) { 

			$side--;
			$side = 2 if $side < 1;

			Tab::Ballot->create({
				panel        => $panel,
				entry        => $opp,
				side         => $side,
				judge        => 0,
				audit        => 0,
				speakerorder => 0
			});

		}

	}

	$round->setting("nsda_pairing_log", "text", $round_log);

	undef $round_log;
	undef $step_counter;

	return;

	sub scoreDebate { 

		my ($aff, $neg, $entries_ref) = @_;

		my $score;

		# Check for wrong bracket.  Pullups are forbidden unless strictly
		# necessary.

		if ($entries_ref->{$aff}{"losses"} != $entries_ref->{$neg}{"losses"}) { 

			$score += $entries_ref->{"scores"}{"bracket"};

		}

		# Check and penalize school hits

		if ($entries_ref->{"school_id"}{$aff} == $entries_ref->{"school_id"}{$neg}) { 

			$score += $entries_ref->{"scores"}{"school"};
		}

		$score +=  $entries_ref->{"scores"}{"repeat"} * $entries_ref->{$aff}{"hits"}{$neg};

		my $aff_side_diff = $entries_ref->{$aff}{"side_count"}{1} - $entries_ref->{$aff}{"side_count"}{2};
		my $neg_side_diff = $entries_ref->{$neg}{"side_count"}{2} - $entries_ref->{$neg}{"side_count"}{1};

		if ($aff_side_diff > 0) { 
			$score += $entries_ref->{"scores"}{"side"} * $aff_side_diff;
		}

		if ($neg_side_diff > 0) { 
			$score += $entries_ref->{"scores"}{"side"} * $neg_side_diff;
		}

		return $score;

	}

	sub logMe {

		my $string = shift;

		Tab::debuglog($string);

		$step_counter++;

		$round_log .= '<div class="full lightrow marleftmuchmore">';

		$round_log .= '<span class="quarter strong">';
		$round_log .= "Step ".$step_counter.". ";
		$round_log .= '</span> ';
		$round_log .= '<span class="threequarters">';
		$round_log .= $string;
		$round_log .= '</span> ';
		$round_log .= "</div>\n";

		return 
	}

</%init>
