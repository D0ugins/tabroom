<%args>
	$round
	$num_panels
	$no_rooms    => undef
	$entries_ref => undef
	$first       => undef
	$wipe        => undef
</%args>
<%perl>

	use POSIX;
	use List::Util 'shuffle';

	our %penalties = ( 
		school      => 1000000000000,
		district    => 1000000000,
		region      => 1000000,
		state       => 10000,
		bloc_school => 100,
		name        => 1
	);

	my $event = $round->event;
	my $tourn = $event->tourn;

	my %tourn_settings = $tourn->all_settings();

	if ($tourn_settings{"nsda_nats"}) { 

		%penalties = ( 
			district  => 10000000000,
			state     => 100000000,
			region    => 1000000,
			author    => 10000,
			auto_qual => 100,
			name      => 1,
			nsda_nats => 1
		);
	}

	my $use_seeds++ if $event->setting("seed_presets");

	Tab::Score->set_sql( delete_round => "
		delete score from score, ballot, panel
		where panel.round = ?
		and panel.id = ballot.panel
		and ballot.id = score.ballot
	");

	Tab::Ballot->set_sql( delete_round => "
		delete ballot from ballot, panel
		where panel.round = ?
		and panel.id = ballot.panel
	");

	Tab::Judge->set_sql( get_parli => "
		select judge.*
		from judge, panel, ballot
		where judge.id = ballot.judge
		and ballot.chair = 1
		and ballot.panel = ? 
		limit 1
	");

	Tab::Panel->set_sql( delete_round => "
		delete from panel where round = ?
	");

	if ($wipe) { 

		my @rounds = Tab::Round->search( 
			event => $round->event->id,
			type  => "prelim"
		);

		foreach my $round (@rounds) { 
			Tab::Score->sql_delete_round->execute($round->id);
			Tab::Ballot->sql_delete_round->execute($round->id);
			Tab::Panel->sql_delete_round->execute($round->id);
		}

	} elsif ($round->type eq "prelim") { 

		my @rounds = Tab::Round->search( 
			event => $round->event->id,
			type  => "prelim"
		);

		my $exists;

		foreach my $other (@rounds) { 

			next if $other->id == $round->id;

			my @entries = $m->comp(
				'/funclib/round_entries.mas', 
				round => $other
			);

			next unless @entries;

			Tab::Score->sql_delete_round->execute($round->id);

			Tab::Ballot->sql_delete_round->execute($round->id);

			Tab::Panel->sql_delete_round->execute($round->id);

			foreach my $panel ($other->panels) { 

				my $new_panel = $panel->copy({
					round  => $round->id
				});

				my $parli = Tab::Judge->search_get_parli($panel->id)->first;

				foreach my $entry (
					$m->comp("/funclib/panel_entries.mas", panel => $panel)
				) { 

					if ($parli) { 

						my $ballot = Tab::Ballot->create({
							panel => $new_panel->id,
							judge => $parli->id,
							entry => $entry->id,
							chair => 1
						})

					} else { 

						my $ballot = Tab::Ballot->create({
							panel => $new_panel->id,
							entry => $entry->id
						})

					}
				}

				$exists++;
			}
		}

		if ($exists) { 

			my $now = DateTime->now;
			$round->created($now);
			$round->update;

			return;
		}

	}

	my @all_entries;

	@all_entries = ${$entries_ref} if $entries_ref;

	@all_entries = $event->entries( active => 1 ) 
		unless @all_entries;

	$num_panels = 1 unless $num_panels;

	my %panel_cohorts = ();

	my $count;
	my $cohort = 1;

	my %size_of_school  = ();
	my %entries = ();

	my %settings = $m->comp(
		"/funclib/event_entry_settings.mas", 
		event   => $event,
		all     => 1,
		inverse => 1,
		value   => 1
	);


	my @schools;

	if ($tourn_settings{"ncfl"}) {

		$penalties{"region"} = $penalties{"school"};

		%{$entries{"school"}} = 
			map {$_->id => $_->school->region->id} 
			@all_entries;

		foreach my $entry (@all_entries) { 
			push @schools, $entries{"school"}{$entry->id};
			$size_of_school{$entries{"school"}{$entry->id}}++;
		}

	} else {

		%{$entries{"school"}} = map {$_->id => $_->school->id} @all_entries;

		if ($tourn_settings{"nsda_nats"}) { 

			$entries{"seed"} = $settings{"seed"};

			$entries{"auto_qual"} = $settings{"auto_qual"};

			my %authorship;
			my %district_region;

			if ($tourn_settings{'district_authorships'} ) { 
				eval { 
					%authorship = %{JSON::decode_json $tourn_settings{'district_authorships'}};
				};
			}

			if ($tourn_settings{'district_regions'} ) { 

				my %regions_by_id = map {$_->id => $_} $tourn->regions;

				eval { 
					%district_region = %{JSON::decode_json $tourn_settings{'district_regions'}};
				};

			}

			foreach my $entry (@all_entries) { 

				next unless $entry->school;

				next unless $entry->school->district;

				my $district = $entry->school->district;
				$entries{"district"}{$entry->id} = $district->id;

				if ($district_region{$district->id}) { 
					$entries{"region"}{$entry->id} = $district_region{$district->id};
				}

				if ($authorship{$district->id}) { 
					$entries{"author"}{$entry->id} = $authorship{$district->id};
				}

			}

		}

		%{$entries{"state"}}  = 
			map {$_->id => $_->school->chapter->state} 
			@all_entries;

		if ($event->setting("region_avoid")) { 

			eval { 
				%{$entries{"region"}}  = 
					map {$_->id => $_->school->region} 
					@all_entries;
			};

		}

		foreach my $entry (@all_entries) { 
			push @schools, $entries{"school"}{$entry->id};
			$size_of_school{$entries{"school"}{$entry->id}}++;
		}

	}

	if ($tourn_settings{"nsda_district"} && $event->name eq "HOU") { 

		my @house_settings = $m->comp(
			"/funclib/event_entry_settings.mas", 
			event => $event,
			tag   => "nsda_house_bloc"
		);

		%{$entries{"bloc"}}= 
			map {$_->entry->id => $_->value} 
			@house_settings;

	}

	my @entry_students = $m->comp(
		"/funclib/event_entry_students.mas",
		event => $event
	);

	%{$entries{"name"}}= map {$_->entry->id => $_->student->last} @entry_students;

	my $ranker = 1;

	my %school_rank = ();

	foreach (@schools) { 
		$school_rank{$_} = $ranker++;
	}

	if ($tourn_settings{"ncfl"}) {

		@all_entries = sort {$a->code <=> $b->code} @all_entries;

	} else {

		@all_entries = 
			shuffle(@all_entries);

		@all_entries = 
			sort {$school_rank{$a->school->id} <=> $school_rank{$b->school->id}} 
			@all_entries;

		@all_entries = 
			sort {$entries{"seed"}{$a} <=> $entries{"seed"}{$b}} 
			@all_entries if $use_seeds;

	} 

	#Set up the initial panels
	my $max_size = ceil(scalar @all_entries / $num_panels);

	my $min_size = floor(scalar @all_entries/ $num_panels);

	my $remainder = (scalar @all_entries - ($num_panels * $min_size));

	my %chambers = ();

    use List::Util 'shuffle';
    my @keys =  shuffle(1 .. $num_panels);

	my %school_count;

    foreach my $entry (@all_entries) {

        my $score = "3141592653";
        my $picked_key;

        KEY:
        foreach my $key (@keys) {

            next if $score == 0;

            my @chamber = @{$chambers{$key}} if $chambers{$key};
            next KEY if (scalar @chamber == $max_size);

            if (scalar @chamber == $min_size) {
                next KEY unless $remainder > 0;
            }

            if (@chamber) {

                push (@chamber, $entry->id);

                my $new_score = score_chamber(\@chamber, \%entries);

                if ($new_score < $score) {
                    $picked_key = $key;
                    $score = $new_score;
                    last KEY if $score == 0;
                }

            } else {

                $picked_key = $key;
                $score = 0;
                last KEY;
            }

        }

        $remainder-- 
			if $chambers{$picked_key} 
			&& scalar @{$chambers{$picked_key}} == $min_size;

        push (@{$chambers{$picked_key}}, $entry->id);

        my $k = shift @keys;
        push (@keys, $k);

    }


	my @chamber_keys = shuffle(keys %chambers);

	my $no_improvement = 1;

	unless ($num_panels == 1) { 

		foreach my $counter (1 .. 7) { 

			my $total;

			next if $no_improvement == 0;
			$no_improvement = 0;

			foreach my $chamber_key (@chamber_keys) { 
			
				my @section = @{$chambers{$chamber_key}};

				my $entry_section1_score = score_chamber(
					\@section, 
					\%entries
				);

				next if $entry_section1_score < 1;

				ENTRY:
				foreach my $entry_id (@section) { 
				
					next if $entry_section1_score < 1;

					# Remove the candidate for a test array of original section
					my @section1 = @section; 	
					my $index = 0;

					$index++ until $section1[$index] == $entry_id;
					splice(@section1, $index, 1);

					my $swap_section;
					my $swap_entry;
					my $current_diff;

					my @new_entry_section;
					my @new_swap_section;

					my $count;
		
					OTHERPANEL:
					foreach my $other_key (@chamber_keys) { 

						# Can't switch to the same section
						next if $other_key == $chamber_key; 				

						# Find the other section for scoring
						my @section2 = @{$chambers{$other_key}}; 			

						my $other_section2_score = score_chamber(
							\@section2, 
							\%entries
						);

						# Put me into this section for testing
						push (@section2, $entry_id);					

						OTHERENTRY:
						foreach my $other_entry_id (@{$chambers{$other_key}}) {
						
							# Add swap candidate to original section
							push (@section1, $other_entry_id);				

							$count++;

							my $other_section1_score = score_chamber(
								\@section1, 
								\%entries
							);

							# Remove swap candidate from the section
							my $index = 0;									

							$index++ until $section2[$index] == $other_entry_id;
							splice(@section2, $index, 1);

							my $entry_section2_score = score_chamber(
								\@section2, 
								\%entries
							);

							my $squo_score = $entry_section1_score + $other_section2_score;
							my $swap_score = $entry_section2_score + $other_section1_score;
							my $diff = $squo_score - $swap_score;

							my $replace = pop(@section1);  #remove me from this section
							push (@section2, $replace);    #put me back from whence I came

							if ( $diff > 0 && $diff > $current_diff) { 
								$current_diff = $diff;
								$swap_entry = $other_entry_id;
								$swap_section = $other_key;
							}

						}

					}

					if ($swap_entry) { 

						my @section2 = @{$chambers{$swap_section}};

						push (@section1, $swap_entry);

						my $swapdex = 0;
						$swapdex++ until $section2[$swapdex] == $swap_entry;
						splice(@section2, $swapdex, 1);

						push (@section2, $entry_id);

						$no_improvement++;  # Fail
						@{$chambers{$chamber_key}} = @section1;
						@{$chambers{$swap_section}} = @section2;

						@section = @section1;

						$entry_section1_score = score_chamber(
							\@section1, 
							\%entries
						);

						my $other_score = score_chamber(
							\@section2,
							\%entries
						);

					}
				}
			}

			last if $no_improvement < 1;

		}

	}

	# Now attempt to improve the seed distribution as long as the score of the
	# panels on states/schools stays the same.

	if ($use_seeds) { 

		foreach my $counter (1 .. 5) { 

			my %panel_seeds = ();
			
			foreach my $chamber_key (@chamber_keys) { 
				foreach my $entry_id (@{$chambers{$chamber_key}}) { 
					$panel_seeds{$chamber_key} += $entries{"seed"}{$entry_id};
				}
			}



			foreach my $chamber_key (@chamber_keys) { 

				my @chamber = @{$chambers{$chamber_key}};

				my $panel_score = score_chamber(\@chamber, \%entries);

				OTHER:
				foreach my $other_key (@chamber_keys) { 
				
					my @other = @{$chambers{$other_key}};
					my $other_score = score_chamber(\@other, \%entries);

					next if $other_key == $chamber_key;
					next if $panel_seeds{$other_key} == $panel_seeds{$chamber_key};

					my @can_flip_panel;
					my @can_flip_other;

					foreach my $entry (@chamber) { 
						push @other, $entry;
						my $new_other_score = score_chamber(\@other, \%entries);
						push @can_flip_panel, $entry if $new_other_score == $other_score;

						my $index = 0;
						$index++ until $other[$index] == $entry;
						splice(@other, $index, 1);
					}

					foreach my $entry (@other) { 
						push @chamber, $entry;
						my $new_panel_score = score_chamber(\@chamber, \%entries);
						push @can_flip_other, $entry if $new_panel_score == $panel_score;

						my $index = 0;
						$index++ until $chamber[$index] == $entry;
						splice(@chamber, $index, 1);
					}
					

					next unless @can_flip_panel;
					next unless @can_flip_other;

					my $flip_panel;
					my $flip_other;

					if ($panel_seeds{$other_key} > $panel_seeds{$chamber_key}) { 

						@can_flip_panel = 
							sort {$entries{"seed"}{$a} <=> $entries{"seed"}{$b}} 
							@can_flip_panel;

						@can_flip_other = 
							sort {$entries{"seed"}{$b} <=> $entries{"seed"}{$a}} 
							@can_flip_other;

						$flip_panel = shift @can_flip_panel;
						$flip_other = shift @can_flip_other;

						next OTHER unless $entries{"seed"}{$flip_panel} < $entries{"seed"}{$flip_other};

					} elsif ($panel_seeds{$other_key} < $panel_seeds{$chamber_key}) { 

						@can_flip_panel = 
							sort {$entries{"seed"}{$b} <=> $entries{"seed"}{$a}} 
							@can_flip_panel;

						@can_flip_other = 
							sort {$entries{"seed"}{$a} <=> $entries{"seed"}{$b}} 
							@can_flip_other;

						$flip_panel = shift @can_flip_panel;
						$flip_other = shift @can_flip_other;

						next OTHER unless $entries{"seed"}{$flip_panel} > $entries{"seed"}{$flip_other};

					}

					if ($flip_panel && $flip_other) { 

						my $index = 0;
						$index++ until $chamber[$index] == $flip_panel;
						splice(@chamber, $index, 1);

						$index = 0;
						$index++ until $other[$index] == $flip_other;
						splice(@other, $index, 1);

						push @chamber, $flip_other;
						push @other, $flip_panel;

						$panel_seeds{$other_key} -= $entries{"seed"}{$flip_other};
						$panel_seeds{$chamber_key} -= $entries{"seed"}{$flip_panel};

						$panel_seeds{$other_key} += $entries{"seed"}{$flip_panel};
						$panel_seeds{$chamber_key} += $entries{"seed"}{$flip_other};

						my $panel_score = score_chamber(\@chamber, \%entries);
					
						@{$chambers{$other_key}} = @other;
						@{$chambers{$chamber_key}} = @chamber;

					}

				}

			}

		}

	}

	my @judges = $m->comp("/funclib/round_judges.mas", round => $round) 
		unless $m->comp("/funclib/round_entries.mas", round => $round);

	my @judge_keys;

	my %judge_panel = ();
	foreach my $judge (@judges) { 
		push (@{$judge_panel{$judge->panelid}}, $judge->id);
		push (@judge_keys, $judge->panelid);
	}

	my %jseen = (); 
	@judge_keys = grep { ! $jseen{$_} ++ } @judge_keys;

	my @rooms = $m->comp(
		"/funclib/round_rooms.mas", 
		round => $round
	);

	# Clear out the old

	Tab::Score->sql_delete_round->execute($round->id);

	Tab::Ballot->sql_delete_round->execute($round->id);

	Tab::Panel->sql_delete_round->execute($round->id);

	my $letter = 1;

	$letter = "A" if $event->setting("panel_lables") eq "letters";

	foreach my $chamber_key (@chamber_keys) { 

		my $room = shift @rooms if @rooms;
		my $room_id = 0;

		$room_id = $room->id if $room;

		my $jpanel = shift @judge_keys if @judge_keys;
		my @judge_ids = @{$judge_panel{$jpanel}} if $jpanel;
		@judge_ids = ("0") unless @judge_ids;

		my @entries = @{$chambers{$chamber_key}};
						
		my $panel_score = score_chamber(\@entries, \%entries);

		my $panel = Tab::Panel->create({
			round  => $round->id,
			room   => $room_id,
			flight => 1,
			letter => $letter,
			score  => $panel_score
		});

		if ($letter eq "Z") { 
			$letter = "AA";
		} else { 
			$letter++;
		}

		foreach my $judge_id (@judge_ids) { 

			my $position;

			foreach my $entry (@entries) { 

				$position++;

				next unless $entry;
				my $ballot = Tab::Ballot->create({
					panel => $panel->id,
					judge => $judge_id,
					entry => $entry
				})

			}
		
		}

	}

	my $now = DateTime->now;
	$round->created($now);
	$round->update;

	undef %penalties;

	return;

    sub score_chamber {

        my ($panref, $entries) = @_;

        my @pan_entries = @$panref;

        my $score = 0;

        foreach my $entry (@pan_entries) { 

            foreach my $other (@pan_entries) { 

                next unless $other > $entry;

                if (${$entries}{"school"}{$other} eq ${$entries}{"school"}{$entry}) { 

                	if (
						${$entries}{"bloc"}{$other} 
						&& ${$entries}{"bloc"}{$other} eq ${$entries}{"bloc"}{$entry}
					) { 

                    	$score -= $penalties{"bloc_school"}; 

					} else { 

                    	$score += $penalties{"school"};

					}
                }


               	if (${$entries}{"name"}{$other} eq ${$entries}{"name"}{$entry}) { 
                   	$score += $penalties{"name"};
				}

				foreach my $constraint ("region", "district", "state") { 

					if ( 
							(
								${$entries}{"school"}{$other} ne ${$entries}{"school"}{$entry}
								|| $penalties{"nsda_nats"}
							) 
						&& ${$entries}{$constraint}{$entry}
						&& ${$entries}{$constraint}{$other} eq ${$entries}{$constraint}{$entry}
					) { 

						$score += $penalties{$constraint};

					}
				}

				foreach my $constraint ("auto_qual", "author") { 

					if ( ${$entries}{$constraint}{$entry} 
						&& ${$entries}{$constraint}{$other} 
					) {
						$score += $penalties{$constraint};
					}

				}

            }

        }

        return $score;

    }
	
</%perl>
