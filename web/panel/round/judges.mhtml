<%args>
	$tourn
	$tourn_settings
	$person
	$round_id => undef
	$round    => undef
	$parlis   => undef
	$return   => undef
</%args>
<%init>

	use List::Util qw(shuffle);

	my $now = DateTime->now();

	unless ($round) {
		$round = Tab::Round->retrieve($round_id);
	}

	my $dbh = Tab::DBI->db_Main();

	unless ($round) {
		$m->comp( "/funclib/abort.mas", err => "No round found for ID ".$round->id);
	}

	my $event = $round->event;
	my $event_id = $event->id;
	my $category = $event->category;

	my %round_settings = $round->all_settings;
	my %event_settings = $event->all_settings();

	my %category_settings = $category->all_settings();

	my @panels = sort {$a->letter <=> $b->letter} $round->panels;
	@panels = sort {$b->bracket <=> $a->bracket} @panels;

	my $num_judges = $round_settings{"num_judges"};
	$num_judges = 1 unless $num_judges;
	$num_judges = 1 if $parlis == 1;

	my $num_flights = $round->flighted;
	$num_flights = 1 unless $num_flights;
	$num_flights = 1 if $event_settings{"flight_rooms_only"};

	$m->comp(
		"/funclib/round_clear_judges.mas",
		round        => $round,
		erase_chairs => $parlis,
	);

	my %panels_by_letter = ();
	my $last_round;

	if ( $parlis == 1 ) {

		foreach my $oround ($event->rounds(type => $round->type)) {

			my $didit;

			foreach my $panel ($oround->panels) {
				push @{$panels_by_letter{$panel->letter}}, $panel;
				$didit++;
			}

			if ($didit) {
				$m->comp(
					"/funclib/round_clear_judges.mas",
					round        => $oround,
					erase_chairs => $parlis,
				);
			}

			$last_round = $oround unless $last_round;
			$last_round = $oround if $oround->name > $last_round->name;
		}
	}

	my $description = "Reassigned the judges in round ".$round->realname." of ".$event->abbr." using judges.mhtml";

	Tab::ChangeLog->create({
		type        => 'tabbing',
		event       => $event_id,
		tourn       => $event->tourn->id,
		person      => $person,
		created     => $now,
		description => $description
	});

	my %judge_settings = $m->comp(
		"/funclib/category_judge_settings.mas",
		category => $category,
		value    => 1,
		all      => 1
	);

	if ($event->type eq "wudc") {

		my %panel_judges;
		my %panel_already_judges;
		my %used_judges;

		foreach my $panel (@panels) {

			next if $panel->bye;

			%{$panel_judges{$panel->id}} = $m->comp(
				"/funclib/clean_judges.mas",
					panel             => $panel,
					wudc              => "true",
					autopanel         => 1,
					event_settings    => \%event_settings,
					category_settings => \%category_settings,
			);

			@{$panel_already_judges{$panel->id}} = $m->comp(
				"/funclib/panel_judges.mas",
				panel => $panel
			);
		}

		my $order_string = $round_settings{"tab_rating_priority"};

		my @orders = split(/\,/, $order_string);

		if (@orders) {

			my %used_schools;
			my %used_regions;

			foreach my $order (@orders) {

				foreach my $panel (@panels) {

					next if $panel->bye;
					next unless $panel->bracket == $order;
					my @cans = keys %{$panel_judges{$panel->id}};

					my $judge;
					my $empty;

					while (@cans
						&& not defined $judge
						&& not defined $empty
					) {

						$empty++ if scalar @cans == 0;
						$judge = shift @cans;
						$empty++ unless $judge;
						next unless $judge;

						undef $judge if $used_judges{$judge};

						unless ($category_settings{"allow_school_panels"}) {
							undef $judge
								if $judge
								&& $panel_judges{$panel->id}{$judge}{"school"}
								&& $used_schools{$panel->id}{$panel_judges{$panel->id}{$judge}{"school"}};
						}

						if ($event_settings{"region_judge_forbid"}) {
							undef $judge
								if $judge
								&& $panel_judges{$panel->id}{$judge}{"region"}
								&& $used_regions{$panel->id}{$panel_judges{$panel->id}{$judge}{"region"}};
						}
					}

					$m->comp("/funclib/panel_judgeadd.mas",
						panel => $panel,
						judge_id => $judge
					) if $judge;

					$used_judges{$judge}++
						if $judge;

					$used_schools{$panel->id}{$panel_judges{$panel->id}{$judge}{"school"}}++
						if $judge && $panel_judges{$panel->id}{$judge}{"school"};

					if ($event_settings{"region_judge_forbid"}) {
						$used_regions{$panel->id}{$panel_judges{$panel->id}{$judge}{"region"}}++
							if $judge && $panel_judges{$panel->id}{$judge}{"region"};
					}

				}

				@panels = reverse(@panels);
			}

		} else {

			$num_judges = 3 unless $num_judges;
			my %used_schools;
			my %used_regions;

			foreach (1 .. $num_judges ) {

				foreach my $panel (@panels) {

					next if $panel->bye;

					my @cans = keys %{$panel_judges{$panel->id}};

					my $judge;
					my $empty;

					while (@cans
						&& not defined $judge
						&& not defined $empty
					) {

						$empty++ if scalar @cans == 0;

						$judge = shift @cans;
						$empty++ unless $judge;
						next unless $judge;

						undef $judge if $used_judges{$judge};

						unless ($category_settings{"allow_school_panels"}) {
							undef $judge
								if $judge
								&& $panel_judges{$panel->id}{$judge}{"school"}
								&& $used_schools{$panel->id}{$panel_judges{$panel->id}{$judge}{"school"}};
						}

						if ($event_settings{"region_judge_forbid"} ) {
							unless ($category_settings{"allow_region_panels"}) {
								undef $judge
									if $judge
									&& $panel_judges{$panel->id}{$judge}{"region"}
									&& $used_regions{$panel->id}{$panel_judges{$panel->id}{$judge}{"region"}};
							}
						}
					}

					$m->comp("/funclib/panel_judgeadd.mas",
						panel    => $panel,
						judge_id => $judge
					) if $judge;

					$used_judges{$judge}++
						if $judge;

					$used_schools{$panel->id}{$panel_judges{$panel->id}{$judge}{"school"}}++
						if $judge && $panel_judges{$panel->id}{$judge}{"school"};

					if ($event_settings{"region_judge_forbid"} ) {
						$used_regions{$panel->id}{$panel_judges{$panel->id}{$judge}{"region"}}++
							if $judge && $panel_judges{$panel->id}{$judge}{"region"};
					}
				}
				@panels = reverse(@panels);
			}
		}

	} else {

		my %rating_by_judge = ();

		if ($category_settings{"coach_ratings"}
			&& (
				(not defined $category_settings{"elim_only_ratings"})
				|| ($round->type ne "prelim")
			)
		) {

			my $rating_sth = $dbh->prepare("
				select judge.id, rating_tier.name, subrt.name

				from (judge, round, event, rating_tier, rating)

				left join rating_subset on rating_subset.id = event.rating_subset
				left join rating subrating on subrating.rating_subset = rating_subset.id
					and subrating.judge = judge.id
					and subrating.type = 'coach'

				left join rating_tier subrt on subrt.id = subrating.rating_tier

				where round.id = ?
				and round.event = event.id
				and judge.id = rating.judge
				and rating.rating_tier = rating_tier.id
				and rating.type = 'coach'

				and (
					judge.category = event.category
					or judge.alt_category = event.category
					or exists (
						select jpj.id
						from jpool_judge jpj, jpool_round jpr
						where jpj.judge = judge.id
						and jpj.jpool = jpr.jpool
						and jpr.round = round.id
					)
				)
			");

			$rating_sth->execute($round->id);

			while (
				my ( $judge_id, $rating_tier, $better_rating_tier) = $rating_sth->fetchrow_array()
			) {
				$rating_by_judge{$judge_id} = $rating_tier;
				$rating_by_judge{$judge_id} = $better_rating_tier if $better_rating_tier;
			}
		}

		my $judge_use = $m->comp("/funclib/judge_use.mas", round => $round);

		my %panel_judges = ();

		foreach my $panel (@panels) {

			next if $panel->bye;

			%{$panel_judges{$panel->id}} = $m->comp(
				"/funclib/clean_judges.mas",
					panel             => $panel,
					event_settings    => \%event_settings,
					category_settings => \%category_settings,
					autopanel         => 1,
					parlis            => $parlis
			);

		}

		my %done = ();
		my %all_judged = ();

		foreach my $panel (@panels) {

			next if $done{"P-".$panel->id};

			my @flights;
			push @flights, $panel;

			my %flighted;
			$flighted{$panel->id}++;

			my @judges =
				sort {
					$judge_use->{$a}{"everything"} <=> $judge_use->{$b}{"everything"}
				} shuffle(keys %{$panel_judges{$panel->id}})
			if $panel_judges{$panel->id};

			unless ($category_settings{"elim_only_ratings"} && $round->type eq "prelim") {
				@judges = sort {
					length($rating_by_judge{$a}) cmp length($rating_by_judge{$b})
					|| $rating_by_judge{$a} cmp $rating_by_judge{$b}
				} @judges;
			}

			FLIGHT:
			foreach my $flight_number (2 .. $num_flights) {

				OTHER:
				foreach my $other (@panels) {

					next if $done{"P-".$other->id};
					next if $flighted{$other->id};

					my %flight_judges = map {$_ => 1} keys %{$panel_judges{$other->id}};
					my @clear;

					foreach my $judge (@judges) {
						next unless $flight_judges{$judge};
						next if $done{"J-".$judge};
						push @clear, $judge;
					}

					next OTHER unless scalar @clear > $num_judges;

					push @flights, $other;
					@judges = @clear;
					$flighted{$other->id}++;
					next FLIGHT;
				}
			}

			my %already = ();
			my @judge_panel;

			# This sorts the parlis to the bottom; the steps that require them
			# will go and get them, but then scorers will be drawn first from
			# non-parlis so as not to absorb them all where not needed.

			foreach my $judge (@judges) {

				next if $done{"J-".$judge};

				next if
					(not defined $category_settings{"allow_school_panels"})
					&& (
						$panel_judges{$panel->id}{$judge}{"school"} > 0
						&& $panel_judges{$panel->id}{$judge}{"school"}
						&& $already{"school"}{$panel_judges{$panel->id}{$judge}{"school"}}
					);

				next if ($tourn_settings->{"ncfl"} || $event_settings{"region_judge_forbid"} )
					&& $panel_judges{$panel->id}{$judge}{"school"}
					&& $panel_judges{$panel->id}{$judge}{"region"}
					&& $already{"region"}{$panel_judges{$panel->id}{$judge}{"region"}};

				if ($parlis == 1) {
					next if (not defined $judge_settings{$judge}{"parli"});
					$done{$panel->id}{"parli"}++;
				} elsif ($parlis == 3) {
					next if (not defined $done{$panel->id}{"parli"});
				}

				if ($panel_judges{$panel->id}{$judge}{"school"}) {
					$already{"school"}{$panel_judges{$panel->id}{$judge}{"school"}}++;
				}

				if ( ($tourn_settings->{"ncfl"} || $event_settings{"region_judge_forbid"} )
					&& $panel_judges{$panel->id}{$judge}{"school"}
					&& $panel_judges{$panel->id}{$judge}{"region"}
				) {
					$already{"region"}{$panel_judges{$panel->id}{$judge}{"region"}}++;
				}

				push @judge_panel, $judge;
				last if scalar @judge_panel >= $num_judges;
			}

			my $flight_number = 1;

			foreach my $chamber (@flights) {

				$chamber->flight($flight_number);
				$chamber->update();
				$flight_number++;

				$done{"flight"}{$chamber->id}++;

				foreach my $judge (@judge_panel) {

					my $chair;

					if ($parlis == 1) {
						$chair++;
					}

					if ($parlis == 3) {
						$chair++
							if $judge_settings{$judge}{"parli"}
							&& (not defined $done{$panel->id}{"parli_done"});
					}

					$done{$panel->id}{"parli_done"}++;

					if ($parlis && $chair) {

						foreach my $ochamber (@{$panels_by_letter{$chamber->letter}}) {

							my $audited++ if $ochamber->round->id != $last_round->id;

							$m->comp(
								"/funclib/panel_judgeadd.mas",
								panel    => $ochamber,
								judge_id => $judge,
								chair    => $chair,
								done     => $audited
							) if $judge;
						}

					} else {

						$m->comp(
							"/funclib/panel_judgeadd.mas",
							panel    => $chamber,
							judge_id => $judge,
							chair    => $chair
						) if $judge;

					}

					$done{"J-".$judge}++;
				}

				$done{"P-".$chamber->id}++;
			}
		}
	}

	my $msg = "Judges have been assigned";
	$msg = "Parliamentarians have been assigned in all rounds" if $parlis == 1;

	return $msg if $return;

	$m->redirect("/panel/schemat/show.mhtml?round_id=".$round->id."&disp=1&msg=$msg");

</%init>
