<%args>
	$tourn_id
	$person_id
	$session_id
	$restore_mode						#valid values are school_reg, round, event. tourn is handled with foreign upload.
	$event_id => undef
	$round_id => undef
	$round_data_only => undef			#checked = only update round results, not ROUND or ROUND_SETTING tables
	$foreign_round_data => undef
	$school_id => undef
	$user_provided_school_id => undef
	$user_provided_event_id => undef
</%args>

<%init>

$school_id = $user_provided_school_id if $user_provided_school_id;
$event_id = $user_provided_event_id if $user_provided_event_id;
$round_data_only = 'on' if $foreign_round_data;

## add errors here -- bounce if not values for both round_id & round_import_id
print "event_id=$event_id<br>";
print "restore_mode=$restore_mode<br>";

########################################################################################
#		read local JSON file into a hash that goes { table }{ record }{ field }
#		HERE'S THE DEAL: When it's downloaded, each record is listed by the original tabroom ID, and
#		every record ALSO has a redundant sub-field that stores the same information.
#		So I'm gonna write one chunk of code to sync up the tabroom ID numbers in the
#		redundant field, and then a second chunk of code to write that back to the database
#########################################################################################

		#### STEP ONE: Load in the file
		#### This finds the file 

use strict;
use warnings;
use Data::Dumper; 
binmode STDOUT, ":utf8";
use utf8;
use DateTime;
use Time::HiRes qw( time );
my $start = time(); 

my $tourn = Tab::Tourn->retrieve($tourn_id);
my $person = Tab::Person->retrieve($person_id);
my $session = Tab::Session->retrieve($session_id);

my $tz = $tourn->tz if $tourn->tz;
$tz = "UTC" unless $tz;
	
my $dbh = Tab::DBI->db_Main();
use JSON;
use Encode qw(encode_utf8);

#upload sequence
my $now = DateTime->now;
$now->set_time_zone($tz);
my $req = Apache2::Request->new($r, DISABLE_UPLOADS => 0);
my $json_file = $req->upload('json_data');
unless ($json_file) { print $r." Couldn't find file<br>"; $m->abort };
my $json_filename = $json_file->tempname;
my $filename = $json_filename;

		#### This reads the file and converts the JSON to a hash called %data ###
		
my $json;
#my $filename = '/www/tabroom/web/register/data/NSDA.json';

{
  local $/; #Enable 'slurp' mode
  open my $fh, "<", $filename;
  $json = <$fh>;
  close $fh;
}

my $HashReferenceDecoded = decode_json($json);
my %data = %$HashReferenceDecoded;

print "Time to load JSON file into a hash:"; printf("%.2f\n", time() - $start) ; print "<br>";

#set up some global utility variables
my $sql;
my $ctr = 0;

		### erase SCORE field from panel and judge in the $data hash -- they are just temporary things and don't need to be restored
		### This is just random cleanup

foreach my $rec (sort keys %{ $data{'judge'} } ) {
	delete $data{'judge'}{$rec}{'score'};
}
foreach my $rec (sort keys %{ $data{'panel'} } ) {
	delete $data{'panel'}{$rec}{'score'};
}

		#### STEP TWO: Delete things you don't want from the hash and delete whatever you'll update in the database.
		### For each restore mode, clean everything out of the database that is currenlty associated with whatever you are restoring
		### and remove from the hash everything in an non-permanent table that you don't want restored.  You only need to do this for the highest-level
		### field, so for ENTRY just delete ENTRY and the next routine will delete everything that points to ENTRY, such as the ENTRY_STUDENT, etc.

if ( $restore_mode eq 'event' ) {
	#Need to update event, event_setting, entry, entry_setting, entry_settingt, round, round_setting, panel, ballot, score

	my $sth = $dbh->prepare( "DELETE rating.* from rating, entry where rating.entry=entry.id and entry.event=".$event_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE strike.* from strike, entry where strike.entry=entry.id and entry.event=".$event_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE result_value.* from result_value, result, entry where result_value.result=result.id and result.entry=entry.id and entry.event=".$event_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE result.* from result, entry where result.entry=entry.id and entry.event=".$event_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE panel.* from panel, round where panel.round=round.id and round.event=".$event_id );
	$sth->execute();
	
	$m->comp("/setup/events/event_rm.mhtml", event_id => $event_id, fire_as_function => 42, tourn => $tourn, person => $person);
	foreach my $rec (sort keys %{ $data{'event'} } ) {
		unless ($rec == $event_id) {
			delete $data{'event'}{$rec};
			print "deleting event $rec<br>";
		}
	}
	#get rid of ratings not linked to an entry in an event
	foreach my $rec (sort keys %{ $data{'rating'} } ) {
		unless ( $data{'rating'}{$rec}{'entry'} && $data{'entry'}{ $data{'rating'}{$rec}{'entry'} }{'event'} == $event_id ) {
			delete $data{'rating'}{$rec};
		}
	}
	#get rid of strikes not linked to an entry in an event
	foreach my $rec (sort keys %{ $data{'strike'} } ) {
		unless ( $data{'strike'}{$rec}{'entry'} && $data{'entry'}{ $data{'strike'}{$rec}{'entry'} }{'event'} == $event_id ) {
			delete $data{'strike'}{$rec};
		}
	}
	#get rid of results not linked to an entry in an event; cascading delet will also get rid of the result_values
	foreach my $rec (sort keys %{ $data{'result'} } ) {
		unless ( $data{'result'}{$rec}{'entry'} && $data{'entry'}{ $data{'result'}{$rec}{'entry'} }{'event'} == $event_id ) {
			delete $data{'result'}{$rec};
		}
	}
}

if ( $restore_mode eq 'round' ) {
	#Need to update score, ballot, panel, round, round_setting, result, result_value

	my $sth = $dbh->prepare( "DELETE score.* from score, ballot, panel where score.ballot=ballot.id and ballot.panel=panel.id and panel.round=".$round_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE ballot.* from ballot, panel where ballot.panel=panel.id and panel.round=".$round_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE panel.* from panel where panel.round=".$round_id );
	$sth->execute();
	if ($round_data_only eq 'on' ) {
		delete $data{'result'};
		delete $data{'result_value'};
		delete $data{'round_setting'};
	}
	unless ($round_data_only eq 'on' ) {
		$sth = $dbh->prepare( "DELETE result_value.* from result_value, result where result_value.result=result.id and result.round=".$round_id );
		$sth->execute();
		$sth = $dbh->prepare( "DELETE result.* from result where result.round=".$round_id );
		$sth->execute();
		$sth = $dbh->prepare( "DELETE from round_setting where round=".$round_id );
		$sth->execute();
		$sth = $dbh->prepare( "DELETE from round where id=".$round_id );
		$sth->execute();
	}
	#get rid of all other rounds; cascading delete will also erase score, ballot, and panels, and round_settings
	foreach my $rec (sort keys %{ $data{'round'} } ) {
		delete $data{'round'}{$rec} unless $rec == $round_id;
	}
	#get all other results out of the hash; cascading delete will get rid of the result_values
	foreach my $rec (sort keys %{ $data{'result'} } ) {
		delete $data{'result'}{$rec} unless $data{'result'}{$rec}{'round'} == $round_id;
	}	
}

if ( $restore_mode eq 'school_reg' ) {

	my $sth = $dbh->prepare( "DELETE from strike where strike.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE strike.* from strike, entry where strike.entry=entry.id and entry.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE strike.* from strike, judge where strike.judge=judge.id and judge.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE room_strike.* from room_strike, entry where room_strike.entry=entry.id and entry.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE room_strike.* from room_strike, judge where room_strike.judge=judge.id and judge.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE from rating where rating.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE rating.* from rating, entry where rating.entry=entry.id and entry.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE rating.* from rating, judge where rating.judge=judge.id and judge.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE from judge_hire where judge_hire.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE judge_hire.* from judge_hire, judge where judge_hire.judge=judge.id and judge.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE judge_setting.* from judge_setting, judge where judge_setting.judge=judge.id and judge.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE entry_setting.* from entry_setting, entry where entry_setting.entry=entry.id and entry.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE entry_student.* from entry_student, entry where entry_student.entry=entry.id and entry.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE from judge where judge.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE from entry where entry.school=".$school_id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE from school where id=".$school_id );
	$sth->execute();

	#$m->comp("/register/school/drop.mhtml", school_id => $school_id, fire_as_function => 42, tourn => $tourn, person => $person, certain => "I am certain");
	foreach my $rec (sort keys %{ $data{'school'} } ) {
		delete $data{'school'}{$rec} unless $rec == $school_id;
	}	
	#clean out unaffiliated judges -- cascading deletion won't catch for judges with school=0
	foreach my $rec (sort keys %{ $data{'judge'} } ) {
		delete $data{'judge'}{$rec} unless ( $data{'judge'}{$rec}{'school'} == $school_id || $data{'judge'}{$rec}{'protected'} );
	}	

}

#now delete all the tables you don't want to mess with; this will still include the permanent tables
foreach my $table (sort keys %data) {
	if ( use_table($table, $restore_mode) ne 'use_me') {
		delete $data{$table};
	}
}

# print Dumper(%data);

print "Time to complete deletion:"; printf("%.2f\n", time() - $start) ; print "<br>";

		#### STEP THREE: Cascading deletions in the hash to get rid of the schools, events and rounds that you don't want to mess with
		### so if you delete a school delete everything that points to the school you deleted
		### This algorithm works except for the exceptions below (note score points to the tiebreak->priority field and calls it 'tiebreak')
		
my $all_ok;
my $trials = 0;
my $delete_exception;

do {
	
	$all_ok = 1;
	$trials++;
	foreach my $table (sort keys %data) {
		foreach my $table2 (sort keys %data) {
			foreach my $rec2 (sort keys %{ $data{$table2} } ) {
				$delete_exception=0;
				if ($table eq 'score' && $table2 eq 'tiebreak') { $delete_exception=1; }
				if ($restore_mode eq 'school_reg' && $table2 eq 'judge_hire' && $data{'judge_hire'}{$rec2}{'school'} == $school_id ) { $delete_exception=1; }
				if ( $data{$table2}{$rec2}{$table} && $delete_exception == 0 ) { 											#so this will only process the record if the field has a value
					unless ( $data{$table}{ $data{$table2}{$rec2}{$table} } ) { 											#and this will process the deletion if the field has been deleted
						#print "deleted record $rec2 from $table2 it used $table ".$data{$table2}{$rec2}{$table}." delete exception = $delete_exception<br>";
						delete $data{$table2}{$rec2};
						$all_ok = 0;
					}
				}
			}
		}	
	}
	
} until ( $all_ok == 1 || $trials > 10 );

print "Time to delete associated records from hash from the hash:"; printf("%.2f\n", time() - $start) ; print "<br>";

# print Dumper(%data);

		#### STEP FOUR: Dump what's left into the database

#ugly place to put it, but it must come AFTER the cascading deletion
if ($round_data_only eq 'on' ) {
	delete $data{'round'};
}
#Same deal with judges and their settings -- you saved the hired judges, so now you gotta delete them before the writing
foreach my $rec (sort keys %{ $data{'judge_setting'} } ) {
	delete $data{'judge_setting'}{$rec} unless $data{'judge'}{ $data{'judge_setting'}{$rec}{'judge'} }{'school'} == $school_id;
}	
foreach my $rec (sort keys %{ $data{'judge'} } ) {
	delete $data{'judge'}{$rec} unless $data{'judge'}{$rec}{'school'} == $school_id;
}	

my $field_name;
my $field_str;

unless ($foreign_round_data eq 'on' ) {

	foreach my $table (sort keys %data) {
	print "Now updating $table...<br>";
		foreach my $rec (sort keys %{ $data{$table} }) {
			$ctr=0;
			my @field_values;
		
			foreach my $field (sort keys %{ $data{$table}{$rec} }) {
				
				if ( $ctr == 0 ) {
					$field_name = $field ;
					$field_str = "?" ;
				} else {
					$field_name = $field_name.", ".$field;
					$field_str = $field_str.", ?" ;
				}
				$field_values[$ctr] = $data{$table}{$rec}{$field};
				$field_values[$ctr] = $tourn_id if $field eq 'tourn' ;
				$ctr++;
		
			}
			
			$sql = 'INSERT INTO '.$table.' ('.$field_name.') VALUES ('.$field_str.')' ;
			my $sth = $dbh->prepare( $sql );
			$sth->execute(@field_values);
		}
	}

}

if ($foreign_round_data eq 'on' ) {
	my $table;
	for (my $i=0; $i <= 3; $i++) {
		if ( $i == 1 ) { $table="panel"; }
		if ( $i == 2 ) { $table="ballot"; }
		if ( $i == 3 ) { $table="score"; }
		
		foreach my $rec (sort keys %{ $data{$table} }) {
			$ctr=0;
			my @field_values;
		
			foreach my $field (sort keys %{ $data{$table}{$rec} }) {
				if ($field ne 'id') {				
					if ( $ctr == 0 ) {
						$field_name = $field ;
						$field_str = "?" ;
					} else {
						$field_name = $field_name.", ".$field;
						$field_str = $field_str.", ?" ;
					}
					$field_values[$ctr] = $data{$table}{$rec}{$field};
					$field_values[$ctr] = $data{'panel'}{ $data{$table}{$rec}{$field} }{'id'} if $field eq 'panel';
					$field_values[$ctr] = $data{'ballot'}{ $data{$table}{$rec}{$field} }{'id'} if $field eq 'ballot';
					$ctr++;
				}
			}
			$sql = 'INSERT INTO '.$table.' ('.$field_name.') VALUES ('.$field_str.')' ;
			my $sth = $dbh->prepare( $sql );
			$sth->execute(@field_values);
			$data{$table}{$rec}{'id'} = $dbh->{'mysql_insertid'};
		}
	}
}

print "Time to create records:"; printf("%.2f\n", time() - $start) ; print "<br>";

#} # end of test

print "And now we're done!";

$m->redirect("/setup/tourn/main.mhtml?msg=Data restored");
		
sub use_table{

	my $table = shift @_;
	my $restore_mode = shift;

	#### Totally NOT the tightest way to code but way easier to read

	if ( $restore_mode eq 'event' ) {
		if ($table eq 'event' || $table eq 'event_setting' || $table eq 'entry' || $table eq 'entry_setting' ) { return "use_me"; }
		if ($table eq 'entry_student' || $table eq 'rating' || $table eq 'panel' || $table eq 'room_strike' ) { return "use_me"; }
		if ($table eq 'round' || $table eq 'round_setting' || $table eq 'score' || $table eq 'ballot' ) { return "use_me"; }
		if ($table eq 'strike' || $table eq 'sweep_event' || $table eq 'result' || $table eq 'result_value' ) { return "use_me"; }
	}

	#update school, entry, entry_setting, entry_student, judge, judge_setting, judge_hire, rating, room_strike, strike
	if ( $restore_mode eq 'school_reg' ) {
		if ($table eq 'school' || $table eq 'entry' || $table eq 'entry_setting' || $table eq 'entry_student' ) { return "use_me"; }
		if ($table eq 'judge' || $table eq 'judge_setting' || $table eq 'judge_hire' || $table eq 'rating') { return "use_me"; }
		if ($table eq 'room_strike' || $table eq 'strike') { return "use_me"; }		
	}

	if ( $restore_mode eq 'round' ) {
		if ( $table eq 'panel' || $table eq 'round' || $table eq 'round_setting' || $table eq 'score' ) { return "use_me"; }
		if ($table eq 'ballot' || $table eq 'result' || $table eq 'result_value' ) { return "use_me"; }
	}
	
	return "nope";
}

</%init>