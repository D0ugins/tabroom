<%args>
	$tourn_id
	$person_id
	$session_id
	$restore_mode						#valid values are school_reg, round, event, tourn
	$event_id         => undef
	$event_id_restore => undef			#This is the event ID from the restore file
	$round_id         => undef
	$round_id_import  => undef			#ID for the round in the import file
	$round_data_only  => undef			#checked = only update round results, not ROUND or ROUND_SETTING tables
	$school_id        => undef
</%args>

<%init>

## add errors here -- bounce if not values for both round_id & round_import_id

########################################################################################
#		read local JSON file into a hash that goes { table }{ record }{ field }
#		HERE'S THE DEAL: When it's downloaded, each record is listed by the original tabroom ID, and
#		every record ALSO has a redundant sub-field that stores the same information.
#		So I'm gonna write one chunk of code to sync up the tabroom ID numbers in the
#		redundant field, and then a second chunk of code to write that back to the database
#########################################################################################

	#### STEP ONE: Load in the file
	#### This finds the file 

	use strict;
	use warnings;
	use Data::Dumper; 
	use JSON;
	use Encode qw(encode_utf8);
	use utf8;
	use DateTime;
	use Time::HiRes qw( time );

	binmode STDOUT, ":utf8";
	my $start = time(); 

	#Guard against injection
	$tourn_id = int($tourn_id);

	my ($person, $tourn, $session) = $m->comp("login_api.mas", 
		tourn_id   => $tourn_id,
		username   => $username,
		password   => $password,
		session_id => $session_id
	); 

	#Guard against injection
	$tourn_id = $tourn->id;

	my $tz = $tourn->tz if $tourn->tz;
	$tz = "UTC" unless $tz;
	
	my $dbh = Tab::DBI->db_Main();

	#upload sequence
	my $now = DateTime->now(time_zone => $tz);
	my $req = Apache2::Request->new($r, DISABLE_UPLOADS => 0);
	my $json_file = $req->upload('json_data');

	unless ($json_file) { print $r." Couldn't find file<br>"; $m->abort };
	my $json_filename = $json_file->tempname;
	my $filename = $json_filename;

	#### This reads the file and converts the JSON to a hash called %data ###
		
	my $json;
	#my $filename = '/www/tabroom/web/register/data/NSDA.json';

{
  local $/; #Enable 'slurp' mode
  open my $fh, "<", $filename;
  $json = <$fh>;
  close $fh;
}

my $HashReferenceDecoded = decode_json($json);
my %data = %$HashReferenceDecoded;

print "Time to load JSON file into a hash:"; 
printf("%.2f\n", time() - $start) ; print "<br>";

	# Erase SCORE field from panel and judge in the $data hash -- they are just
	# temporary things and don't need to be restored.  This is just random
	# cleanup

foreach my $rec (sort keys %{ $data{'judge'} } ) {
	delete $data{'judge'}{$rec}{'score'};
}
foreach my $rec (sort keys %{ $data{'panel'} } ) {
	delete $data{'panel'}{$rec}{'score'};
}

#set up some global utility variables
my $sql;
my $ctr = 0;
my $matched;
my $new_rec;
my $comparisons;

	# STEP TWO: Delete things you don't want from the hash and delete whatever
	# you'll update in the live database For each restore mode, clean everything
	# out of the database that is currenlty associated with whatever you are
	# restoring and remove from the hash everything in an non-permanent table that
	# you don't want restored.  You only need to do this for the highest-level
	# field, so for ENTRY just delete ENTRY and the next routine will delete
	# everything that points to ENTRY, such as the ENTRY_STUDENT, etc.

if ( $restore_mode eq 'tourn' ) {
	$m->comp("/register/data/reset_panels.mas",
		fire_as_function => 42,
		tourn            => $tourn,
		person           => $person,
		certain          => "I am certain"
	);
	$m->comp("/register/data/reset_everything.mas",
		fire_as_function => 42,
		tourn            => $tourn,
		person           => $person,
		certain          => "I am certain"
	);
	$m->comp("/register/data/reset_registration.mas",
		fire_as_function => 42,
		tourn            => $tourn,
		person           => $person,
		certain          => "I am certain"
	);

	my $sth = $dbh->prepare( "DELETE from tourn_circuit where tourn=".$tourn->id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE from tourn_site where tourn=".$tourn->id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE from tourn_ignore where tourn=".$tourn->id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE from tourn_fee where tourn=".$tourn->id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE tiebreak.* from tiebreak, tiebreak_set where tiebreak.tiebreak_set=tiebreak_set.id and tiebreak_set.tourn=".$tourn->id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE tiebreak_set_setting.* from tiebreak_set_setting, tiebreak_set where tiebreak_set_setting.tiebreak_set=tiebreak_set.id and tiebreak_set.tourn=".$tourn->id );
	$sth->execute();
	$sth = $dbh->prepare( "DELETE from tiebreak_set where tourn=".$tourn->id );
	$sth->execute();
	foreach my $category ($tourn->categories) {
		my $sth = $dbh->prepare( "DELETE from category_setting where category=".$category->id );
		$sth->execute();
	}
}
if ( $restore_mode eq 'event' ) {
	print "event id is $event_id<br>";
	
	$event_id_restore = $event_id unless $event_id_restore;
	
	$m->comp("/setup/events/event_rm.mhtml",
		event_id         => $event_id,
		fire_as_function => 42,
		tourn            => $tourn,
		person           => $person
	);

	foreach my $rec (sort keys %{ $data{'event'} } ) {
		delete $data{'event'}{$rec} unless $rec == $event_id_restore;
	}	
}
if ( $restore_mode eq 'round' ) {
	#$m->comp("/funclib/round_dump.mas", round_id => $round_id, fire_as_function => 42, person => $person);
	unless ($round_data_only eq 'on' ) {
		my $sth = $dbh->prepare( "DELETE from round_setting where round=".$round_id );
		$sth->execute();
		print "Just ran DELETE from round_setting where round=".$round_id."<br>";
		$sth = $dbh->prepare( "DELETE from round where id=".$round_id );
		$sth->execute();
	}
	$round_id_import = $round_id unless $round_id_import;
	foreach my $rec (sort keys %{ $data{'round'} } ) {
		delete $data{'round'}{$rec} unless $rec == $round_id_import;
	}	
}
if ( $restore_mode eq 'school_reg' ) {

	$m->comp("/register/school/drop.mhtml",
		school_id        => $school_id,
		fire_as_function => 42,
		tourn            => $tourn,
		person           => $person,
		certain          => "I am certain"
	);

	foreach my $rec (sort keys %{ $data{'school'} } ) {
		delete $data{'event'}{$rec} unless $rec == $school_id;
	}	
}

print "Time to complete deletion:"; printf("%.2f\n", time() - $start) ; print "<br>";

	# STEP THREE: Cascading deletions in the hash to get rid of the events and
	# rounds that you don't want to mess with if you're restoring a round,
	# school, or event, perform a cascading deletion on the hash to get rid of
	# everything associated with deleted records, so if you delete a school
	# delete everything that points to the school you deleted This algorithm
	# works with one exception -- score points to the tiebreak->priority field
	# and calls it 'tiebreak' Don't need to do this for a 'tourn' restore b/c
	# you're using all the data in the hash
		
if ($restore_mode ne 'tourn' ) {
	
	my $all_ok;
	my $trials = 0;
	
	do {
		
		$all_ok = 1;
		$trials++;
		
		foreach my $table (sort keys %data) {
			foreach my $table2 (sort keys %data) {
				foreach my $rec2 (sort keys %{ $data{$table2} } ) {

					if ( $data{$table2}{$rec2}{$table} && delete_exception($table2, $table) == 0 ) {
						#so this will only process the record if the field has a value

						unless ( $data{$table}{ $data{$table2}{$rec2}{$table} } ) {
							#and this will process the deletion if the field has been deleted
							delete $data{$table2}{$rec2};
							$all_ok = 0;
						}
					}
				}
			}	
		}
		
	} until ( $all_ok == 1 || $trials > 10 );
}

print "Time to delete associated records from hash from the hash:";
printf("%.2f\n", time() - $start);
print "<br>";

#print Dumper(%data);

	# STEP FOUR: Check all the upstream records (including permanent) to make sure
	# that records are there, and add them if they're not.  Note that a foreign
	# restore won't have the permanent tables so you don't have to worry about
	# them.  For a local restore they should already be there, but there's a
	# separate routine to audit permanent records for a tourney.
		
#define the upstream tables
my %upstream_table;
foreach my $table (sort keys %data) {
	if ( use_table($table, $restore_mode) eq 'use_me') {
		foreach my $rec (sort keys %{ $data{$table}}) {
			foreach my $field (sort keys %{ $data{$table}{$rec} }) {
				if ( $data{$field} && use_table($field, $restore_mode) ne 'use_me' && $field ne 'tourn' ) {
					$upstream_table{$field} = 1;
					#print "$field is an upstream table for $table and needs to get a tabroom ID for it<br>";
				}
			}
		}
	}
}

foreach my $table (sort keys %data) {
	
	if  ( $upstream_table{$table} == 1 ) {
		
		# Load in db values in case you need them to match later; not as
		# efficient as loading on demand but the coding is way cleaner I
		# *really* didn't want to hard code this but I think I have to.  Only
		# part of the code that isn't the general case.
		
		my %temp_hash;
		undef($sql);
		$sql = "SELECT * FROM category where tourn=$tourn_id" if $table eq 'category';
		$sql = "SELECT judge.* FROM judge, category WHERE judge.category=category.id AND category.tourn=$tourn_id" if $table eq 'judge';
		$sql = "SELECT * FROM pattern where tourn=$tourn_id" if $table eq 'pattern';
		$sql = "SELECT room.* FROM room, site, tourn_site where room.site=site.id and tourn_site.site=site.id and tourn_site.tourn=$tourn" if $table eq 'room';
		$sql = "SELECT site.* FROM site, tourn_site where tourn_site.site=site.id and tourn_site.tourn=$tourn" if $table eq 'site';
		$sql = "SELECT student.* FROM student, school WHERE student.chapter=school.chapter and school.tourn=$tourn" if $table eq 'student';
		$sql = "SELECT * FROM school where tourn=$tourn_id" if $table eq 'school';
		$sql = "SELECT shift.* FROM shift, category WHERE shift.category=category.id AND category.tourn=$tourn_id" if $table eq 'shift';
		$sql = "SELECT tiebreak.* FROM tiebreak, tiebreak_set WHERE tiebreak.tiebreak_set=tiebreak_set.id AND tiebreak_set.tourn=$tourn_id" if $table eq 'tiebreak';
		$sql = "SELECT * FROM tiebreak_set where tourn=$tourn_id" if $table eq 'tiebreak_set';
		$sql = "SELECT tiebreak_set_setting.* FROM tiebreak_set_setting, tiebreak_set WHERE tiebreak_set_setting.tiebreak_set=tiebreak_set.id AND tiebreak_set.tourn=$tourn_id" if $table eq 'tiebreak_set_setting';
		$sql = "SELECT * FROM timeslot where tourn=$tourn_id" if $table eq 'timeslot';
		
		unless ( $sql ) {
			print "Didn't match $table because there was no sql for it <br>";
			next;
		} 
		
		my $sth = $dbh->prepare( $sql );
		$sth->execute();
		my $id_num;
		while (my @temp_data = $sth->fetchrow_array() ) {
			$ctr=0;
			foreach my $val (@temp_data) {
				$id_num = $val if $sth->{NAME}->[$ctr] eq 'id'; 
				$temp_hash{$id_num}{ $sth->{NAME}->[$ctr] } = $val;
				$ctr++;
			}
		}
		
		#print "<BR>Looking for tabroom matches for table $table<br>";
		
		#First pass -- pull the id number from the database and see if it matches
		foreach my $rec (sort keys %{ $data{$table} } ) {
			my $sth = $dbh->prepare( "SELECT * from $table where id=$rec" );
			$sth->execute();
			$matched = 0;
			while (my @temp_data = $sth->fetchrow_array()) {
				$ctr=0;
				$comparisons = 0;
				foreach my $fld (@temp_data) {
					$matched = 1;
					if ($fld && $sth->{NAME}->[$ctr] ne 'timestamp' && $sth->{NAME}->[$ctr] ne 'id' && not $data{ $sth->{NAME}->[$ctr] } ) {
						$comparisons++;
						if ( $data{$table}{$rec}{ $sth->{NAME}->[$ctr] } ne $fld ) {
							$matched = 0;
						}
						#print "Hash value for ".$sth->{NAME}->[$ctr]." is ".$data{$table}{$rec}{ $sth->{NAME}->[$ctr] }." -- ";
						#print " TABROOM value=".$fld." name=".$sth->{NAME}->[$ctr]." matched=$matched<br>" if $fld;
					}
					$ctr++;
				}
			}
			
			#print "Found a match for $table record $rec on $comparisons comparisons when searching by id<br>" if $matched == 1;
			
			#second pass; match it to existing tournament records
			if ( $matched == 0 ) {
				#print "No match for record $rec in table $table so looking it up in the tourney tables in the db...";
				foreach my $temp_rec (keys %temp_hash) {
					$matched = 1;
					$comparisons=0;
					foreach my $key (sort keys %{ $temp_hash{$temp_rec} } ) {
						$new_rec = $temp_hash{$temp_rec}{'id'};
						#if the person record matches you're good
						if ( $data{$table}{$rec}{'person'} ) { 
							if ( $data{$table}{$rec}{'person'} eq $temp_hash{$temp_rec}{'person'} ) {
								$comparisons = " PERSON field ";
								last;
							}
						}
						#OK, so settings tables are weird, but this handles them.  And I'm not sure this is ever necessary
						if (index($table, "_setting") != -1) {
							my $setting_table = substr( $table, 0, index($table, "_setting") );
							if ( $temp_hash{$temp_rec}{$setting_table} eq $data{$setting_table}{ $data{$table}{$rec}{$setting_table} }{'id'} && $temp_hash{$temp_rec}{'tag'} eq $data{$table}{$rec}{'tag'}  ) {
								$comparisons = " SETTINGS $setting_table field ";
								last;
							}
						}
						#only compare if not null, not timestamp, not id, isn't a table name, isn't a settings table
						if ( $temp_hash{$temp_rec}{$key} && $key ne 'timestamp' && $key ne 'id' && not $data{$key} && index($table, "_setting") == -1 ) {
							$comparisons++;
							if ( $data{$table}{$rec}{$key} ne $temp_hash{$temp_rec}{$key} ) {
								$matched = 0;
								last;
							}
							#print "Hash field = ".$key." value= ".$data{$table}{$rec}{ $key }." -- ";
							#print " TABROOM field=".$key." value=".$temp_hash{$temp_rec}{$key}." matched=$matched<br>";
						}
					}
					if ( $matched == 1 ) {
						$data{$table}{$rec}{'id'} = $new_rec;
						#print "Matched $table record $rec in the hash to record $new_rec on $comparisons comparisons in the tabroom db<br>";
						last;
					}
				}
			}
			
			#third pass -- match in the db on the basis of unique records
			if ($matched == 0 ) {
				$sql = "Select * from $table WHERE ";
				foreach my $fld (sort keys %{ $data{$table}{$rec} } ) {
					#if this is a foreign import, none of the permanent table fields should have values
					if ($data{$table}{$rec}{$fld} && $fld ne 'id' && $fld ne 'timestamp' && $fld ne 'ualt_id' && $fld ne 'nsda' ) {
						if ($sql ne "Select * from $table WHERE " ) { $
							sql = $sql." AND ";
						}
						$sql = $sql.$fld."='".$data{$table}{$rec}{$fld}."' ";
					}
				}
				#print $sql."<br>";
				my $sth = $dbh->prepare( $sql );
				$sth->execute();
				if ($sth->rows > 1) {
					print "Trying to do a databse pull, but pulled multiple records<br>";
				}
				$ctr=0;
				while (my @temp_data = $sth->fetchrow_array()) {
					foreach my $fld_value (@temp_data) {
						if ( $sth->{NAME}->[$ctr] eq 'id' ) {
							if ( $sth->rows == 1 ) {
								$data{$table}{$rec}{'id'} = $fld_value;
								$matched = 1;
								print "Found match on database pull and comparison<br>";
							}
						}
						#print " TABROOM value=".$fld_value." field=".$sth->{NAME}->[$ctr]."<br>";
						$ctr++;
					}
				}
			}
								
			if ($matched == 0 ) {
				print "*********** Still no match for record $rec on table $table -- gotta do an insert *********<br>";
			}
			
		}
	}
}

print "Time to check that all the upstream records exist:"; printf("%.2f\n", time() - $start) ; print "<br>";

		#### STEP FIVE: Insert the records you want to restore in to the database
		#### Now scroll through the hash, add the records to the database, and store the new
		#### id numbers in $data{$table}{$rec}{'id'}

my $field_name;
my $field_str;
foreach my $table (sort keys %data) {
	my $insert_table = 1;
	if ($round_data_only eq 'on' && $restore_mode eq 'round' && ($table eq 'round' || $table eq 'round_setting') ) {
		$insert_table= 0 ;
	}
	if ( use_table($table, $restore_mode) eq 'use_me' && $insert_table == 1 ) {
		#print "Now inserting records for table $table<br>";
		foreach my $rec (sort keys %{ $data{$table} }) {
			$ctr=0;
			my @field_values;
			foreach my $field (sort keys %{ $data{$table}{$rec} }) {
			
				
				if ($field ne 'id') {
					if ( $ctr == 0 ) {
						$field_name = $field ;
						$field_str = "?" ;
					} else {
						$field_name = $field_name.", ".$field;
						$field_str = $field_str.", ?" ;
					}
					$field_values[$ctr] = $data{$table}{$rec}{$field};
					$field_values[$ctr] = $tourn_id if $field eq 'tourn' ;
					$ctr++;
				}

			}
			
			$sql = 'INSERT INTO '.$table.' ('.$field_name.') VALUES ('.$field_str.')' ;
			my $sth = $dbh->prepare( $sql );
			$sth->execute(@field_values);
			#Now grab the current id and store it in the hash
			$data{$table}{$rec}{'id'} = $dbh->{'mysql_insertid'};
			#print $sql."<br>"  if $table eq 'tiebreak' ;
			#print "For table $table new tabroom ID for $rec is ".$data{$table}{$rec}{'id'}."<br>";
		}
	}
}

print "Time to create records:"; printf("%.2f\n", time() - $start) ; print "<br>";

		#### STEP SIX: Update the linked records so that they point to the new id numbers
		#### The records are now saved, but they are pointing to the OLD id numbers, so like entry_student is pointing back to the OLD entry id
		#### But the NEW ids are stored in $data{table}{record}{id}, so UPDATE to put the new tabroom id number in all the keys that point to other tables

my $not_this_table=0;
foreach my $table (sort keys %data) {
	if ( use_table($table, $restore_mode) eq 'use_me' ) {
		foreach my $table2 (sort keys %data) {
			$not_this_table = 0;
			foreach my $rec2 (sort keys %{ $data{$table2} }) {
				print $table2." has a record of 1<br>" if $rec2 == 1;
				if ($table2 eq 'score' && $table eq 'tiebreak' ) {
					$not_this_table = 1;
					print "Skipping the tiebreak in the score table<br>";
				}
				last if $not_this_table == 1;
				if ( not exists $data{$table2}{$rec2}{$table} ) {
					#print "no $table found in $table2; value=".$data{$table2}{$rec2}{$table}." for $table2 record=$rec2 so skipping to next table<br>" if $table2 eq 'tiebreak' ;
					$not_this_table = 1;
					last;
				}
				if ( $data{$table2}{$rec2}{$table} ) { 				#don't do anything for blank records
					#print "Changing $table in $table2 record=$rec2 field=$table from ".$data{$table2}{$rec2}{$table}." to ".$data{$table}{ $data{$table2}{$rec2}{$table} }{'id'}."<br>" if $table2 eq 'tiebreak';
					my $orig_id = $data{$table2}{$rec2}{$table};
					$sql = 'UPDATE '.$table2.' SET '.$table.' ='.$data{$table}{ $orig_id }{'id'}.' WHERE id='.$data{$table2}{$rec2}{'id'} ; 
					my $sth = $dbh->prepare( $sql ) ;
					$sth->execute() if $data{$table}{ $orig_id }{'id'};
					#print "$sql<br>" if ( $table2 eq 'tiebreak' || $table eq 'tiebreak' ) ;
					#yeah, coding exceptions!  If the event_setting points to the speaker tiebreak set, update that too!
					if ( $table2 eq 'event_setting' & $data{$table2}{$rec2}{'tag'} eq 'speaker_tbset' ) {
						my $orig_id = $data{$table2}{$rec2}{'value'};
						$sql = 'UPDATE event_setting SET value ='.$data{'tiebreak_set'}{ $orig_id }{'id'}.' WHERE id='.$data{$table2}{$rec2}{'id'} ; 
						my $sth = $dbh->prepare( $sql ) ;
						$sth->execute();
					}
				}
			}
		}
	}
}
print "Time to update records with new id numbers:"; printf("%.2f\n", time() - $start) ; print "<br>";

print "And now we're done!";

sub use_table{

	my $table = shift @_;
	my $restore_mode = shift;

	#don't do anything to the tourn table
	if ($table eq "tourn") { return "nope"; }
	
	#these are permanent tables that don't have anything to do with the tournament, but you should check whether the ids from the tournament are there
	if ($table eq "nsda_event_category") { return "perm"; } 
	if ($table eq "person") { return "perm"; } 
	if ($table eq "person_setting") { return "perm"; } 
	if ($table eq "circuit") { return "perm"; } 
	if ($table eq "chapter") { return "perm"; }
	if ($table eq "room") { return "perm"; } 	
	if ($table eq "site") { return "perm"; } 
	if ($table eq "student") { return "perm"; } 
	if ($table eq "student_setting") { return "perm"; } 

	#these are tables you use depending on whether you are restoring an event, round, or school_reg
	if ($table eq 'event' && $restore_mode eq 'event' ) { return "use_me"; }
	if ($table eq 'event_setting' && $restore_mode eq 'event' ) { return "use_me"; }
	if ($table eq 'entry' && $restore_mode eq 'event' ) { return "use_me"; }
	if ($table eq 'entry_setting' && $restore_mode eq 'event') { return "use_me"; }
	if ($table eq 'entry_student' && $restore_mode eq 'event') { return "use_me"; }
	if ($table eq 'judge' && $restore_mode eq 'school_reg' ) { return "use_me"; }
	if ($table eq 'judge_setting' &&  $restore_mode eq 'school_reg' ) { return "use_me"; }
	if ($table eq 'judge_hire' && $restore_mode eq 'school_reg' ) { return "use_me"; }
	if ($table eq 'rating' && ( $restore_mode eq 'event' || $restore_mode eq 'school_reg') ) { return "use_me"; }
	if ($table eq 'panel' && ( $restore_mode eq 'event' || $restore_mode eq 'round') ) { return "use_me"; }
	if ($table eq 'room_strike' && ( $restore_mode eq 'event' || $restore_mode eq 'school_reg') ) { return "use_me"; }
	if ($table eq 'round' && ( $restore_mode eq 'event' || $restore_mode eq 'round') ) { return "use_me"; }
	if ($table eq 'round_setting' && ( $restore_mode eq 'event' || $restore_mode eq 'round') ) { return "use_me"; }
	if ($table eq 'score' && ( $restore_mode eq 'event' || $restore_mode eq 'round') ) { return "use_me"; }
	if ($table eq 'ballot' && ( $restore_mode eq 'event' || $restore_mode eq 'round') ) { return "use_me"; }
	if ($table eq 'strike' && ( $restore_mode eq 'event' || $restore_mode eq 'school_reg') ) { return "use_me"; }
	if ($table eq 'sweep_event' && $restore_mode eq 'event' ) { return "use_me"; }
	if ($table eq 'result' && ( $restore_mode eq 'event' || $restore_mode eq 'round') ) { return "use_me"; }
	if ($table eq 'result_value' && ( $restore_mode eq 'event' || $restore_mode eq 'round') ) { return "use_me"; }
	
	#if you are restoring a whole tournament, use everything but tourn, which is already excluded above
	if ( $restore_mode eq 'tourn' ) { return "use_me"; }
	
	#if you haven't been used yet, don't use you
	return "nope";
}

sub delete_exception{

	my $table1 = shift @_;
	my $table2 = shift;
	
	if ($table1 eq 'score' && $table2 eq 'tiebreak') { return 1; }
	return 0;

}

</%init>
