<%args>
	$timestring => undef
	$output     => "XML"
</%args>
<%init>

	use Tab::XML;
	use JSON;

	$timestring =~ s/T/ /g;

	my $start;
	eval { $start = DateTime::Format::MySQL->parse_datetime($timestring) };

	if ($timestring && not defined $start) {
		$m->print("TIMESTAMP $timestring FORMAT NOT VALID.  USE: YYYY-MM-DD HH:MM:SS");
		$m->abort;
	}
	$start = DateTime->now unless $start;

	my $grace = $start->clone;
	$grace->add(days => 1);

	Tab::Tourn->set_sql( by_date => "
		select distinct tourn.*
		from tourn
		where tourn.start <= ?
		and tourn.end >= ?
		and tourn.hidden != 1
		order by tourn.name ");

	my @tourns = Tab::Tourn->search_by_date(
		DateTime::Format::MySQL->format_datetime($grace),
		DateTime::Format::MySQL->format_datetime($start));

	my $tourns = [];

	foreach my $tourn (@tourns) {

		my $tourn_data = {
			id    => $tourn->id,
			name  => $tourn->name,
			start => $m->comp("/funclib/showdt.mas" , dt => $tourn->start , length => "json", return => 1),
			end   => $m->comp("/funclib/showdt.mas" , dt => $tourn->end   , length => "json", return => 1),
		};

		push (@{$tourns}, $tourn_data);

		foreach my $category ($tourn->categories) {

			my $category_data = {
				id   => $category->id,
				name => $category->name
			};

			push @{$tourn_data->{categories}}, $category_data;

			foreach my $event ($category->events) {

				my $event_data = {
					id   => $event->id,
					name => $event->name,
					type => $event->type,
					name => $event->name,
					nsda => $event->setting("nsda_event_category")
				};

				push (@{$category_data->{events}}, $event_data);
			}
		}
	}

	$m->clear_buffer();

	if ($output eq "xml") {

		$r->content_type('application/xml');
		my $xs = new XML::Simple();
		print $xs->XMLout($tourns, RootName => 'TOURNLIST', NoAttr => 1, XMLDecl => 1);

	} else {

        my $json = JSON->new->allow_nonref;
		$r->content_type('application/json');
        print $json->pretty->encode( $tourns )

	}

</%init>
