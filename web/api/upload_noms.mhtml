<%args>
	$username    => undef
	$password    => undef
	$session_id  => undef
	$tourn_id    => undef
	$event_id    => undef
	$school_id   => undef
	$category_id => undef
	$from        => undef
</%args>
<%init>

	use JSON -convert_blessed_universally;

	# I hate this;
	our $no_return;
	undef $no_return;
	$no_return = $from;

	my ($person, $tourn) = $m->comp(
		"login_api.mas",
		tourn_id   => $tourn_id,
		username   => $username,
		password   => $password,
		session_id => $session_id
	);

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	my $now     = DateTime->now(time_zone => $tz);
	my $req     = Apache2::Request->new($r);
	my @handles = $r->upload;
	my $upload  = $req->upload($handles[0]);

	$m->print("<div id=\"wrapper\">");
	$m->print("<div id=\"content\">");

	my %settings = $tourn->all_settings();

    $m->comp("/register/data/menu.mas",
        tourn          => $tourn,
		tourn_settings => \%settings,
        person         => $person,
        whoami         => 'import_native',
	);

	$m->print("<div class=\"main\">");

	&outlog("<h2>Uploading data</h2>");
	$m->print("<span class='nospace upload_scroll'>");
	$m->flush_buffer() unless $no_return;

	unless ($upload) {
		&errorlog("<p>No data upload sent, cannot process anything!</p>");
		$m->abort();
	}

	my $contents;
	$upload->slurp($contents);

	my $json = JSON->new->allow_nonref->convert_blessed;
	my $jdata = $json->decode($contents);

	&outlog("<h5 class='centeralign redtext'>Data Upload Complete!</h5>");
	$m->print("</div>");
	$m->print("</div>");
	$m->print("</div>");

	foreach my $judge_id (keys %{$jdata}) {

		my $judge = Tab::Judge->retrieve($judge_id);
		next unless $judge;

		&outlog("<p class='action'>I have a judge ID ".$judge_id." who is y-cleped ".$judge->first." ".$judge->last."</p>");

		my $backup_json = $jdata->{$judge_id};
		my $nom_json = JSON::decode_json($judge->setting("nomination"));

		my $nom;

		if ($nom_json) {

			$nom_json->{chair_nominated}++
				if $backup_json->{chair_nominated}
				&& ($nom_json->{chair_nominated} < 1);

			foreach my $type (keys %{$backup_json->{chair}}) {
				$nom_json->{chair}{$type}++ unless $nom_json->{chair}{$type};

				if ($type eq "middle") {
					foreach my $mid_type (keys %{$backup_json->{middle_types}}) {
						$nom_json->{middle_types}{$mid_type}++ if $nom_json->{middle_types}{$mid_type} < 1;
					}
				}

				if ($type eq "speech") {
					foreach my $mid_type (keys %{$backup_json->{speech_types}}) {
						$nom_json->{speech_types}{$mid_type}++ if $nom_json->{speech_types}{$mid_type} < 1;
					}
				}
			}

			$nom = JSON::encode_json($nom_json);

		} else {
			$nom = JSON::encode_json($backup_json);
		}

		&outlog("<p class='specific'>Restoring nomination with json</p>");
		&outlog("<pre>".$nom."</pre>");
		$judge->setting('nomination', "text", $nom);
	}

	$m->flush_buffer() unless $no_return;
	undef $no_return;

	sub errorlog {
		my $text = shift;
		$m->print('<span class="redtext semibold">');
		$m->print($text);
		$m->print('</span>');
	#	$m->print('{ "error": true, "message": "'.$text.'"}');
		$m->flush_buffer() unless $no_return;
	}

	sub outlog {
		my $text = shift;
		$m->print($text);
	#	$m->print('{ "error": false, "message": "'.$text.'"}');
		$m->flush_buffer() unless $no_return;
	}

</%init>
