<%args>
	$username    => undef
	$password    => undef
	$tourn_id    => undef
	$event_id    => undef
	$school_id   => undef
	$public      => undef
	$session_id  => undef
	$category_id => undef
</%args>
<%init>

	use JSON -convert_blessed_universally;

	my $dbh = Tab::DBI->db_Main();

	my ($person, $tourn, $session) = $m->comp("login_api.mas",
		tourn_id   => $tourn_id,
		username   => $username,
		password   => $password,
		session_id => $session_id
	);

	my $tz = "UTC";
	my $now = DateTime->now(time_zone => $tz);

	my $start_string     = $tourn->start->datetime();
	my $end_string       = $tourn->end->datetime();
	my $reg_start_string = $tourn->reg_start->datetime();
	my $reg_end_string   = $tourn->reg_end->datetime();
	my $now_string       = $now->datetime();

	my @events;
	my @timeslots;
	my @categories;
	my %category_events;
	my $file_name;

	my $json_tourn = {
		name           => $tourn->name,
		start          => $start_string,
		end            => $end_string,
		city           => $tourn->city,
		state          => $tourn->state,
		country        => $tourn->country,
		webname        => $tourn->webname,
		reg_start      => $reg_start_string,
		reg_end        => $reg_end_string,
		timezone       => $tz,
		hidden         => $tourn->hidden,
		backup_created => $now_string,
		creator        => $person->email
	};

	my %schools_used;
	my %events_used;

	if ($public) {
		$json_tourn->{public} = 'true';
	} elsif ($school_id) {
		$json_tourn->{school_only} = $school_id;
	} elsif ($event_id) {
		$json_tourn->{event_only} = $event_id;
	} elsif ($category_id) {
		$json_tourn->{category_only} = $category_id;
	} else {
		$json_tourn->{whole} = 1;
	}


	unless ($school_id || $event_id) {

		# TOURN SETTINGS
		my $ts_sth = $dbh->prepare("
			select
				tourn.id, tourn_setting.id, tourn_setting.tag,
				tourn_setting.value, tourn_setting.value_date, tourn_setting.value_text
			from (tourn, tourn_setting)
			where tourn.id = ?
			and tourn.id = tourn_setting.tourn
		");

		$json_tourn->{settings} = raw_value($ts_sth, $tourn->id);
	}

	my $rpool_sth = $dbh->prepare("
		select
			rpool.id,
			rpool.name,
			rpool_room.room
		from (rpool)
			left join rpool_room on rpool.id = rpool_room.rpool
		where rpool.tourn = ?
	");

	my $rpool_round_sth = $dbh->prepare("
		select
			rpool_round.rpool, rpool_round.round
		from rpool_round, rpool
			where rpool_round.rpool = rpool.id
			and rpool.tourn = ?
	");

	my $event_entries_sth = $dbh->prepare("
		select entry_student.id,
			student.id, student.first, student.middle, student.last, student.grad_year,
				student.nsda, student.phonetic, student.chapter, hybrid.school,
			entry.id, entry.code, entry.name, entry.event, entry.school, school.chapter,
				entry.ada, entry.active, entry.dropped, entry.waitlist, entry.unconfirmed
		from (entry_student, entry, student, school)

		left join school hybrid
			on hybrid.tourn = school.tourn
			and hybrid.chapter = student.chapter

		where entry.event = ?
			and entry.id = entry_student.entry
			and entry_student.student = student.id
			and entry.school = school.id
		group by entry_student.id
	");

	unless ($school_id) {

		if ($event_id) {
			push @events, Tab::Event->retrieve($event_id);
			unless (@events) {
				$m->clear_buffer();
				$m->print("No event found for ID $event_id");
				$m->abort;
			}
			$file_name = $events[0]->name;
		} elsif ($category_id) {
			my $category = Tab::Category->retrieve($category_id);
			unless ($category) {
				$m->clear_buffer();
				$m->print("No judge category found for ID $category_id");
				$m->abort;
			}
			$file_name = $category->name;
			push @events, $category->events;
		} else {
			push @events, $tourn->events;
		}

		foreach my $event (@events) {

			my $category = $event->category;

			unless ($category_events{$category->id}) {
				push @categories, $category;
			}

			push @{$category_events{$category->id}}, $event;
			push (@timeslots, $m->comp("/funclib/event_timeslots.mas", event => $event));
			$events_used{$event->id} = $event;
		}

		my %tseen = ();
		@timeslots = grep { ! $tseen{$_->id} ++ } @timeslots;

		# TIMESLOTS
		foreach my $ts (@timeslots) {

			my $json_ts = {
				id    => $ts->id,
				name  => $ts->name,
				start => $ts->start->datetime(),
				end   => $ts->end->datetime()
			};
			push (@{$json_tourn->{timeslots}}, $json_ts);
		}

		# PATTERNS
		foreach my $pattern ($tourn->patterns) {

			my $json_pattern = {
				id      => $pattern->id,
				name    => $pattern->name,
				tag     => $pattern->type,
				max     => $pattern->max,
				exclude => $pattern->exclude
			};

			push (@{$json_tourn->{patterns}}, $json_pattern);
		}

		my $room_strike_sth = $dbh->prepare("
			select rs.id, rs.type, rs.start, rs.end, rs.room,
				rs.event, rs.tourn, rs.entry, rs.judge
			from room_strike rs, room
			where rs.room = room.id
			and room.site = ?
			and rs.tourn = ?
		");

		# SITES AND ROOMS
		foreach my $site ($tourn->sites) {

			my $json_site = {
				id => $site->id,
				name => $site->name
			};

			push @{$json_tourn->{sites}}, $json_site;

			foreach my $room ($site->rooms(deleted => 0)) {

				my $json_room = {
					id   => $room->id,
					name => $room->name
				};

				$json_room->{rows} = $room->rows if $room->rows;
				$json_room->{seats} = $room->seats if $room->seats;
				$json_room->{inactive} = $room->inactive if $room->inactive;
				$json_room->{ada} = $room->ada if $room->ada && (not defined $public);

				$json_room->{quality} = $room->quality if $room->quality;
				$json_room->{capacity} = $room->capacity if $room->capacity;
				$json_room->{notes} = $room->notes if $room->notes;
				$json_room->{url} = $room->url if $room->url;

				push (@{$json_site->{rooms}}, $json_room);
			}

			$room_strike_sth->execute($site->id, $tourn->id);

			while (
				my ($rs_id, $rs_type, $rs_start, $rs_end, $rs_room,
					$rs_event, $rs_tourn, $rs_entry, $rs_judge
				) = $room_strike_sth->fetchrow_array()
			) {

				my $room_strike = {
					id   => $rs_id,
					tag  => $rs_type,
					room => $rs_room
				};

				$room_strike->{start} = $rs_start if $rs_start;
				$room_strike->{end} = $rs_end if $rs_end;
				$room_strike->{event} = $rs_event if $rs_event;
				$room_strike->{entry} = $rs_entry if $rs_entry;
				$room_strike->{judge} = $rs_judge if $rs_judge;

				push @{$json_site->{blocks}}, $room_strike;
			}
		}

		# ROOM POOLS RPOOLS

		my %rpools;
		$rpool_sth->execute($tourn->id);

		while(
			my (
				$rpool_id,
				$rpool_name,
				$room_id
			) = $rpool_sth->fetchrow_array()
		) {

			my $json_rpool = $rpools{$rpool_id};

			unless ($json_rpool) {
				$json_rpool = {
					id     => $rpool_id,
					name   => $rpool_name
				};
				$rpools{$rpool_id} = $json_rpool;
				push @{$json_tourn->{"room_pools"}}, $json_rpool;
			}
			push @{$json_rpool->{"rooms"}}, $room_id;
		}

		$rpool_round_sth->execute($tourn->id);

		while (
			my (
				$rpool, $round
			) = $rpool_round_sth->fetchrow_array()
		) {

			my $rpool = $rpools{$rpool};

			if ($rpool) {
				push @{$rpool->{rounds}}, $round;
			}
		}

		# WEEKENDS

		foreach my $weekend ($tourn->weekends) {

			my $json_weekend = {
				id              => $weekend->id,
				name            => $weekend->name,
				city            => $weekend->city,
				state           => $weekend->state,
				site            => $weekend->site->id,
				start           => $weekend->start->datetime(),
				end             => $weekend->end->datetime(),
				reg_start       => $weekend->reg_start->datetime(),
				reg_end         => $weekend->reg_end->datetime(),
				freeze_deadline => $weekend->freeze_deadline->datetime(),
				drop_deadline   => $weekend->drop_deadline->datetime(),
				judge_deadline  => $weekend->judge_deadline->datetime(),
				fine_deadline   => $weekend->fine_deadline->datetime(),
			};

			push @{$json_tourn->{weekends}}, $json_weekend;
		}
	}


	my $score_sth = $dbh->prepare("
		select
			score.id, score.tag, score.student, score.value, score.speech, score.position, score.topic, score.content,
			ballot.id, ballot.panel, ballot.judge, ballot.entry, ballot.bye,
				ballot.forfeit, ballot.side, ballot.speakerorder, ballot.audit, ballot.chair,
			panel.id, panel.letter, panel.round, panel.room, panel.bye, panel.flight, panel.bracket,
				panel.started, panel.publish,
			round.id, round.name, round.event, round.flighted, round.tiebreak_set,
				round.label, round.type, round.timeslot, round.site,
				round.published, round.post_results, round.created, round.start_time,
				runoff.id

			from (round)

			left join panel on panel.round = round.id
			left join ballot on ballot.panel = panel.id
			left join score on score.ballot = ballot.id
			left join round runoff on runoff.id = round.runoff

			where round.event = ?
	");

	my $cs_sth = $dbh->prepare("
		select
			category_setting.category, category_setting.id, category_setting.tag,
			category_setting.value, category_setting.value_date, category_setting.value_text
		from category_setting

		where category_setting.category = ?
	");

	my $rs_sth = $dbh->prepare("
		select
			round_setting.round, round_setting.id, round_setting.tag,
			round_setting.value, round_setting.value_date, round_setting.value_text
		from round_setting

		where round_setting.round = ?
	");

	my $cj_sth = $dbh->prepare("
		select
			judge.id, judge_setting.id, judge_setting.tag,
			judge_setting.value, judge_setting.value_date, judge_setting.value_text
		from (judge, judge_setting)

		where judge.category = ?
			and judge.id = judge_setting.judge
	");

	my $sj_sth = $dbh->prepare("
		select
			judge.id, judge_setting.id, judge_setting.tag,
			judge_setting.value, judge_setting.value_date, judge_setting.value_text
		from (judge, judge_setting)

		where judge.school = ?
			and judge.id = judge_setting.judge
	");


	my $judge_sth = $dbh->prepare("
		select
			judge.id, judge.first, judge.middle, judge.last, judge.person,
			judge.code, judge.ada, judge.active, judge.obligation, judge.hired,
			judge.alt_category, judge.covers, judge.chapter_judge,
			judge.school,
			person.id, person.email, person.phone

		from judge
		left join person on person.id = judge.person

		where judge.category = ?
		group by judge.id
	");


	my $school_judge_sth = $dbh->prepare("
		select
			judge.id, judge.first, judge.middle, judge.last, judge.person,
			judge.code, judge.ada, judge.active, judge.obligation, judge.hired,
			judge.category,
			judge.alt_category, judge.covers, judge.chapter_judge,
			judge.school,
			person.id, person.email, person.phone

		from judge
		left join person on person.id = judge.person
		where judge.school = ?
	");

	my $jpool_sth = $dbh->prepare("
		select
			jpool.id,
			jpool_judge.judge,
			jpool.name, jpool.category, jpool.site, jpool.parent
		from (jpool)
			left join jpool_judge on jpool.id = jpool_judge.jpool
		where jpool.category = ?
	");

	my $jpool_setting_sth = $dbh->prepare("
		select
			setting.id, setting.tag, setting.value, setting.value_text, setting.value_date, setting.jpool
		from (jpool_setting setting, jpool)
		where jpool.category = ?
			and jpool.id = setting.jpool
	");

	my $jpool_round_sth = $dbh->prepare("
		select jpool_round.jpool
		from jpool_round, jpool
		where jpool_round.jpool = jpool.id
			and jpool.category = ?
	");

	my $rating_sth = $dbh->prepare("
		select
			rating.id, rating.type, rating.draft, rating.entry, rating.judge,
			rating.tourn, rating.school, rating.entered,
			rating.ordinal, rating.percentile,
			rating.rating_tier, rating_tier.name, rating.rating_subset

		from (rating, judge)

		left join rating_tier on rating_tier.id = rating.rating_tier

		where rating.judge = judge.id
			and judge.category = ?
	");

	my $strike_sth = $dbh->prepare("
		select
			strike.id, strike.type, strike.start, strike.end,
			strike.judge, strike.entry, strike.event, strike.school,
			strike.region, strike.district, strike.timeslot,
			strike.shift, strike.registrant, strike.conflictee

		from (strike, judge)

		where strike.judge = judge.id
		and judge.category = ?
	");

	my $results_sth = $dbh->prepare("
		select
			rv.id, rv.tag, rv.value, rv.priority, rv.description, rv.no_sort, rv.sort_desc,
			result.id, result.rank, result.percentile, result.entry, result.student, result.school, result.round,
			rs.id, rs.label, rs.bracket, rs.published, rs.coach, rs.tourn, rs.event

			from result_set rs

			left join result on result.result_set = rs.id
			left join result_value rv on rv.result = result.id

			where rs.event = ?
	");

	my %judges;
	my %jpools;

	# CATEGORY CATEGORIES
	unless ($school_id) {

		foreach my $category (@categories) {

			my $category_id = $category->id;

			next if $ARGS{category_id} && ($ARGS{category_id} ne $category_id);

			next unless $category_events{$category_id};

			my $json_category = {
				id   => $category->id,
				name => $category->name,
				abbr => $category->abbr
			};

			$json_category->{settings} = raw_value($cs_sth, $category_id);

			push (@{$json_tourn->{categories}}, $json_category);

			# RATINGS PREFS RATING TIERS
			foreach my $rt ($category->rating_tiers) {
				my $json_rating = {
					id          => $rt->id,
					tag         => $rt->type,
					name        => $rt->name,
					strike      => $rt->strike,
					conflict    => $rt->conflict,
					description => $rt->description,
					min         => $rt->min,
					max         => $rt->max,
					start       => $rt->start
				};

				push @{$json_category->{'rating_tiers'}}, $json_rating;
			}

			# RATINGS PREFS RATING TIERS
			foreach my $rs ($category->rating_subsets) {
				my $json_subset = {
					id   => $rs->id,
					name => $rs->name,
				};
				push @{$json_category->{'rating_subsets'}}, $json_subset;
			}

			# JUDGES
			$judge_sth->execute($category_id);

			my %done_judge;

			while (
				my (
					$judge_id, $judge_first, $judge_middle, $judge_last,
					$judge_person, $judge_code, $judge_ada, $judge_active,
					$judge_obligation, $judge_hired,
					$judge_alt_category,
					$judge_covers, $judge_chapter_judge, $judge_school,
					$person_id, $person_email, $person_phone
				) = $judge_sth->fetchrow_array()
			) {

				next if $done_judge{$judge_id}++;

				my $json_judge = {
					id       => $judge_id,
					first    => $judge_first,
					last     => $judge_last
				};

				$schools_used{$judge_school}++ if $judge_school;
				$person_phone =~ s/[\D_]//g;

				$json_judge->{school}        = $judge_school if $judge_school;
				$json_judge->{active}        = $judge_active;
				$json_judge->{ada}           = $judge_ada unless $public;
				$json_judge->{email}         = lc($person_email) if $person_email;
				$json_judge->{phone}         = $person_phone if $person_phone;
				$json_judge->{person}        = $person_id if $person_id;
				$json_judge->{obligation}    = $judge_obligation if $judge_obligation;
				$json_judge->{hired}         = $judge_hired if $judge_hired;
				$json_judge->{alt_category}  = $judge_alt_category if $judge_alt_category;
				$json_judge->{covers}        = $judge_covers if $judge_covers;
				$json_judge->{chapter_judge} = $judge_chapter_judge if $judge_chapter_judge;

				$judges{$judge_id} = $json_judge;
				push @{$json_category->{judges}}, $json_judge;
			}

			$judge_sth->finish();
			$cj_sth->execute($category_id);

			while(
				my (
					$judge_id, $js_id, $js_tag, $js_value, $js_value_date, $js_value_text
				) = $cj_sth->fetchrow_array()
			) {

				my $meta;
				if ($js_value eq "date") {
					$js_value_date =~ s/ /T/g;
					$js_value = $js_value_date;
					$meta = "date";
				} elsif ($js_value eq "text") {
					$js_value = $js_value_text;
					$meta = "text";
				}

				my $js_setting = {
					tag   => $js_tag,
					value => $js_value,
					meta  => $meta
				};

				push @{$judges{$judge_id}->{settings}}, $js_setting;
			}

			$cj_sth->finish();

			# JUDGE POOLS JPOOLS

			$jpool_sth->execute($category_id);

			while(
				my (
					$jpool_id,
					$judge_id,
					$jpool_name, $jpool_category, $jpool_site, $jpool_parent
				) = $jpool_sth->fetchrow_array()
			) {

				my $json_jpool = $jpools{$jpool_id};

				unless ($json_jpool) {
					$json_jpool = {
						id     => $jpool_id,
						name   => $jpool_name,
						site   => $jpool_site,
						parent => $jpool_parent
					};
					$jpools{$jpool_id} = $json_jpool;
				}

				push @{$jpools{$jpool_id}->{judges}}, $judge_id;
			}

			foreach my $key (keys %jpools) {
				push @{$json_category->{judge_pools}}, $jpools{$key};
			}

			$jpool_setting_sth->execute($category_id);

			while (
				my (
					$setting_id, $setting_tag, $setting_value,
					$setting_value_text, $setting_value_date, $setting_jpool
				) = $jpool_setting_sth->fetchrow_array()
			) {

				my $jpool = $jpools{$setting_jpool};

				if ($jpool) {

					my $meta;

					if ($setting_value eq "date") {
						$setting_value_date =~ s/ /T/g;
						$setting_value = $setting_value_date;
						$meta = "date";
					} elsif ($setting_value eq "text") {
						$setting_value = $setting_value_text;
						$meta = "text";
					}

					my $jpool_setting = {
						tag   => $setting_tag,
						value => $setting_value,
						meta  => $meta
					};

					push @{$jpool->{settings}}, $jpool_setting;
				}
			}

			# JPOOL ROUNDS

			$jpool_round_sth->execute($tourn->id);

			while (
				my (
					$jpool, $round
				) = $jpool_round_sth->fetchrow_array()
			) {

				my $jpool = $jpools{$jpool};

				if ($jpool) {
					push @{$jpool->{rounds}}, $round;
				}
			}

			# EVENTS
			foreach my $event (@{$category_events{$category_id}}) {

				my $json_event = {
					id            => $event->id,
					name          => $event->name,
					abbr          => $event->abbr,
					type          => $event->type,
					fee           => $event->fee,
					pattern       => $event->pattern,
					rating_subset => $event->rating_subset
				};

				foreach my $event_setting ($event->settings) {

					my $json_eset = {
						tag   => $event_setting->tag,
						value => setting_value($event_setting),
					};

					push (@{$json_event->{settings}}, $json_eset);
				}

				push @{$json_category->{"events"}}, $json_event;

				# EVENT ENTRIES
				# If we are downloading only one event or category, then we need the entries here as well.

				if ($json_tourn->{event_only} || $json_tourn->{category_only}) {

					$event_entries_sth->execute($event->id);

					while (
						my (
							$entry_student_id,
							$student_id, $student_first, $student_middle, $student_last,
							$student_grad_year, $student_nsda, $student_phonetic, $student_chapter, $student_school,
							$entry_id, $entry_code, $entry_name, $entry_event, $entry_school, $entry_chapter,
							$entry_ada, $entry_active, $entry_dropped, $entry_waitlist, $entry_unconfirmed
						) = $event_entries_sth->fetchrow_array()
					) {

						my $json_entry;

						if ($entries{$entry_id}) {

							$json_entry = $entries{$entry_id};

						} else {

							$json_entry = {
								id     => $entry_id,
								school => $entry_school,
								event  => $entry_event,
								code   => $entry_code,
								name   => $entry_name
							};

							$json_entry->{ada}         = $entry_ada unless $public;
							$json_entry->{active}      = $entry_active;

							$json_entry->{hybrid}      = $entry_active;

							$json_entry->{dropped}     = $entry_dropped;
							$json_entry->{waitlist}    = $entry_waitlist;
							$json_entry->{unconfirmed} = $entry_unconfirmed;
							$json_entry->{settings}    = raw_value($es_sth, $entry_id);

							$entries{$entry_id} = $json_entry;
							push (@{$json_school->{entries}}, $json_entry);

						}

						my $json_student = {
							id        => $student_id,
							chapter   => $student_chapter,
							first     => $student_first,
							last      => $student_last
						};

						$json_student->{nsda}      = $student_nsda if $student_nsda;
						$json_student->{grad_year} = $student_grad_year if $student_grad_year;
						$json_student->{middle}    = $student_middle if $student_middle;

						push @{$json_entry->{students}}, $json_student;

					}
				}

				# PATTERNS

				my %rounds;
				my %sections;
				my %ballots;

				$score_sth->execute($event->id);

				# ROUNDS BALLOTS AND SCORES
				while (
					my (
						$score_id, $score_tag, $score_student, $score_value, $score_speech,
						$score_position, $score_topic, $score_content,
						$ballot_id, $ballot_panel, $ballot_judge, $ballot_entry, $ballot_bye,
						$ballot_forfeit, $ballot_side, $ballot_speakerorder, $ballot_audit, $ballot_chair,
						$panel_id, $panel_letter, $panel_round, $panel_room, $panel_bye, $panel_flight, $panel_bracket,
							$panel_started, $panel_publish,
						$round_id, $round_name, $round_event, $round_flighted, $round_tiebreak_set,
						$round_label, $round_type, $round_timeslot, $round_site,
						$round_published, $round_results, $round_created, $round_start_time,
						$runoff_id
					) = $score_sth->fetchrow_array()
				) {

					my $json_round;

					$score_tag = "winloss" if $score_tag eq "ballot";

					if ($rounds{$round_id}) {

						$json_round = $rounds{$round_id};

					} else {

						$json_round = {
							id           => $round_id,
							type         => $round_type,
							name         => $round_name,
							published    => $round_published,
							post_results => $round_results,
							timeslot     => $round_timeslot,
							created      => $round_created,
							start_time   => $round_start_time,
							site         => $round_site,
							tiebreak_set => $round_tiebreak_set
						};

						$json_round->{label}  = $round_label if $round_label;
						$json_round->{flights} = $round_flighted if $round_flighted;
						$json_round->{runoff}  = $runoff_id if $runoff_id;

						# ROUND SETTINGS
						$json_round->{settings} = raw_value($rs_sth, $round_id);
						$rounds{$round_id} = $json_round;

						push @{$json_event->{rounds}}, $json_round;
					}

					if ($round_published > 0 || (not defined $public)) {

						# SECTIONS PANELS
						if ($panel_id) {

							my $json_section;

							if ($sections{$panel_id}) {

								$json_section = $sections{$panel_id};

							} else {

								$json_section = {
									id      => $panel_id,
									round   => $round_id,
									room    => $panel_room,
									letter  => $panel_letter
								};

								$json_section->{bye}     = 1 if $panel_bye;
								$json_section->{publish} = 1 if $panel_publish;
								$json_section->{bracket} = $panel_bracket if $panel_bracket;
								$json_section->{flight}  = $panel_flight if $panel_flight;

								push @{$json_round->{"sections"}}, $json_section;
								$sections{$panel_id} = $json_section;
							}

							if ($ballot_id) {

								my $json_ballot;

								# BALLOTS
								if ($ballots{$ballot_id}) {

									$json_ballot = $ballots{$ballot_id};

								} else {

									$json_ballot = {
										id    => $ballot_id,
										panel => $panel_id,
										entry => $ballot_entry
									};

									$json_ballot->{side}         = $ballot_side if $ballot_side;
									$json_ballot->{speakerorder} = $ballot_speakerorder if $ballot_speakerorder;

									if ($round_published != 2 || (not defined $public)) {
										$json_ballot->{judge}   = $ballot_judge if $ballot_judge;
										$json_ballot->{chair}   = $ballot_chair;
									}

									if ($round_results > 0 || (not defined $public)) {
										$json_ballot->{audit}   = $ballot_audit;
										$json_ballot->{bye}     = $ballot_bye;
										$json_ballot->{forfeit} = $ballot_forfeit;
									}

									$ballots{$ballot_id} = $json_ballot;
									push @{$json_section->{"ballots"}}, $json_ballot;

								}

								if ($public) {

									next unless $round_results > 0;
									if ($round_results == 1 && $score_tag ne "winloss") {
										next;
									}
								}

								# SCORES
								if ($score_id) {

									my $json_score = {
										id    => $score_id,
										tag   => $score_tag,
										value => $score_value
									};

									$json_score->{speaker}  = $score_student if $score_student;
									$json_score->{topic}    = $score_topic if $score_topic;
									$json_score->{speech}   = $score_speech if $score_speech;
									$json_score->{position} = $score_position if $score_position;
									$json_score->{content}  = $score_content if $score_content;
									push @{$json_ballot->{"scores"}}, $json_score;
								}
							}
						}
					}
				}

				$score_sth->finish();

				# RESULTS SHEETS
				$results_sth->execute($event->id);

				my %results;
				my %result_sets;

				while(
					my (
						$rv_id, $rv_tag, $rv_value, $rv_priority, $rv_description, $rv_no_sort, $rv_sort_desc,
						$result_id, $result_rank, $result_percentile, $result_entry, $result_student, $result_school, $result_round,
						$rs_id, $rs_label, $rs_bracket, $rs_published, $rs_coach, $rs_tourn, $rs_event
					) = $results_sth->fetchrow_array()
				) {

					my $json_rs;

					if ($result_sets{$rs_id}) {

						$json_rs = $result_sets{$rs_id};

					} else {

						$json_rs = {
							label     => $rs_label,
							bracket   => $rs_bracket,
							published => $rs_published,
							coach     => $rs_coach
						};

						push @{$json_event->{result_sets}}, $json_rs;
						$result_sets{$rs_id} = $json_rs;
					}

					my $json_result;

					if ($results{$result_id}) {

						$json_result = $results{$result_id};

					} else {

						$json_result = {
							rank       => $result_rank,
							percentile => $result_percentile,
							entry      => $result_entry,
							student    => $result_student,
							school     => $result_school,
							round      => $result_round
						};

						push @{$json_rs->{results}}, $json_result;
						$results{$result_id} = $json_result;
					}

					my $json_rv = {
						tag         => $rv_tag,
						value       => $rv_value,
						priority    => $rv_priority,
						description => $rv_description,
						no_sort     => $rv_no_sort,
						sort_desc   => $rv_sort_desc,
					};

					push @{$json_result->{"values"}}, $json_rv;

				}
			}

			# PREFS RATINGS AND STRIKES
			unless ($public) {

				$rating_sth->execute($category_id);

				while (
					my (
						$rating_id, $rating_type, $rating_draft, $rating_entry, $rating_judge,
						$rating_tourn, $rating_school, $rating_entered,
						$rating_ordinal, $rating_percentile,
						$rating_rating_tier, $rating_tier_name, $rating_rating_subset
					) = $rating_sth->fetchrow_array()
				) {

					next unless $rating_ordinal || $rating_tier_name;

					my $json_rating = {
						id    => $rating_id,
						tag   => $rating_type
					};

					$json_rating->{school} = $rating_school if $rating_school;
					$json_rating->{entry} = $rating_entry if $rating_entry;

					$json_rating->{draft} = $rating_draft if $rating_draft;
					$json_rating->{rating_subset} = $rating_rating_subset if $rating_rating_subset;

					$json_rating->{entered} = $rating_entered if $rating_entered;

					if ($rating_tier_name) {
						$json_rating->{rating} = $rating_tier_name;
						$json_rating->{rating_tier} = $rating_rating_tier;
					} else {
						$json_rating->{rating} = $rating_ordinal;
						$json_rating->{ordinal} = $rating_ordinal;
						$json_rating->{percentile} = $rating_percentile;
					}

					push (@{$judges{$rating_judge}{ratings}}, $json_rating);
				}

				$rating_sth->finish();

				$strike_sth->execute($category_id);

				while (
					my (
						$strike_id, $strike_type, $strike_start, $strike_end, $strike_judge,
						$strike_entry, $strike_event, $strike_school, $strike_region, $strike_district,
						$strike_timeslot, $strike_shift, $strike_registrant, $strike_conflictee
					) = $strike_sth->fetchrow_array()
				) {

					my $json_strike = {
						id    => $strike_id,
						tag   => $strike_type,
						judge => $strike_judge
					};

					$json_strike->{entry} = $strike_entry if $strike_entry;
					$json_strike->{event} = $strike_event if $strike_event;
					$json_strike->{school} = $strike_school if $strike_school;
					$json_strike->{region} = $strike_region if $strike_region;
					$json_strike->{district} = $strike_district if $strike_district;
					$json_strike->{shift} = $strike_shift if $strike_shift;
					$json_strike->{timeslot} = $strike_timeslot if $strike_timeslot;

					if ($strike_start && $strike_end) {
						$json_strike->{start} = $strike_start;
						$json_strike->{end} = $strike_end;
					}

					push (@{$judges{$strike_judge}{"strike"}}, $json_strike);

				}
			}
		}
	}

	my $student_sth = $dbh->prepare("
		select
			entry_student.id,
			student.id, student.first, student.middle, student.last, student.grad_year,
				student.nsda, student.phonetic, student.chapter,
			entry.id, entry.code, entry.name, entry.event,
				entry.school, entry.ada, entry.active, entry.dropped, entry.waitlist, entry.unconfirmed,
			school.id, school.name, school.chapter, school.code,
				school.onsite, school.state, school.region, school.district,
			chapter.id, chapter.nsda, pairing_seed.value,
			hybrid.id, hybrid.type, hybrid.school

		from (entry, school, chapter, event)

			left join entry_student
				on entry_student.entry = entry.id

			left join student
				on student.id = entry_student.student
				and student.chapter = chapter.id

			left join entry_setting pairing_seed
				on pairing_seed.tag = 'pairing_seed'
				and pairing_seed.entry = entry.id

			left join strike hybrid
				on hybrid.entry = entry.id
				and hybrid.type = 'hybrid'

		where event.tourn = ?
			and event.id = entry.event
			and entry.school = school.id
			and school.chapter = chapter.id
		group by entry_student.id
	");

	my $ss_sth = $dbh->prepare("
		select
			school.id, school_setting.id, school_setting.tag,
			school_setting.value, school_setting.value_date, school_setting.value_text
		from (school, school_setting)

		where school.id = ?
			and school.id = school_setting.school
	");

	my $es_sth = $dbh->prepare("
		select
			entry.id, entry_setting.id, entry_setting.tag,
			entry_setting.value, entry_setting.value_date, entry_setting.value_text
		from (entry, entry_setting)

		where entry.id = ?
			and entry.id = entry_setting.entry
	");

	my $es_sth = $dbh->prepare("
		select
			entry.id, entry_setting.id, entry_setting.tag,
			entry_setting.value, entry_setting.value_date, entry_setting.value_text
		from (entry, entry_setting)

		where entry.id = ?
			and entry.id = entry_setting.entry
	");

	my $purchase_sth = $dbh->prepare("
		select purchase.id, purchase.school,
			purchase.quantity, purchase.placed, purchase.fulfilled,
				purchase.concession, purchase.invoice,
			cpo.concession_option
		from (concession_purchase purchase, school)
			left join concession_purchase_option cpo on cpo.concession_purchase = purchase.id
		where purchase.school = school.id
		and school.tourn = ?
	");

	my $invoice_sth = $dbh->prepare("
		select invoice.id,
			invoice.blusynergy, invoice.blu_number,
			invoice.total, invoice.paid,
			invoice.school, invoice.details
		from (invoice, school)
		where invoice.school = school.id
		and school.tourn = ?
	");


	my %schools;
	my %students;
	my %entries;

	unless ($event_id || $category_id) {

		$student_sth->execute($tourn->id);

		while (
			my (
				$entry_student_id,
				$student_id, $student_first, $student_middle, $student_last, $student_grad_year,
				$student_nsda, $student_phonetic, $student_chapter,
				$entry_id, $entry_code, $entry_name, $entry_event, $entry_school,
				$entry_ada, $entry_active, $entry_dropped, $entry_waitlist, $entry_unconfirmed,
				$this_school_id, $school_name, $school_chapter, $school_code, $school_onsite,
				$school_state, $school_region, $school_district,
				$chapter_id, $chapter_nsda, $entry_seed,
				$hybrid_id, $hybrid_type, $hybrid_school
			) = $student_sth->fetchrow_array()
		) {

			if ($school_id) {
				next if ($school_id != $entry_school);
				$file_name = $school_name;
			} else {
				next unless $events_used{$entry_event};
			}

			my $json_school;

			# SCHOOLS CHAPTERS

			if ($schools{$entry_school}) {

				$json_school = $schools{$entry_school};

			} else {

				$json_school = {
					id      => $entry_school,
					name    => $school_name,
					chapter => $school_chapter,
					onsite  => $school_onsite
				};

				$json_school->{code}     = $school_code if $school_code;
				$json_school->{state}    = $school_state if $school_state;
				$json_school->{nsda}     = $chapter_nsda if $chapter_nsda;
				$json_school->{region}   = $school_region if $school_region;
				$json_school->{district} = $school_district if $school_district;
				$json_school->{settings} = raw_value($ss_sth, $entry_school);

				$schools{$entry_school} = $json_school;
				push (@{$json_tourn->{schools}}, $json_school);
			}

			# ENTRY ENTRIES
			my $json_entry;

			if ($entries{$entry_id}) {

				$json_entry = $entries{$entry_id};

			} else {

				$json_entry = {
					id     => $entry_id,
					school => $entry_school,
					event  => $entry_event,
					code   => $entry_code,
					name   => $entry_name
				};

				$json_entry->{ada}         = $entry_ada unless $public;
				$json_entry->{active}      = $entry_active;
				$json_entry->{hybrid}      = $hybrid_school;
				$json_entry->{dropped}     = $entry_dropped;
				$json_entry->{waitlist}    = $entry_waitlist;
				$json_entry->{unconfirmed} = $entry_unconfirmed;
				$json_entry->{settings}    = raw_value($es_sth, $entry_id);

				$entries{$entry_id} = $json_entry;
				push (@{$json_school->{entries}}, $json_entry);
			}

			# STUDENTS COMPETITORS
			my $json_student;

			if ($students{$student_id}) {
				$json_student = $students{$student_id};
			} else {

				$json_student = {
					id        => $student_id,
					chapter   => $student_chapter,
					first     => $student_first,
					last      => $student_last
				};

				$json_student->{nsda}      = $student_nsda if $student_nsda;
				$json_student->{grad_year} = $student_grad_year if $student_grad_year;
				$json_student->{middle}    = $student_middle if $student_middle;

				push (@{$json_school->{students}}, $json_student);
				$students{$student_id} = $json_student;
			}

			push @{$json_entry->{students}}, $student_id;
		}

		$student_sth->finish();

		if ($school_id) {

			# SCHOOL JUDGES

			$school_judge_sth->execute($school_id);

			my $json_school = ${$json_tourn->{schools}}[0];
			my %done_judge;

			while (
				my (
					$judge_id, $judge_first, $judge_middle, $judge_last,
					$judge_person, $judge_code, $judge_ada, $judge_active,
					$judge_obligation, $judge_hired,
					$judge_category, $judge_alt_category,
					$judge_covers, $judge_chapter_judge, $judge_school,
					$person_id, $person_email, $person_phone

				) = $school_judge_sth->fetchrow_array()
			) {

				next if $done_judge{$judge_id}++;

				my $json_judge = {
					id       => $judge_id,
					first    => $judge_first,
					last     => $judge_last,
					category => $judge_category
				};

				$schools_used{$judge_school}++ if $judge_school;

				$person_phone =~ s/[\D_]//g;

				$json_judge->{active}       = $judge_active;
				$json_judge->{ada}          = $judge_ada unless $public;
				$json_judge->{email}        = lc($person_email) if $person_email;
				$json_judge->{phone}        = $person_phone if $person_phone;
				$json_judge->{middle}       = $judge_middle if $judge_middle;
				$json_judge->{code}         = $judge_code if $judge_code;
				$json_judge->{person}       = $person_id if $person_id;
				$json_judge->{obligation}   = $judge_obligation if $judge_obligation;
				$json_judge->{hired}        = $judge_hired if $judge_hired;
				$json_judge->{alt_category} = $judge_alt_category if $judge_alt_category;
				$json_judge->{covers}       = $judge_covers if $judge_covers;

				$judges{$judge_id} = $json_judge;

				push @{$json_school->{"judges"}}, $json_judge;
			}

			$school_judge_sth->finish();
			$sj_sth->execute($school_id);

			while(
				my (
					$judge_id, $js_id, $js_tag, $js_value, $js_value_date, $js_value_text
				) = $sj_sth->fetchrow_array()
			) {

				my $meta;
				if ($js_value eq "date") {
					$js_value_date =~ s/ /T/g;
					$js_value = $js_value_date;
					$meta = "date";
				} elsif ($js_value eq "text") {
					$js_value = $js_value_text;
					$meta = "text";
				}

				my $js_setting = {
					tag   => $js_tag,
					value => $js_value,
					meta  => $meta
				};

				push @{$judges{$judge_id}->{settings}}, $js_setting;
			}

			$sj_sth->finish();
		}

		$purchase_sth->execute($tourn->id);
		my %purchases;

		while (
			my (
				$purchase_id, $purchase_school,
				$purchase_quantity, $purchase_placed, $purchase_fulfilled,
				$purchase_concession, $purchase_invoice, $cpo_option
			) = $purchase_sth->fetchrow_array()
		) {

			next unless $purchase_quantity > 0;

			my $json_school = $schools{$purchase_school};

			if ($json_school) {

				my $json_purchase = $purchases{$purchase_id};

				unless ($json_purchase) {

					$json_purchase = {
						id         => $purchase_id,
						quantity   => $purchase_quantity,
						placed     => $purchase_placed,
						fulfilled  => $purchase_fulfilled,
						concession => $purchase_concession,
						invoice    => $purchase_invoice,
					};

					push @{$json_school->{purchases}}, $json_purchase;
					$purchases{$purchase_id} = $json_purchase;
				}

				push @{$json_purchase->{options}}, $cpo_option if $cpo_option;
			}
		}

		#INVOICES
		$invoice_sth->execute($tourn->id);

		while (
			my ( $invoice_id, $invoice_blusynergy, $invoice_blu_number,
				$invoice_total, $invoice_paid, $invoice_school, $invoice_details
			) = $invoice_sth->fetchrow_array()
		) {

			my $json_school = $schools{$invoice_school};

			my $json_invoice = {
				id         => $invoice_id,
				blusynergy => $invoice_blusynergy,
				blu_number => $invoice_blu_number,
				total      => $invoice_total,
				paid       => $invoice_paid,
				details    => $invoice_details
			};

			push @{$json_school->{invoices}}, $json_invoice;

		}
	}

	unless ($event_id || $category_id) {

		my $region_sth = $dbh->prepare("
			select region.id, region.name, region.code,
				region.quota, region.arch, region.cooke_pts, region.sweeps,
				region.circuit, region.tourn
			from region
				where region.tourn = ?
		");

		$region_sth->execute($tourn->id);

		while (
			my ($region_id, $region_name, $region_code, $region_quota, $region_arch,
			    $region_cooke_pts, $region_sweeps, $region_circuit, $region_tourn
			) = $region_sth->fetchrow_array()
		) {

			my $json_region = {
				id           => $region_id,
				name         => $region_name,
				code         => $region_code,
				quota        => $region_quota,
				arch         => $region_arch,
				cooke_points => $region_cooke_pts,
				sweeps       => $region_sweeps,
				circuit      => $region_circuit,
				tourn        => $region_tourn
			};

			push @{$json_tourn->{"regions"}}, $json_region;
		}
	}

	unless ($school_id) {

		my $tb_sth = $dbh->prepare("
			select
				tiebreak.id, tiebreak.name, tiebreak.count, tiebreak.count_round,
				tiebreak.truncate, tiebreak.truncate_smallest,
				tiebreak.multiplier, tiebreak.priority,
				tiebreak.highlow, tiebreak.highlow_count,
				tiebreak.child,
				ts.id, ts.name

			from tiebreak, tiebreak_set ts
				where ts.tourn = ?
				and ts.id = tiebreak.tiebreak_set
		");

		my $ts_sth = $dbh->prepare("
			select
				tiebreak_set.id, tiebreak_set_setting.id, tiebreak_set_setting.tag,
				tiebreak_set_setting.value, tiebreak_set_setting.value_date, tiebreak_set_setting.value_text
			from (tiebreak_set, tiebreak_set_setting)

			where tiebreak_set.id = ?
				and tiebreak_set.id = tiebreak_set_setting.tiebreak_set
		");

		my %tbsets;

		$tb_sth->execute($tourn_id);

		while (
			my (
				$tiebreak_id, $tiebreak_name, $tiebreak_count, $tiebreak_count_round,
				$tiebreak_truncate, $tiebreak_truncate_smallest,
				$tiebreak_multiplier, $tiebreak_priority,
				$tiebreak_highlow, $tiebreak_highlow_count, $tiebreak_child,
				$ts_id, $ts_name
			) = $tb_sth->fetchrow_array()
		) {

			my $json_tbset;

			if ($tbsets{$ts_id}) {

				$json_tbset = $tbsets{$ts_id};

			} else {

				$json_tbset = {
					id   => $ts_id,
					name => $ts_name
				};

				$json_tbset->{settings} = raw_value($ts_sth, $ts_id);

				$tbsets{$ts_id} = $json_tbset;
				push @{$json_tourn->{"tiebreak_sets"}}, $json_tbset;

			};

			my $json_tb = {
				name     => $tiebreak_name,
				priority => $tiebreak_priority,
				count    => $tiebreak_count
			};

			$json_tb->{highlow_count}     = $tiebreak_highlow_count if $tiebreak_highlow_count;
			$json_tb->{count_round}       = $tiebreak_count_round if $tiebreak_count_round;
			$json_tb->{truncate}          = $tiebreak_truncate if $tiebreak_truncate;
			$json_tb->{truncate_smallest} = $tiebreak_truncate_smallest if $tiebreak_truncate_smallest;
			$json_tb->{multiplier}        = $tiebreak_multiplier if $tiebreak_multiplier;
			$json_tb->{child}             = $tiebreak_child if $tiebreak_child;

			push (@{$json_tbset->{tiebreaks}}, $json_tb);
		}
	}

	unless ($public || $event_id || $category_id) {

		# FINES FEES PAYMENTS

		my $fine_sth = $dbh->prepare("
			select
				fine.id, fine.reason, fine.amount, fine.payment, fine.levied_at, fine.levied_by,
				fine.deleted, fine.deleted_at, fine.deleted_by,
				fine.tourn, fine.school, fine.region, fine.judge, fine.parent, fine.invoice
			from fine
			where fine.tourn = ?
		");

		$fine_sth->execute($tourn->id);

		while (
			my (
				$fine_id, $fine_reason, $fine_amount, $fine_payment,
				$fine_levied_at, $fine_levied_by,
				$fine_deleted, $fine_deleted_at, $fine_deleted_by,
				$fine_tourn, $fine_school, $fine_region, $fine_judge,
				$fine_parent, $fine_invoice
			) = $fine_sth->fetchrow_array()
		) {

			next if ($school_id && ($school_id != $fine_school));

			my $json_fine = {
				id         => $fine_id,
				reason     => $fine_reason,
				amount     => $fine_amount,
				payment    => $fine_payment,
				levied_by  => $fine_levied_by,
				levied_at  => $fine_levied_at,
				deleted    => $fine_deleted,
				deleted_by => $fine_deleted_by,
				deleted_at => $fine_deleted_at,
				tourn      => $fine_tourn,
				school     => $fine_school,
				region     => $fine_region,
				judge      => $fine_judge,
				parent     => $fine_parent,
				invoice    => $fine_invoice,
			};

			push @{$json_tourn->{"fines"}}, $json_fine;
		}
	}

	unless ($event_id || $category_id || $school_id) {

		my $email_sth = $dbh->prepare("
			select
				email.id, email.subject, email.content, email.metadata,
				email.sent_to, email.sent_at, email.sender, email.tourn
			from email
			where email.tourn = ?
		");

		$email_sth->execute($tourn->id);

		while (
			my ($email_id, $email_subject, $email_content, $email_metadata,
				$email_sent_to, $email_sent_at, $email_sender, $email_tourn
			) = $email_sth->fetchrow_array()
		) {

			my $json_email = {
				id       => $email_id,
				subject  => $email_subject,
				content  => $email_content,
				metadata => $email_metadata,
				sent_to  => $email_sent_to,
				sent_at  => $email_sent_at,
				sender   => $email_sender,
			};

			push @{$json_tourn->{"emails"}}, $json_email;
		}

		my $webpage_sth = $dbh->prepare("
			select
				webpage.id, webpage.title, webpage.content, webpage.published,
				webpage.special, webpage.page_order,
				webpage.parent, webpage.last_editor
			from webpage
			where webpage.tourn = ?
		");

		$webpage_sth->execute($tourn->id);

		while (
			my (
				$webpage_id, $webpage_title, $webpage_content, $webpage_published,
				$webpage_special, $webpage_page_order,
				$webpage_parent, $webpage_last_editor
			) = $webpage_sth->fetchrow_array()
		) {

			my $json_webpage = {
				id          => $webpage_id,
				title       => $webpage_title,
				content     => $webpage_content,
				published   => $webpage_published,
				special     => $webpage_special,
				page_order  => $webpage_page_order,
				parent      => $webpage_parent,
				last_editor => $webpage_last_editor,
			};

			push @{$json_tourn->{"webpages"}}, $json_webpage;
		}

		my $concession_sth = $dbh->prepare("
			select
				concession.id, concession.name, concession.price, concession.description,
				concession.deadline, concession.cap, concession.school_cap, concession.billing_code,
				type.id, type.name, type.description,
				copt.id, copt.name, copt.description, copt.disabled
			from concession

				left join concession_type type on type.concession = concession.id
				left join concession_option copt on copt.concession_type = type.id
			where concession.tourn = ?
		");

		$concession_sth->execute($tourn->id);

		my %concession_by_id;
		my %ctype_by_id;

		#CONCESSION ORDERS

		while (
			my (

				$concession_id, $concession_name, $concession_price, $concession_description,
				$concession_deadline, $concession_cap, $concession_school_cap, $concession_billing_code,
				$type_id, $type_name, $type_description,
				$option_id, $option_name, $option_description, $option_disabled
			) = $concession_sth->fetchrow_array()
		) {

			my $json_concession = $concession_by_id{$concession_id};

			unless ($json_concession) {

				$json_concession = {
					id           => $concession_id,
					name         => $concession_name,
					price        => $concession_price,
					description  => $concession_description,
					deadline     => $concession_deadline,
					cap          => $concession_cap,
					school_cap   => $concession_school_cap,
					billing_code => $concession_billing_code,
				};

				$concession_by_id{$concession_id} = $json_concession;
				push @{$json_tourn->{concessions}}, $json_concession;
			}

			if ($type_id) {

				my $json_type = $ctype_by_id{$type_id};

				unless ($json_type) {
					$json_type = {
						id          => $type_id,
						name        => $type_name,
						description => $type_description
					};

					$ctype_by_id{$type_id} = $json_type;
					push @{$json_concession->{types}}, $json_type;
				}

				if ($option_id) {

					my $json_option = {
						id          => $option_id,
						name        => $option_name,
						description => $option_description,
						disabled    => $option_disabled,
					};

					push @{$json_type->{options}}, $json_option;
				}
			}
		}
	}

	$dbh->disconnect();

	$m->clear_buffer();
	$r->content_type('application/json');

	$file_name =~ s/[\W_]//g;

	my $filename = "Complete-".$tourn->name;
	$filename =~ s/[\W_]//g;
	$filename = $file_name."-".$filename if $file_name;
	$filename = $filename."-".$now->ymd('-')."-at-".$now->hms('-').".json";

	my $filedir = $Tab::file_root."tmp/".$session->id."/".$now->epoch."/";
	system "mkdir -p $filedir";
	my $filepath = $filedir."/".$filename;

	my $json = JSON->new->allow_nonref->convert_blessed;

#	Filepath method is MUCH faster with bulky files it so happens.

#	$r->content_type('application/json');
#	$r->headers_out->{'Content-Disposition'} = "attachment; filename=$filename";

#	Tab::debuglog("Filepath is $filepath");

	open my $fh, ">", $filepath;
	print $fh $json->pretty->encode($json_tourn);
	close $fh;

	$m->redirect("/tmp/".$session->id."/".$now->epoch."/".$filename);

#	$m->print($json->pretty->encode( $json_tourn ));

#	$m->flush_buffer();
#	$m->abort();

	sub setting_value {

		my $setting = shift;

		if ($setting->value eq "date") {
			return Tab::pickerdate($setting->value_date);
		} elsif ($setting->value eq "text") {
			return $setting->value_text;
		} elsif ($setting->value) {
			return $setting->value;
		} else {
			return 0;
		}
	}

	sub raw_value {

		my ($parent_sth, $args) = @_;
		$parent_sth->execute($args);

		my @settings;

		while (
			my (
				$object_id, $setting_id, $tag, $value, $value_date, $value_text
			) = $parent_sth->fetchrow_array()
		) {

			my $meta = "string";

			if ($value_date) {
				$value = $value_date;
				$meta = "date";
			} elsif ($value_text) {
				$value = $value_text;
				$meta = "text";
			}

			my $json_setting = {
				tag   => $tag,
				value => $value,
				meta  => $meta
			};

			push @settings, $json_setting;
		}

		$parent_sth->finish;
		return \@settings;
	}

</%init>
