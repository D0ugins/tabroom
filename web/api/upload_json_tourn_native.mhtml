<%args>
	$tourn_id
	$person_id
	$session_id
	$include_rooms => undef
</%args>

<%init>

unless ($tourn_id && $person_id && $session_id) {
	my $err = "Tournament restore aborted because essential information is missing";
	$m->redirect("/setup/tourn/main.mhtml?msg=$err");
}

########################################################################################
#		read local JSON file into a hash that goes { table }{ record }{ field }
#		This will work for a file generated by tabroom, and will delete everything that exists
#		and replace it with the backup file, id numbers and all.
#		(1) delete everything (2) remove permanent tables from the hash
#		(3) dump everything using insert commands back into the database
#########################################################################################

		#### STEP ONE: Load in the file
			#### This finds the file 

use strict;
use warnings;
use Data::Dumper; 
binmode STDOUT, ":utf8";
use utf8;
use DateTime;
use Time::HiRes qw( time );
my $start = time(); 

my $tourn = Tab::Tourn->retrieve($tourn_id);
my $person = Tab::Person->retrieve($person_id);
my $session = Tab::Session->retrieve($session_id);

my $tz = $tourn->tz if $tourn->tz;
$tz = "UTC" unless $tz;
	
my $dbh = Tab::DBI->db_Main();
use JSON;
use Encode qw(encode_utf8);

#upload sequence
my $now = DateTime->now;
$now->set_time_zone($tz);
my $req = Apache2::Request->new($r, DISABLE_UPLOADS => 0);
my $json_file = $req->upload('json_data');
unless ($json_file) { print $r." Couldn't find file<br>"; $m->abort };
my $json_filename = $json_file->tempname;
my $filename = $json_filename;

			#### This reads the file and converts the JSON to a hash called %data ###
		
my $json;
#my $filename = '/www/tabroom/web/register/data/NSDA.json';

{
  local $/; #Enable 'slurp' mode
  open my $fh, "<", $filename;
  $json = <$fh>;
  close $fh;
}

my $HashReferenceDecoded = decode_json($json);
my %data = %$HashReferenceDecoded;

print "Time to load JSON file into a hash:"; printf("%.2f\n", time() - $start) ; print "<br>";

#set up some global utility variables
my $sql;
my $ctr = 0;
my $matched;
my $new_rec;
my $sth = $dbh;

		### erase SCORE field from panel and judge in the $data hash -- they are just temporary things and don't need to be restored
		### This is just random cleanup

foreach my $rec (sort keys %{ $data{'judge'} } ) {
	delete $data{'judge'}{$rec}{'score'};
}
foreach my $rec (sort keys %{ $data{'panel'} } ) {
	delete $data{'panel'}{$rec}{'score'};
}

		#### STEP TWO: Delete everything associated with the tournament from the database

$m->comp("delete_tourn.mas", session => $session, include_rooms => $include_rooms, tourn => $tourn, person => $person);
print "Time to complete deletion:"; printf("%.2f\n", time() - $start) ; print "<br>";

	#### STEP THREE: Delete permanent tables from the hash

delete $data{'region'};
delete $data{'region_fine'};
delete $data{'circuit'};
delete $data{'site'};
delete $data{'chapter'};
delete $data{'district'};
delete $data{'person'};
delete $data{'student'};
delete $data{'tourn'};
delete $data{'room'} unless $include_rooms;

		#### STEP FOUR: Insert the records you want to restore in to the database with their original ID numbers

my $field_name;
my $field_str;

	foreach my $table (sort keys %data) {
	
		foreach my $rec (sort keys %{ $data{$table} }) {

			$ctr=0;
			my @field_values;
			foreach my $field (sort keys %{ $data{$table}{$rec} }) {
				if ( $ctr == 0 ) {
					$field_name = $field ;
					$field_str = "?" ;
				} else {
					$field_name = $field_name.", ".$field;
					$field_str = $field_str.", ?" ;
				}
				$field_values[$ctr] = $data{$table}{$rec}{$field};
				$field_values[$ctr] = $tourn_id if $field eq 'tourn' ;
				$ctr++;
			}
					
			$sql = 'INSERT INTO '.$table.' ('.$field_name.') VALUES ('.$field_str.')' ;
			my $sth = $dbh->prepare( $sql );
			$sth->execute(@field_values);
		}

	}

print "Time to create records:"; printf("%.2f\n", time() - $start) ; print "<br>";

#clean up the speaker tiebreak settings
foreach my $rec (sort keys %{ $data{'event_setting'} }) {
	if ( $data{'event_setting'}{$rec}{'tag'} eq 'speaker_tbset' ) {
		$sql = 'UPDATE event_setting SET value ='.$data{'tiebreak_set'}{ $data{'event_setting'}{$rec}{'value'} }{'id'}.' WHERE id='.$data{'event_setting'}{$rec}{'id'} ; 
		my $sth = $dbh->prepare( $sql ) ;
		$sth->execute();
		print $sql."<br>";
	}
}
print "Time to update speaker tiebreak sets:"; printf("%.2f\n", time() - $start) ; print "<br>";

#clean up times on timeslot strikes
foreach my $rec (sort keys %{ $data{'strike'} }) {
	if ( $data{'strike'}{$rec}{'strike_timeslot'}  ) {
		$sql = "UPDATE strike SET type ='time' WHERE id=".$data{'strike'}{$rec}{'id'} ;
		my $sth = $dbh->prepare( $sql ) ;
		$sth->execute();
		$sql = "UPDATE strike SET start ='".$data{'timeslot'}{ $data{'strike'}{$rec}{'strike_timeslot'} }{'start'}."' WHERE id=".$data{'strike'}{$rec}{'id'} ;
		$sth = $dbh->prepare( $sql ) ;
		$sth->execute();
		$sql = "UPDATE strike SET end ='".$data{'timeslot'}{ $data{'strike'}{$rec}{'strike_timeslot'} }{'end'}."' WHERE id=".$data{'strike'}{$rec}{'id'} ; 
		$sth = $dbh->prepare( $sql ) ;
		$sth->execute();
	}
}
print "Time to update times in timeslot_strikes:"; printf("%.2f\n", time() - $start) ; print "<br>";

print "And now we're done!";

my $err = "tourn ". $tourn->name ." has been completely deleted and restored from a backup (using the native backup function) by ".$person->first." ".$person->last;

my $change = Tab::ChangeLog->create({
    tourn       => $tourn->id,
    person      => $person->id,
    type        => "tabbing",
    description => $err

}); 

$m->redirect("/setup/tourn/main.mhtml?msg=Data restored");

</%init>