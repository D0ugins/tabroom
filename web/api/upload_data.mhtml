<%args>
	$username    => undef
	$password    => undef
	$session_id  => undef
	$tourn_id    => undef
	$event_id    => undef
	$school_id   => undef
	$category_id => undef
</%args>
<%init>

	use JSON -convert_blessed_universally;
	use Tab::NSDA::MemberSchool;

	my $dbh = Tab::DBI->db_Main();

	my ($person, $tourn) = $m->comp("login_api.mas",
		tourn_id   => $tourn_id,
		username   => $username,
		password   => $password,
		session_id => $session_id
	);

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	my $now = DateTime->now(time_zone => $tz);

    my $req     = Apache2::Request->new($r);
    my $upload  = $req->upload("tourn_data");
    my $io      = $upload->io;

    my $json = JSON->new->allow_nonref->convert_blessed;
	my $jdata = $json->decode($io);

	$m->flush_buffer();
	$m->print("<h5>Uploading data from file into ".$tourn->name."</h5>\n");

	my $timestamp = parse_date($jdata->{timestamp});

	$m->print("<p class='specific'>Data file was created on ");
	$m->comp("/funclib/showdt.mas", dt => $timestamp);
	$m->print(" by ".$jdata->{creator}."</p>");

	# Shared Database functions

	Tab::RoundSetting->set_sql(rm_all => "
		delete from round_setting where round = ?
	");

	Tab::TournSetting->set_sql(rm_all => "
		delete from tourn_setting where tourn = ?
	");

	Tab::CategorySetting->set_sql(
		rm_all => "delete from category_setting where category = ?"
	);

	Tab::EventSetting->set_sql(
		rm_all => "delete from event_setting where event = ?"
	);

	Tab::TiebreakSetSetting->set_sql(rm_all => "
		delete from tiebreak_set_setting where tb_set = ?
	");

	Tab::SchoolSetting->set_sql(rm_all => "
		delete from school_setting where school = ?
	");

	Tab::EntrySetting->set_sql(rm_all => "
		delete from entry_setting where entry = ?
	");

	Tab::JudgeSetting->set_sql(rm_all => "
		delete from judge_setting where judge = ?
	");

	Tab::Rating->set_sql(rm_all => "
		delete from rating where judge = ?
	");

	Tab::Score->set_sql(rm_all => "
		delete score.* from panel, ballot, score
		where panel.round = ?
			and panel.id = ballot.panel
			and ballot.id = score.ballot
	");

	Tab::Ballot->set_sql(rm_all => "
		delete ballot.* from panel, ballot
		where panel.round = ?
			and panel.id = ballot.panel
	");

	Tab::Panel->set_sql(rm_all => "
		delete * from panel where panel.round = ?
	");

	Tab::RoomStrike->set_sql( search_site => "
		select rs.*
		from room_strike rs, room
		where rs.room = room.id
			and room.site = ?
			and rs.tourn = ?
	");

	unless ($jdata->{event_only} || $jdata->{school_only}) {

		#TOURN DATA

		my $reg_start_dt = parse_date($jdata->{reg_start});
		my $reg_end_dt = parse_date($jdata->{reg_end});

		$m->print("<p class='action'> Updating tournament</p>");

		$tourn->name($jdata->{name}) if $jdata->{name};
		$tourn->tz($jdata->{tz}) if $jdata->{tz};
		$tourn->start($start_dt) if $start_dt;
		$tourn->end($end_dt) if $end_dt;
		$tourn->start($reg_start_dt) if $reg_start_dt;
		$tourn->end($reg_end_dt) if $reg_end_dt;

		$m->print("<p class='specific'>Loaded tournament data changes</p>");
		$tourn->update();

		#TOURN SETTINGS

		if ($jdata->{settings})  {

			$m->print("<p class='specific'> Loading ".scalar @{$jdata->{settings}}." tournament settings </p>");


			Tab::TournSetting->sql_rm_all->execute($tourn->id);

			foreach my $jsetting (@{$jdata->{settings}}) {
				my @reply = parse_setting($jsetting);
				$tourn->setting(@reply) if @reply;
			}
		}

	} elsif ($jdata->{event_only}) {
		$m->print("<p class='action'>Update event(s) only</p>");
	} elsif ($jdata->{school_only}) {
		$m->print("<p class='action'>Update school(s) only</p>");
	}

	my %translator;
	my @categories = $tourn->categories();
	my %category_by_id = map {$_->id => $_} @categories;
	my %category_by_name = map {$_->name => $_} @categories;
	my %category_by_abbr = map {$_->abbr => $_} @categories;

	unless ($jdata->{school_only}) {

		$m->print("<p class='action'> Importing ".scalar @{$jdata->{categories}}." judge categories </p>");


		# CATEGORY CATEGORIES
		foreach my $category (@{$jdata->{categories}}) {

			my $ocategory = $category_by_id{$category->{id}};

			$m->print("<p class='specific'> No category found for id ".$category->{id}." Trying abbr ".$category->{abbr}."</p>");
			$ocategory = $category_by_abbr{$category->{abbr}} unless $ocategory;

			$m->print("<p class='specific'> No category found for id ".$category->{id}." Trying name ".$category->{name}."</p>");
			$ocategory = $category_by_name{$category->{name}} unless $ocategory;

			if ($ocategory) {
				$ocategory->name($category->{name});
				$ocategory->abbr($category->{abbr});
				$ocategory->update();
			} else {

				$m->print("<p class='specific'> No category found for name ".$category->{name}." Creating</p>");
				$ocategory = Tab::Category->create({
					tourn => $tourn->id,
					name  => $category->{name},
					abbr  => $category->{abbr},
				});

			}

			$translator{category}{$category->{id}} = $ocategory;

			if ($category->{settings})  {
				$m->print("<p class='specific'> Loading ".scalar @{$category->{settings}}." categoryament settings </p>");

				Tab::CategorySetting->sql_rm_all->execute($ocategory->id);

				foreach my $jsetting (@{$category->{settings}}) {
					my @reply = parse_setting($jsetting);
					$ocategory->setting(@reply) if @reply;
				}
			}

			# PREFS AND PREF SHEETS
			my @rts = $ocategory->rating_tiers;
			my %rt_by_id = map {$_->id => $_} @rts;
			my %rt_by_name = map {$_->name => $_} @rts;

			# PREF TIERS
			foreach my $rt (@{$category->{rating_tiers}}) {

				my $ort = $rt_by_id{$rt->{id}};

				$m->print("<p class='specific'> No rating tier found for id ".$rt->{id}." Trying name ".$rt->{name}."</p>");
				$ort = $rt_by_name{$rt->{name}} unless $ort;

				unless ($ort) {
					$ort = Tab::RatingTier->create({
						category    => $ocategory->id,
						type        => $rt->{tag},
						name        => $rt->{name},
						description => $rt->{description},
						strike      => $rt->{strike},
						conflict    => $rt->{conflict},
						min         => $rt->{min},
						max         => $rt->{max},
						start       => $rt->{start},
					});

				} else {

					$ort->type($rt->{tag});
					$ort->name($rt->{name});
					$ort->description($rt->{description});
					$ort->strike($rt->{strike});
					$ort->conflict($rt->{conflict});
					$ort->min($rt->{min});
					$ort->max($rt->{max});
					$ort->start($rt->{start});
					$ort->update();

				}

				$translator{rating_tier}{$rt->{id}} = $ort;
			}

			my @rss = $ocategory->rating_subsets;
			my %rs_by_id = map {$_->id => $_} @rss;
			my %rs_by_name = map {$_->name => $_} @rss;

			#RATING SUBSETS
			foreach my $rs (@{$category->{rating_subsets}}) {
				my $ors = $rs_by_id{$rs->{id}};

				$m->print("<p class='specific'> No rating subset found for id ".$rs->{id}." Trying name ".$rs->{name}."</p>");
				$ors = $rs_by_name{$rs->{name}} unless $ors;

				unless ($ors) {
					$ors = Tab::RatingTier->create({
						category => $ocategory->id,
						name     => $rs->{name}
					});
				} else {
					$ors->name($rs->{name});
					$ors->update();
				}
				$translator{rating_subset}{$rs->{id}} = $ors;
			}

			# EVENTS
			if ($category->{events}) {

				my @events = $oevent->events();
				my %event_by_id = map {$_->id => $_} @events;
				my %event_by_name = map {$_->name => $_} @events;
				my %event_by_abbr = map {$_->abbr => $_} @events;

				$m->print("<p class='action'> Importing ".scalar @{$jdata->{events}}." events </p>");

				foreach my $event (@{$jdata->{events}}) {

					my $oevent = $event_by_id{$event->{id}};

					$m->print("<p class='specific'> No event found for id ".$event->{id}." Trying abbr ".$event->{abbr}."</p>");
					$oevent = $event_by_abbr{$event->{abbr}} unless $oevent;

					$m->print("<p class='specific'> No event found for id ".$event->{id}." Trying name ".$event->{name}."</p>");
					$oevent = $event_by_name{$event->{name}} unless $oevent;

					if ($oevent) {
						$oevent->name($event->{name});
						$oevent->abbr($event->{abbr});
						$oevent->update();
					} else {

						$m->print("<p class='specific'> No event found for name ".$event->{name}." Creating</p>");
						$oevent = Tab::Event->create({
							tourn    => $tourn->id,
							category => $ocategory->id,
							name     => $event->{name},
							abbr     => $event->{abbr},
							type     => $event->{type}
						});
					}

					if ($event->{rating_subset}) {
						$rs = $translator{rating_subset}{$event->{rating_subset}};
						$event->rating_subset($rs->id) if $rs;
					}

					if ($event->{pattern}) {
						$rs = $translator{pattern}{$event->{pattern}};
						$event->pattern($rs->id) if $rs;
					}

					$translator{event}{$event->{id}} = $oevent;

					if ($event->{settings})  {
						$m->print("<p class='specific'> Loading ".scalar @{$event->{settings}}." eventament settings </p>");

						Tab::EventSetting->sql_rm_all->execute($event->id);

						foreach my $jsetting (@{$event->{settings}}) {
							my @reply = parse_setting($jsetting);
							$event->setting(@reply) if @reply;
						}
					}
				}
			}
		}
	}

	#TIEBREAK SETS
	my @tb_sets = $tourn->tiebreak_sets;
	my %tb_set_by_id = map {$_->id => $_} @tb_sets;
	my %tb_set_by_name = map {$_->name => $_} @tb_sets;

	if ($jdata->{tiebreak_sets}) {

		foreach my $tb_set ($jdata->{tiebreak_sets}) {

			my $otb_set;
			$otb_set = $tb_set_by_id{$tb_set->id};

			unless ($otb_set) {
				$otb_set = $tb_set_by_name{$tb_set->name};
			}

			unless ($otb_set) {
				$otb_set = Tab::TiebreakSet->create({
					name  => $tb_set->{name},
					tourn => $tourn->id
				});
			} else {
				$otb_set->name($tb_set->{name});
				$otb_set->update();
			}

			$translator{tb_set}{$tb_set->{id}} = $otb_set;

			foreach my $tiebreak ($otb_set->tiebreaks) {
				$tiebreak->delete();
			}

			#TIEBREAK SET SETTINGS
			if ($tb_set->{settings})  {

				$m->print("<p class='specific'> Loading ".scalar @{$tb_set->{settings}}." tiebreak set settings </p>");


				Tab::TiebreakSetSetting->sql_rm_all->execute($tb_set->id);

				foreach my $jsetting (@{$tb_set->{settings}}) {
					my @reply = parse_setting($jsetting);
					$tb_set->setting(@reply) if @reply;
				}
			}
		}

		# TIEBREAKS

		# These are broken off to ensure that Child tiebreak sets with
		# derivative sets are available for translation

		foreach my $tb_set ($jdata->{tiebreak_sets}) {

			my $otb_set = $translator{tb_set}{$tb_set->{id}};

			foreach my $tiebreak (@{$tb_set->{tiebreaks}}) {

				my $child_set = $translator{tb_set}{$tiebreak->{child}};

				Tab::Tiebreak->create({
					tourn             => $tourn->id,
					name              => $tiebreak->{name},
					priority          => $tiebreak->{priority},
					count             => $tiebreak->{count},
					highlow_count     => $tiebreak->{highlow_count},
					count_round       => $tiebreak->{count_round},
					truncate          => $tiebreak->{truncate},
					truncate_smallest => $tiebreak->{truncate_smallest},
					multiplier        => $tiebreak->{multiplier},
					child             => $child_set
				});
			}
		}
	}

	#PATTERNS
	if ($jdata->{patterns}) {

		my @patterns = $tourn->patterns;
		my %pattern_by_id = map {$_->id => $_} @patterns;
		my %pattern_by_name = map {$_->name => $_} @patterns;

		foreach my $pattern ($jdata->{patterns}) {

			my $opattern;
			my $opattern;
			$opattern = $pattern_by_id{$pattern->id};

			unless ($opattern) {
				$opattern = $pattern_by_name{$pattern->name};
			}

			if ($opattern) {

				$opattern->name($pattern->{name});
				$opattern->type($pattern->{tag});
				$opattern->max($pattern->{max});
				$opattern->exclude($pattern->{exclude});
				$opattern->update();

			} else {
				$opattern = Tab::Pattern->create({
					tourn   => $tourn->id,
					name    => $pattern->{name},
					type    => $pattern->{tag},
					max     => $pattern->{max},
					exclude => $pattern->{exclude}
				});
			}

			$translator{pattern}{$pattern->{id}} = $opattern;
		}
	}

	#TIMESLOTS
	my @timeslots = $tourn->timeslots;
	my %timeslot_by_id = map {$_->id => $_} @timeslots;
	my %timeslot_by_name = map {$_->name => $_} @timeslots;

	if ($jdata->{timeslots}) {

		foreach my $timeslot ($jdata->{timeslots}) {

			my $otimeslot;
			$otimeslot = $timeslot_by_id{$timeslot->id};

			unless ($otimeslot) {
				$otimeslot = $timeslot_by_name{$timeslot->name};
			}

			my $start = parse_date($timeslot->{start});
			my $end = parse_date($timeslot->{end});

			unless ($otimeslot) {
				$otimeslot = Tab::Timeslot->create({
					name  => $timeslot->{name},
					tourn => $tourn->id,
					start => $start,
					end   => $end
				});
			} else {
				$otimeslot->name($timeslot->{name});
				$otimeslot->start($timeslot->{start});
				$otimeslot->end($timeslot->{end});
				$otimeslot->update();
			}

			$translator{timeslot}{$timeslot->{id}} = $otimeslot;
		}
	}

	my $default_site;

	# SITES
	my @sites = $tourn->sites;
	my %site_by_id = map {$_->id => $_} @sites;
	my %site_by_name = map {$_->name => $_} @sites;

	if ($jdata->{sites}) {

		foreach my $site (@{$jdata->{sites}}) {

			my $osite;
			$osite = $site_by_id{$site->id};

			unless ($osite) {
				$osite = $site_by_name{$site->name};
			}

			if ($osite) {
				$osite->name($site->{name});
				$osite->update();
			} else {
				$osite = Tab::Site->create({
					name => $site->{name},
					circuit => $tourn->circuits->first
				});
			}

			$translator{site}{$site->{id}} = $osite;
			$default_site = $osite unless $default_site;

			# ROOMS
			foreach my $room ($site->{rooms}) {

				my @rooms = $osite->rooms;
				my %room_by_id = map {$_->id => $_} @rooms;
				my %room_by_name = map {$_->name => $_} @rooms;

				my $oroom;
				$oroom = $room_by_id{$room->id};

				unless ($oroom) {
					$oroom = $room_by_name{$room->name};
				}

				if ($oroom) {

					$oroom->name($room->{name});
					$oroom->rows($room->{rows});
					$oroom->seats($room->{seats});
					$oroom->ada($room->{ada});
					$oroom->inactive($room->{inactive});

					$oroom->quality($room->{quality});
					$oroom->capacity($room->{capacity});
					$oroom->notes($room->{notes});
					$oroom->url($room->{url});

				} else {

					$oroom = Tab::Room->create({
						site     => $osite->id,
						name     => $room->{name},
						rows     => $room->{rows},
						seats    => $room->{seats},
						ada      => $room->{ada},
						inactive => $room->{inactive},
						quality  => $room->{quality},
						capacity => $room->{capacity},
						notes    => $room->{notes},
						url      => $room->{url},
					});
				}
			}
		}
	} else {

		$default_site = $sites[0];

	}

	# WEEKENDS
	my @weekends = $tourn->weekends;
	my %weekend_by_id = map {$_->id => $_} @weekends;
	my %weekend_by_name = map {$_->name => $_} @weekends;

	if ($jdata->{weekends}) {
		foreach my $weekend (@{$jdata->{weekends}}) {

			my $oweekend;
			$oweekend = $weekend_by_id{$weekend->id};

			unless ($oweekend) {
				$oweekend = $weekend_by_name{$weekend->name};
			}

			my $start          = parse_date($site->{start});
			my $end            = parse_date($site->{end});
			my $reg_start      = parse_date($site->{reg_start});
			my $reg_end        = parse_date($site->{reg_end});
			my $fine_deadline  = parse_date($site->{fine_deadline});
			my $judge_deadline = parse_date($site->{judge_deadline});
			my $drop_deadline  = parse_date($site->{drop_deadline});

			if ($oweekend) {

				$oweekend->end($end);
				$oweekend->start($start);
				$oweekend->reg_end($reg_end);
				$oweekend->reg_start($reg_start);
				$oweekend->drop_deadline($drop_deadline);
				$oweekend->freeze_deadline($freeze_deadline);
				$oweekend->judge_deadline($judge_deadline);
				$oweekend->fine_deadline($fine_deadline);

			} else {

				$oweekend = Tab::Weekend->create({
					end             => $end,
					start           => $start,
					reg_end         => $reg_end,
					reg_start       => $reg_start,
					drop_deadline   => $drop_deadline,
					freeze_deadline => $freeze_deadline,
					judge_deadline  => $judge_deadline,
					fine_deadline   => $fine_deadline,
				});
			}

			$translator{weekend}{$weekend->{id}} = $oweekend;
		}
	}

	# REGIONS
	my @regions = $tourn->regions;
	my %region_by_id = map {$_->id => $_} @regions;
	my %region_by_name = map {$_->name => $_} @regions;
	my %region_by_code = map {$_->code => $_} @regions;

	if ($jdata->{regions}) {

		foreach my $region (@{$jdata->{regions}}) {

			my $oregion;
			$oregion = $region_by_id{$region->{id}};

			unless ($oregion) {
				$oregion = $region_by_code{$region->{code}};
			}

			unless ($oregion) {
				$oregion = $region_by_name{$region->{name}};
			}

			unless ($oregion) {

				$oregion = Tab::Region->create({
					tourn     => $tourn->id,
					name      => $region->{name},
					code      => $region->{code},
					quota     => $region->{quota},
					arch      => $region->{arch},
					cooke_pts => $region->{cooke_points},
					sweeps    => $region->{sweeps},
					circuit   => $region->{circuit},
				});

			} else {

				 $oregion->name($region->{name});
				 $oregion->code($region->{code});
				 $oregion->quota($region->{quota});
				 $oregion->arch($region->{arch});
				 $oregion->cooke_pts($region->{cooke_points});
				 $oregion->sweeps($region->{sweeps});
				 $oregion->circuit($region->{circuit});
				 $oregion->update();
			}

			$translator{region}{$region->{id}} = $oregion;
		}
	}

	my @schools = $tourn->schools;
	my %school_by_id = map {$_->id => $_} @schools;
	my %school_by_name = map {$_->name => $_} @schools;

	if ($jdata->{schools} && (not defined $jdata->{event_only})) {

		$m->print("<p class='action'> Importing ".scalar @{$jdata->{schools}}." school registrations</p>");

		# SCHOOLS
		foreach my $school (@{$jdata->{schools}}) {

			my $oschool;
			$oschool = $school_by_id{$school->id};
			my $chapter;

			unless ($oschool) {
				$oschool = $school_by_name{$school->name};
			}

			my $region = $translator{region}{$school->{region}};

			if ($oschool) {

				$m->print("<p class='specific'> School $school found for ".$school->{id}." </p>");

				$oschool->name($school->{name});
				$oschool->code($school->{code});
				$oschool->onsite($school->{onsite});
				$oschool->region($region);
				$oschool->district($school->{district});
				$oschool->update();

				$chapter = $oschool->chapter;

				if ($chapter) {
					if ($school->{nsda} && (not defined $chapter->nsda)) {
						$chapter->nsda($school->{nsda});
						$chapter->update();
					}
				}

			} else {

				$m->print("<p class='specific'> No School $school found for ".$school->{id}." ".$school->{name}." Creating:</p>");

				$chapter = Tab::Chapter->retrieve($school->{chapter})
					if $school->{chapter};

				if ((not defined $chapter) && $school->{nsda}) {

					$chapter = Tab::Chapter->search(nsda => $school->{nsda})->first;

					unless ($chapter) {
						my $nsda_school = Tab::NSDA::MemberSchool->search(
							school_id => $school->{nsda}
						)->first;

						$m->print("<p class='specific'>No chapter with NSDA ID ".$school->{nsda}." found.  Importing from NSDA DB</p>");
						if ($nsda_school) {
							$chapter = $m->comp(
								"/funclib/chapter_import.mas",
									nsda_school => $nsda_school,
									person      => $person,
									nome        => "yup"
							);
						}
					}

					unless ($chapter) {

						$chapter = Tab::Chapter->create({
							name => $school->{name}
						});

						$m->print("<p class='specific'>No chapter with name ".$school->{name}." or NSDA ID ".$school->{nsda}." found.  Created $chapter</p>");
					}
				}

				my %data;

				if ($chapter) {
					$data{chapter} = $chapter->id;
					$data{state} = $chapter->state;
				}

				$oschool->create({
					tourn    => $tourn->id,
					chapter  => $data{chapter},
					state    => $data{state},
					name     => $school->{name},
					code     => $school->{code},
					region   => $school->{region},
					district => $school->{district},
				});

				$m->print("<p class='specific'>Created school $school with $chapter</p>");
			}

			$translator{school}{$school->{id}} = $oschool->id;

			if ($oschool) {

				#SCHOOL SETTINGS
				if ($school->{settings})  {
					$m->print("<p class='specific'> Loading ".scalar @{$school->{settings}}." school settings </p>");


					Tab::SchoolSetting->sql_rm_all->execute($school->id);

					foreach my $jsetting (@{$school->{settings}}) {
						my @reply = parse_setting($jsetting);
						$school->setting(@reply) if @reply;
					}
				}

				# STUDENTS
				my @students = $chapter->students();
				my %students_by_id = map {$_->id => $_} @students;
				my %students_by_nsda = map {$_->nsda => $_} @students;
				my %students_by_name = map {$_->first."-".$_->last => $_} @students;

				foreach my $student (@{$school->{students}}) {

					my $ostudent;
					$ostudent = $student_by_id{$student->{id}};
					$ostudent = $student_by_nsda{$student->{nsda}} unless $ostudent;
					$ostudent = $student_by_name{$student->{first}." ".$student->{last}} unless $ostudent;

					unless ($ostudent) {
						$ostudent->create({
							chapter => $chapter->id,
							first   => $student->{first},
							last    => $student->{last},
							middle  => $student->{middle},
							nsda    => $student->{nsda}
						});

						$student_by_id{$ostudent->id} = $ostudent;
						$student_by_nsda{$ostudent->nsda} = $ostudent;
						$student_by_name{$ostudent->first."-".$ostudent->last} = $ostudent;

					} else {

						$ostudent->first($student->{first});
						$ostudent->last($student->{last});
						$ostudent->middle($student->{middle});
						$ostudent->nsda($student->{nsda});
						$ostudent->update();
						$student_by_id{$ostudent->id} = $ostudent;
					}

					$translator{"student"}{$student->{id}} = $ostudent;
				}

				# ENTRIES

				$m->print("<p class='action'>".$school->name." has ".scalar @{$school->{entries}}." entries</p>");
				my $created;
				my $found;

				foreach my $category (@{$jdata->{categories}}) {

					# Done by event to catch double entries with the same code & name
					foreach my $event (@{$jdata->{events}}) {

						my $oevent = $translator{event}{$entry->{event}};

						my @entries = $oschool->entries(event => $oevent->id);
						my %entry_by_id = map {$_->id => $_} @entries;
						my %entry_by_name = map {$_->name => $_} @entries;
						my %entry_by_code = map {$_->code => $_} @entries;

						foreach my $entry (@{$school->{entries}}) {

							next unless $entry->{event} == $event->{id};

							my $oentry;
							$oentry = $entry_by_id{$entry->{id}};
							$oentry = $entry_by_name{$entry->{name}} unless $oentry;
							$oentry = $entry_by_code{$entry->{code}} unless $oentry;

							unless ($oentry) {
								$oentry = Tab::Entry->create({
									event => $event->id,
									name  => $entry->{name},
									code  => $entry->{code},
									ada   => $entry->{ada}
								});

								$entry_by_id{$oentry->id} = $oentry;
								$entry_by_name{$oentry->name} = $oentry;
								$entry_by_code{$oentry->code} = $oentry;
								$created++;

							} else {
								$found++;
								$oentry->name($entry->{name});
								$oentry->code($entry->{code});
								$oentry->event($event->id);
								$oentry->update();
							}

							$translator{"entry"}{$entry->{id}} = $oentry;

							#ENTRY SETTINGS

							if ($entry->{settings})  {
								$m->print("<p class='specific'> Loading ".scalar @{$entry->{settings}}." entry settings </p>");

								Tab::EntrySetting->sql_rm_all->execute($entry->id);
								foreach my $jsetting (@{$entry->{settings}}) {
									my @reply = parse_setting($jsetting);
									$entry->setting(@reply) if @reply;
								}
							}

							#ENTRY STUDENTS
							my @es = Tab::EntryStudent->search( entry => $entry->id);
							my %esen = map {$_->student->id => $_} @es;

							foreach my $student_id (@{$entry->{students}}) {
								my $translated = $translator{student}{$student_id};

								if ($esen{$translated->id}) {
									delete $esen{$translated->id};
								} else {
									Tab::EntryStudent->create({
										entry   => $oentry->id,
										student => $translated->id
									});
								}
							}
						}
					}
				}

				# SCHOOL JUDGES

				# Ordinarily the judges are stored with the categories to
				# account for neutral/hired judges but if you are importing a
				# school on its own this includes the judges here.

				if ($school->{judges}) {

					my @chapter_judges;
					if ($oschool->chapter) {
						@chapter_judges = $oschool->chapter->chapter_judges();
					}

					my %cjs_by_id = map {$_->id => $_} @chapter_judges;
					my %cjs_by_person = map {$_->person => $_} @chapter_judges;
					my %cjs_by_nsda = map {$_->nsda => $_} @chapter_judges;
					my %cjs_by_name = map {$_->first."-".$_->last => $_} @chapter_judges;

					foreach my $category (@{$jdata->{categories}}) {

						my $ocategory = $translator{category}{$category->{id}};

						my @judges = $oschool->judges( category => $ocategory->id);

						my %judges_by_id = map {$_->id => $_} @judges;
						my %judges_by_person = map {$_->person => $_} @judges;
						my %judges_by_name = map {$_->first."-".$_->last => $_} @judges;
						my %judges_by_nsda;

						foreach my $judge (@judges) {
							next unless $judge->chapter_judge > 0;
							next unless $judge->chapter_judge->nsda > 0;
							$judges_by_nsda{$judge->chapter_judge->nsda} = $judge;
						}

						foreach my $judge (@{$school->{judges}}) {

							next unless $judge->{category} == $category->{id};

							my $ojudge = $judges_by_id{$judge->{id}};

							unless ($ojudge) {
								$ojudge = $judges_by_person{$judge->{person}}
									if $judge->{person} > 0;
							}

							unless ($ojudge) {
								$ojudge = $judges_by_nsda{$judge->{nsda}}
									if $judge->{nsda} > 0;
							}

							unless ($ojudge) {
								$ojudge = $judges_by_name{$judge->{name}};
							}

							# Chapter Judge link if possible

							my $ocj;

							$ocj = $ojudge->chapter_judge if $ojudge && $ojudge->chapter_judge > 0;

							unless ($ocj) {
								$ocj = $cjs_by_id{$judge->{chapter_judge}};
								$ocj = $cjs_by_person{$judge->{person}} unless $ocj;
								$ocj = $cjs_by_nsda{$judge->{nsda}} unless $ocj;
								$ocj = $cjs_by_name{$judge->{first}."-".$judge->{last}} unless $ocj;
							}

							#nulls, whiny nulls.
							foreach my $flag ("active", "ada", "school", "person") {
								$judge->{$flag} = 0 unless $judge->{$flag} > 0;
							}

							unless ($ojudge) {

								$ojudge->create({
									code          => $judge->{code},
									middle        => $judge->{middle},
									first         => $judge->{first},
									last          => $judge->{last},
									nsda          => $judge->{nsda},
									category      => $judge->{category},
									alt_category  => $judge->{alt_category},
									covers        => $judge->{covers},
									active        => $judge->{active},
									ada           => $judge->{ada},
									obligation    => $judge->{obligation},
									hired         => $judge->{hired},
									school        => $judge->{school},
									chapter_judge => $ocj
								});

							} else {

								$ojudge->code($judge->{code});
								$ojudge->middle($judge->{middle});
								$ojudge->first($judge->{first});
								$ojudge->last($judge->{last});
								$ojudge->nsda($judge->{nsda});
								$ojudge->category($judge->{category});
								$ojudge->alt_category($judge->{alt_category});
								$ojudge->covers($judge->{covers});
								$ojudge->active($judge->{active});
								$ojudge->ada($judge->{ada});
								$ojudge->obligation($judge->{obligation});
								$ojudge->hired($judge->{hired});
								$ojudge->school($judge->{school});
								$ojudge->chapter_judge($ocj);

								$ojudge->update();
							}

							$translator{"judge"}{$judge->{id}} = $ojudge;

							#SCHOOL JUDGE SETTINGS

							Tab::JudgeSetting->sql_rm_all->execute($judge->id);

							if ($judge->{settings})  {

								$m->print("<p class='specific'> Loading ".scalar @{$judge->{settings}}." judge settings </p>");
								$m->flush_buffer();

								foreach my $jsetting (@{$judge->{settings}}) {
									my @reply = parse_setting($jsetting);
									eval{$judge->setting(@reply)}; if @reply;
								}
							}

							# PREFS
							Tab::Rating->sql_rm_all->execute($judge->id);

							if ($judge->{ratings}) {

								foreach my $rating (@{$judge->{ratings}}) {

									my $entry = $translator{entry}{$entry->{entry}};
									my $school = $translator{school}{$school->{school}};

									next unless ($entry || $school);

									my $tier = $translator{rating_tier}{$judge->{rating_tier}};
									$tier = 0 unless $tier > 0;
									my $subset = $translator{rating_subset}{$judge->{rating_subset}};

									next unless ($tier > 0 || $ordinal > 0);

									foreach my $key ("draft", "ordinal") {
										$rating->{$key} = 0 unless $rating->{$key} > 0;
									}

									Tab::Rating->create({
										type        => $rating->{tag},
										draft       => $rating->{draft},
										entered     => $rating->{entered},
										ordinal     => $rating->{ordinal},
										percentile  => $rating->{percentile},
										rating_tier => $tier,
										tourn       => $tourn,
										entry       => $entry,
										judge       => $judge,
										school      => $school,
										subset      => $subset
									});
								}
							}

                        id    => $rating_id,
                        tag   => $rating_type,
                        judge => $rating_judge
                    };

                    $json_rating->{rating_subset} = $rating_rating_subset if $rating_rating_subset;
                    $json_rating->{draft} = $rating_draft if $rating_draft;
                    $json_rating->{school} = $rating_school if $rating_school;
                    $json_rating->{entry} = $rating_entry if $rating_entry;
                    $json_rating->{entered} = $rating_entered if $rating_entered;

                    if ($rating_tier_name) {
                        $json_rating->{rating} = $rating_tier_name;
                        $json_rating->{rating_tier} = $rating_rating_tier;
                    } else {
                        $json_rating->{rating} = $rating_ordinal;
                        $json_rating->{percentile} = $rating_percentile;
                    }




							}

						}
					}
				}
			}
		}
	}

	# FINES FEES AND PAYMENTS
	if ($jdata->{fines}) {

		my @fines = $tourn->fines;
		my %fine_by_id = map {$_->id => $_} @fines;
		my %fine_by_school_reason = map {$_->school."-".$_->reason => $_} @fines;

		foreach my $fine (@{$jdata->{fines}}) {

			my $school = $translator{school}{$fine->{school}};
			my $region = $translator{region}{$fine->{region}};
			my $judge  = $translator{judge}{$fine->{judge}};

			my $ofine = $fine_by_id{$fine->{id}};

			unless ($ofine) {
				$ofine = $fine_by_school_reason{$fine->{school}."-".$fine->{reason}};
			}

			$fine->{deleted} = 0 unless $fine->{deleted};
			$fine->{payment} = 0 unless $fine->{payment};

			unless ($ofine) {

				$ofine = Tab::Fine->create({
					reason     => $fine->{reason},
					amount     => $fine->{amount},
					payment    => $fine->{payment},
					levied_by  => $fine->{levied_by},
					levied_at  => $fine->{levied_at},
					deleted    => $fine->{deleted},
					deleted_by => $fine->{deleted_by},
					deleted_at => $fine->{deleted_at},
					tourn      => $tourn->id,
					school     => $school,
					region     => $region,
					judge      => $judge,
					invoice    => $fine->{invoice}
				});

			} else {

				$ofine->reason($fine->{reason});
				$ofine->amount($fine->{amount});
				$ofine->payment($fine->{payment});
				$ofine->levied_by($fine->{levied_by});
				$ofine->levied_at(DateTime::Format::MySQL->parse_datetime($fine->{levied_at}));
				$ofine->deleted($fine->{deleted});
				$ofine->deleted_by($fine->{deleted_by});
				$ofine->deleted_at(DateTime::Format::MySQL->parse_datetime($fine->{deleted_at}));
				$ofine->tourn($tourn));
				$ofine->school($school));
				$ofine->region($regoin));
				$ofine->judge($judge));
				$ofine->invoice($fine->{invoice});
				$ofine->update();
			}

			$translator{fine}{$fine->{id}} = $ofine;
		}

		foreach my $fine (@{$jdata->{fines}}) {
			next unless $fine->{parent};
			my $ofine = $translator{fine}{$fine->{id}};
			my $oparent = $translator{fine}{$fine->{parent}};
			$ofine->parent($oparent);
			$ofine->update();
		}
	}

	#EMAILS
	if ($jdata->{emails}) {

		my @emails = $tourn->emails;
		my %email_by_id = map {$_->id => $_} @emails;
		my %email_by_subject = map {$_->subject => $_} @emails;

		foreach my $email (@{$jdata->{emails}}) {

			my $oemail = $email_by_id{$email->{id}};

			unless ($oemail) {
				$oemail = $email_by_subject{$email->{subject}};
			}

			unless ($oemail) {

				$oemail = Tab::Email->create({
					tourn    => $tourn->id,
					subject  => $email->{subject},
					content  => $email->{content},
					metadata => $email->{metadata},
					sent_to  => $email->{sent_to},
					sent_at  => $email->{sent_at},
					sender   => $email->{sender}
				});

			} else {

				$oemail->subject($email->{subject});
				$oemail->content($email->{content});
				$oemail->metadata($email->{metadata});
				$oemail->sent_to($email->{sent_to});
				$oemail->sent_at($email->{sent_at});
				$oemail->sender($email->{sender});
				$oemail->update();
			}
		}
	}

	#EMAILS
	if ($jdata->{webpages}) {

		my @webpages = $tourn->webpages;
		my %webpage_by_id = map {$_->id => $_} @webpages;
		my %webpage_by_subject = map {$_->subject => $_} @webpages;

		foreach my $webpage (@{$jdata->{webpages}}) {

			my $owebpage = $webpage_by_id{$webpage->{id}};

			unless ($owebpage) {
				$owebpage = $webpage_by_subject{$webpage->{subject}};
			}

			$webpage->{published} = 0 unless $webpage->{published};

			unless ($owebpage) {

				$owebpage = Tab::Webpage->create({
					tourn       => $tourn->id,
					title       => $webpage->{title},
					content     => $webpage->{content},
					published   => $webpage->{published},
					special     => $webpage->{special},
					page_order  => $webpage->{page_order},
					last_editor => $webpage->{last_editor},
				});

			} else {

				$owebpage->title($webpage->{title});
				$owebpage->content($webpage->{content});
				$owebpage->published($webpage->{published});
				$owebpage->special($webpage->{special});
				$owebpage->page_order($webpage->{page_order});
				$owebpage->last_editor($webpage->{last_editor});
				$owebpage->update();
			}

			$translator{webpage}{$webpage->{id}} = $owebpage;
		}

		foreach my $webpage (@{$jdata->{webpages}}) {
			next unless $webpage->{parent};
			my $owebpage = $translator{webpage}{$webpage->{id}};
			my $oparent = $translator{webpage}{$webpage->{parent}};
			$owebpage->parent($oparent);
			$owebpage->update();
		}
	}

	# EVENTS PART DEUX: ROUNDS AND RESULTS
	if ($jdata->{events} && (not defined $jdata->{school_only})) {

		CATEGORY:
		foreach my $category (@{$jdata->{categories}}) {

			my $ocategory = $translator{category}{$category->{id}};

			unless ($oevent) {
				$m->print("<p class='error'> No category found for ID ".$category->{id}."?  Error in data, skipping</p>");
				next CATEGORY;
			}

			EVENT:
			foreach my $event (@{$category->{events}}) {

				my $oevent = $translator{event}{$event->{id}};

				unless ($oevent) {
					$m->print("<p class='error'> No event found for ID ".$event->{id}."?  Error in data, skipping</p>");
					next EVENT;

				}

				$m->print("<p class='action'> Importing ".scalar @{$event->{rounds}}." rounds in ".$oevent->name." </p>");
				$m->flush_buffer();

				my %rounds_by_name = map {$_->name => $_} $event->rounds;

				ROUND:
				foreach my $round ($event->{rounds}) {

					my $oround;
					$oround = $round_by_name{$round->{name}};

					my $site = $translator{site}{$round->{site}};
					$site = $default_site unless $site;

					my $timeslot = $translator{timeslot}{$round->{timeslot}};
					unless ($timeslot) {
						$m->print("<p class='error'> No timeslot found for ID ".$round->{timeslot}."?  Error in data, skipping round ".$round->{name}."</p>");
						next ROUND;
					}

					my $tb_set = $translator{tiebreak_set}{$round->{tiebreak_set}};

					#This facilitates importing foreign Districts results from Speechwire
					unless ($tb_set) {
						$tb_set = $tb_set_by_name{$round->{tiebreak_set_name}};
					}
					unless ($tb_set) {
						$m->print("<p class='error'> No tiebreak set found for ID ".$round->{tb_set}."?  Error in data, skipping round ".$round->{name}."</p>");
						next ROUND;
					}

					if ($oround) {

						$oround->id($round->{id});
						$oround->type($round->{type});
						$oround->name($round->{name});
						$oround->published($round->{published});
						$oround->results($round->{results});
						$oround->timeslot($timeslot->id);
						$oround->created($round->{created});
						$oround->start_time($round->{start});
						$oround->site($round->{site});
						$oround->label($round->{label});
						$oround->flights($round->{flighted});
						$oround->tiebreak_set($tb_set);

					} else {

						$oround = Tab::Round->create({
							id           => $round->{id},
							type         => $round->{type},
							name         => $round->{name},
							published    => $round->{published},
							results      => $round->{results},
							timeslot     => $timeslot->id,
							created      => $round->{created},
							start_time   => $round->{start},
							site         => $round->{site},
							label        => $round->{label},
							flights      => $round->{flighted},
							tiebreak_set => $tb_set->id,
						});
					}

					$m->print("<p class='action'> Importing ".scalar @{$event->{rounds}}." rounds in ".$oevent->name." </p>");

					if ($round->{settings}) {

						$m->print("<p class='specific'> Loading ".scalar @{$round->{settings}}." round settings </p>");


						Tab::RoundSetting->sql_rm_all->execute($round->id);

						foreach my $jsetting (@{$round->{settings}}) {
							my @reply = parse_setting($jsetting);
							$round->setting(@reply) if @reply;
						}
					}


					Tab::Score->sql_rm_all->execute($oround->id);
					Tab::Ballot->sql_rm_all->execute($oround->id);
					Tab::Panel->sql_rm_all->execute($oround->id);

					#SECTIONS PANELS AND FUN
					if ($round->{sections}) {

						foreach my $section (@{$round->{sections}}) {

							my $room = $translator{room}{$section->{room}};

							unless ($room) {
								$room = $room_by_id{$section->{room}};
							}

							# Also to help foreign imports and Speechwire
							unless ($room) {
								$room = $room_by_id{$section->{room_name}};
							}

							unless ($room) {
								if ($room_by_id{$section->{room_name}}) {
									$room = Tab::Room->create({
										site     => $site->id,
										name     => $section->{room_name}
										ada      => 0,
										inactive => 0
									});
								}
							}

							my $flight = if $section->{flight};
							$flight = 1 unless $flight;

							my $osection = Tab::Panel->create({
								room   => $room,
								round  => $oround,
								letter => $section->{letter},
								flight => $flight
							});

							$osection->bye($section->{bye}) if $section->{bye};
							$osection->publish($section->{publish}) if $section->{publish};
							$osection->bracket($section->{bracket}) if $section->{bracket};
							$osection->update();

							if ($section->{ballots}) {

								foreach my $ballot (@{$section->{ballots}}) {

									my $entry = $translator{entry}{$ballot->{entry}};
									next unless $entry;

									my $judge = $translator{judge}{$ballot->{judge}};

									my $side = $ballot->{side};
									$side    = 0 unless $side;

									my $speakerorder = $ballot->{speakerorder};
									$speakerorder    = 0 unless $speakerorder;

									my $chair = $ballot->{chair};
									$chair    = 0 unless $chair;

									my $bye = $ballot->{bye};
									$bye    = 0 unless $bye;

									my $forfeit = $ballot->{forfeit};
									$forfeit    = 0 unless $forfeit;

									my $oballot = Tab::Ballot->create({
										panel        => $osection->id,
										entry        => $entry,
										judge        => $judge,
										side         => $side,
										speakerorder => $speakerorder,
										bye          => $bye,
										chair        => $chair,
										audit        => $audit,
										forfeit      => $forfeit
									});

									if ($ballot->{scores}) {

										foreach my $score (@{$ballot->{scores}}) {

											next unless defined $score->{value};

											my $oscore = Tab::Score->create({
												ballot   => $oballot->id,
												tag      => $score->{tag},
												value    => $score->{value},
												speaker  => $score->{speaker},
												speech   => $score->{speech},
												topic    => $score->{topic},
												position => $score->{position}
											});
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	my %room_by_name;
	my %room_by_id;

	foreach my $site (@{$jdata->{sites}}) {

		my $osite = $translator{site}{$site->{id}};
		next unless $osite;

		my @blocks = Tab::RoomStrike->search_site( $osite->id, $tourn->id);
		my %block_by_id = map {$_->id => $_} @blocks;

		foreach my $block ($site->{blocks}) {

			my $oblock;
			$oblock = $block_by_id{$block->{id}};

			if ($oblock) {
				$oblock->type($block->{tag});
				$oblock->room($block->{room});
			} else {
				$oblock = Tab::RoomStrike->create({
					type => $block->{tag},
					room => $block->{room},
				});
			}

			if ($block->{start} && $block->{end}) {
				my $start_dt = parse_date($block->{start});
				my $end_dt = parse_date($block->{end});
			}

			$oblock->start($start_dt);
			$oblock->end($end_dt);

			foreach my $key ("event", "judge", "entry") {
				if ($block->{$key}) {
					my $obj = $translator{$key}{$block->{$key}};
					$oblock->$key($obj->id) if $obj > 0;
				}
			}
			$oblock->update();
		}

	} else {

		my @all_rooms;

		foreach my $site ($tourn->sites) {
			push @all_rooms, $site->rooms;
		}

		%room_by_id = map {$_->id => $_} @all_rooms;
		%room_by_name = map {$_->name => $_} @all_rooms;
	}

	sub parse_date {
		my $string = shift;
		return eval {
			return DateTime::Format::MySQL->parse_datetime($string);
		};
	}

	sub parse_setting {
		my $json_ref = shift;
		if ($json_ref->{meta} eq "date") {
			my $dt = parse_date($json_ref->{value});
			return unless $dt;
			return ($json_ref->{tag}, $json_ref->{meta}, $dt);
		} elsif ($json_ref->{meta} eq "text") {
			return ($json_ref->{tag}, $json_ref->{meta}, $json_ref->{value});
		} else {
			return ($json_ref->{tag}, $json_ref->{value});
		}
	}

</%init>
