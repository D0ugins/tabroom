<%args>
	$username    => undef
	$password    => undef
	$session_id  => undef
	$tourn_id    => undef
	$event_id    => undef
	$school_id   => undef
	$category_id => undef
</%args>
<%init>

	use JSON -convert_blessed_universally;
	use Tab::NSDA::MemberSchool;

	my $dbh = Tab::DBI->db_Main();

	my ($person, $tourn) = $m->comp("login_api.mas",
		tourn_id   => $tourn_id,
		username   => $username,
		password   => $password,
		session_id => $session_id
	);

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	my $now = DateTime->now(time_zone => $tz);

    my $req     = Apache2::Request->new($r);
    my $upload  = $req->upload("tourn_data");
    my $io      = $upload->io;

    my $json = JSON->new->allow_nonref->convert_blessed;
	my $jdata = $json->decode($io);

	$m->flush_buffer();
	$m->print("<h5>Uploading data from file into ".$tourn->name."</h5>\n");

	my $timestamp = parse_date($jdata->{timestamp});

	$m->print("<p class='specific'>Data file was created on ");
	$m->comp("/funclib/showdt.mas", dt => $timestamp);
	$m->print(" by ".$jdata->{creator}."</p>");

	unless ($jdata->{event_only} || $jdata->{school_only}) {

		#TOURN DATA

		my $reg_start_dt = parse_date($jdata->{reg_start});
		my $reg_end_dt = parse_date($jdata->{reg_end});

		$m->print("<p class='action'> Updating tournament</p>");

		$tourn->name($jdata->{name}) if $jdata->{name};
		$tourn->tz($jdata->{tz}) if $jdata->{tz};
		$tourn->start($start_dt) if $start_dt;
		$tourn->end($end_dt) if $end_dt;
		$tourn->start($reg_start_dt) if $reg_start_dt;
		$tourn->end($reg_end_dt) if $reg_end_dt;

		$m->print("<p class='specific'>Loaded tournament data changes</p>");
		$tourn->update();

		#TOURN SETTINGS

		if ($jdata->{settings})  {

			$m->print("<p class='specific'> Loading ".scalar @{$jdata->{settings}}." tournament settings </p>");

			Tab::TournSetting->set_sql(rm_all => "
				delete from tourn_setting where tourn = ?
			");

			Tab::TournSetting->sql_rm_all->execute($tourn->id);

			foreach my $jsetting (@{$jdata->{settings}}) {
				my @reply = parse_setting($jsetting);
				$tourn->setting(@reply) if @reply;
			}
		}

	} elsif ($jdata->{event_only}) {
		$m->print("<p class='action'>Update event(s) only</p>");
	} elsif ($jdata->{school_only}) {
		$m->print("<p class='action'>Update school(s) only</p>");
	}

	my %translator;

	unless ($jdata->{school_only}) {

		my @categories = $tourn->categories();
		my %category_by_id = map {$_->id => $_} @categories;
		my %category_by_name = map {$_->name => $_} @categories;
		my %category_by_abbr = map {$_->abbr => $_} @categories;

		$m->print("<p class='action'> Importing ".scalar @{$jdata->{categories}}." judge categories </p>");

		Tab::CategorySetting->set_sql(
			rm_all => "delete from category_setting where category = ?"
		);

		Tab::EventSetting->set_sql(
			rm_all => "delete from event_setting where event = ?"
		);

		# CATEGORY CATEGORIES
		foreach my $category (@{$jdata->{categories}}) {

			my $ocategory = $category_by_id{$category->{id}};

			$m->print("<p class='specific'> No category found for id ".$category->{id}." Trying abbr ".$category->{abbr}."</p>");
			$ocategory = $category_by_abbr{$category->{abbr}} unless $ocategory;

			$m->print("<p class='specific'> No category found for id ".$category->{id}." Trying name ".$category->{name}."</p>");
			$ocategory = $category_by_name{$category->{name}} unless $ocategory;

			if ($ocategory) {
				$ocategory->name($category->{name});
				$ocategory->abbr($category->{abbr});
				$ocategory->update();
			} else {

				$m->print("<p class='specific'> No category found for name ".$category->{name}." Creating</p>");
				$ocategory = Tab::Category->create({
					tourn => $tourn->id,
					name  => $category->{name},
					abbr  => $category->{abbr},
				});

			}

			$translator{category}{$category->{id}} = $ocategory;

			if ($category->{settings})  {
				$m->print("<p class='specific'> Loading ".scalar @{$category->{settings}}." categoryament settings </p>");

				Tab::CategorySetting->sql_rm_all->execute($ocategory->id);

				foreach my $jsetting (@{$category->{settings}}) {
					my @reply = parse_setting($jsetting);
					$ocategory->setting(@reply) if @reply;
				}
			}

			# PREFS AND PREF SHEETS
			my @rts = $ocategory->rating_tiers;
			my %rt_by_id = map {$_->id => $_} @rts;
			my %rt_by_name = map {$_->name => $_} @rts;

			foreach my $rt (@{$category->{rating_tiers}}) {
				my $ort = $rt_by_id{$rt->{id}};

				$m->print("<p class='specific'> No rating tier found for id ".$rt->{id}." Trying name ".$rt->{name}."</p>");
				$ort = $rt_by_name{$rt->{name}} unless $ort;

				unless ($ort) {
					$ort = Tab::RatingTier->create({
						category    => $ocategory->id,
						type        => $rt->{tag},
						name        => $rt->{name},
						description => $rt->{description},
						strike      => $rt->{strike},
						conflict    => $rt->{conflict},
						min         => $rt->{min},
						max         => $rt->{max},
						start       => $rt->{start},
					});

				} else {

					$ort->type($rt->{tag});
					$ort->name($rt->{name});
					$ort->description($rt->{description});
					$ort->strike($rt->{strike});
					$ort->conflict($rt->{conflict});
					$ort->min($rt->{min});
					$ort->max($rt->{max});
					$ort->start($rt->{start});
					$ort->update();

				}

				$translator{rating_tier}{$rt->{id}} = $ort;
			}

			my @rss = $ocategory->rating_subsets;
			my %rs_by_id = map {$_->id => $_} @rss;
			my %rs_by_name = map {$_->name => $_} @rss;

			#RATING SUBSETS
			foreach my $rs (@{$category->{rating_subsets}}) {
				my $ors = $rs_by_id{$rs->{id}};

				$m->print("<p class='specific'> No rating subset found for id ".$rs->{id}." Trying name ".$rs->{name}."</p>");
				$ors = $rs_by_name{$rs->{name}} unless $ors;

				unless ($ors) {
					$ors = Tab::RatingTier->create({
						category => $ocategory->id,
						name     => $rs->{name}
					});
				} else {
					$ors->name($rs->{name});
					$ors->update();
				}

				$translator{rating_subset}{$rs->{id}} = $ors;
			}

			# EVENTS
			if ($category->{events}) {

				my @events = $oevent->events();
				my %event_by_id = map {$_->id => $_} @events;
				my %event_by_name = map {$_->name => $_} @events;
				my %event_by_abbr = map {$_->abbr => $_} @events;

				$m->print("<p class='action'> Importing ".scalar @{$jdata->{events}}." events </p>");

				foreach my $event (@{$jdata->{events}}) {

					my $oevent = $event_by_id{$event->{id}};

					$m->print("<p class='specific'> No event found for id ".$event->{id}." Trying abbr ".$event->{abbr}."</p>");
					$oevent = $event_by_abbr{$event->{abbr}} unless $oevent;

					$m->print("<p class='specific'> No event found for id ".$event->{id}." Trying name ".$event->{name}."</p>");
					$oevent = $event_by_name{$event->{name}} unless $oevent;

					if ($oevent) {
						$oevent->name($event->{name});
						$oevent->abbr($event->{abbr});
						$oevent->update();
					} else {

						$m->print("<p class='specific'> No event found for name ".$event->{name}." Creating</p>");
						$oevent = Tab::Event->create({
							tourn    => $tourn->id,
							category => $ocategory->id,
							name     => $event->{name},
							abbr     => $event->{abbr},
							type     => $event->{type}
						});
					}

					if ($event->{rating_subset}) {
						$rs = $translator{rating_subset}{$event->{rating_subset}};
						$event->rating_subset($rs->id) if $rs;
					}

					if ($event->{pattern}) {
						$rs = $translator{pattern}{$event->{pattern}};
						$event->pattern($rs->id) if $rs;
					}

					$translator{event}{$event->{id}} = $oevent;

					if ($event->{settings})  {
						$m->print("<p class='specific'> Loading ".scalar @{$event->{settings}}." eventament settings </p>");

						Tab::EventSetting->sql_rm_all->execute($event->id);

						foreach my $jsetting (@{$event->{settings}}) {
							my @reply = parse_setting($jsetting);
							$event->setting(@reply) if @reply;
						}
					}
				}
			}
		}
	}

	#TIEBREAK SETS
	unless ($jdata->{tiebreak_sets}) {

		my @tb_sets = $tourn->tiebreak_sets;
		my %tb_set_by_id = map {$_->id => $_} @tb_sets;
		my %tb_set_by_name = map {$_->name => $_} @tb_sets;

		foreach my $tb_set ($jdata->{tiebreak_sets}) {

			my $otb_set;
			$otb_set = $tb_set_by_id{$tb_set->id};

			unless ($otb_set) {
				$otb_set = $tb_set_by_name{$tb_set->name};
			}

			unless ($otb_set) {
				$otb_set = Tab::TiebreakSet->create({
					name  => $tb_set->{name},
					tourn => $tourn->id
				});
			} else {
				$otb_set->name($tb_set->{name});
				$otb_set->update();
			}

			$translator{tb_set}{$tb_set->{id}} = $otb_set;

			foreach my $tiebreak ($otb_set->tiebreaks) {
				$tiebreak->delete();
			}

			#TIEBREAK SET SETTINGS
			if ($tb_set->{settings})  {

				$m->print("<p class='specific'> Loading ".scalar @{$tb_set->{settings}}." tiebreak set settings </p>");

				Tab::TiebreakSetSetting->set_sql(rm_all => "
					delete from tiebreak_set_setting where tb_set = ?
				");

				Tab::TiebreakSetSetting->sql_rm_all->execute($tb_set->id);

				foreach my $jsetting (@{$tb_set->{settings}}) {
					my @reply = parse_setting($jsetting);
					$tb_set->setting(@reply) if @reply;
				}
			}
		}

		#TIEBREAKS

		foreach my $tb_set ($jdata->{tiebreak_sets}) {

			my $otb_set = $translator{tb_set}{$tb_set->{id}};

			foreach my $tiebreak (@{$tb_set->{tiebreaks}}) {

				my $child_set = $translator{tb_set}{$tiebreak->{child}};

				Tab::Tiebreak->create({
					tourn             => $tourn->id,
					name              => $tiebreak->{name},
					priority          => $tiebreak->{priority},
					count             => $tiebreak->{count},
					highlow_count     => $tiebreak->{highlow_count},
					count_round       => $tiebreak->{count_round},
					truncate          => $tiebreak->{truncate},
					truncate_smallest => $tiebreak->{truncate_smallest},
					multiplier        => $tiebreak->{multiplier},
					child             => $child_set
				});
			}
		}
	}

	#PATTERNS
	if ($jdata->{patterns}) {

		my @patterns = $tourn->patterns;
		my %pattern_by_id = map {$_->id => $_} @patterns;
		my %pattern_by_name = map {$_->name => $_} @patterns;

		foreach my $pattern ($jdata->{patterns}) {

			my $opattern;
			my $opattern;
			$opattern = $pattern_by_id{$pattern->id};

			unless ($opattern) {
				$opattern = $pattern_by_name{$pattern->name};
			}

			if ($opattern) {

				$opattern->name($pattern->{name});
				$opattern->type($pattern->{tag});
				$opattern->max($pattern->{max});
				$opattern->exclude($pattern->{exclude});
				$opattern->update();

			} else {
				$opattern = Tab::Pattern->create({
					tourn   => $tourn->id,
					name    => $pattern->{name},
					type    => $pattern->{tag},
					max     => $pattern->{max},
					exclude => $pattern->{exclude}
				});
			}

			$translator{pattern}{$pattern->{id}} = $opattern;

		}
	}

	#TIMESLOTS
	if ($jdata->{timeslots}) {

		my @timeslots = $tourn->timeslots;
		my %timeslot_by_id = map {$_->id => $_} @timeslots;
		my %timeslot_by_name = map {$_->name => $_} @timeslots;

		foreach my $timeslot ($jdata->{timeslots}) {

			my $otimeslot;
			$otimeslot = $timeslot_by_id{$timeslot->id};

			unless ($otimeslot) {
				$otimeslot = $timeslot_by_name{$timeslot->name};
			}

			my $start = parse_date($timeslot->{start});
			my $end = parse_date($timeslot->{end});

			unless ($otimeslot) {
				$otimeslot = Tab::Timeslot->create({
					name  => $timeslot->{name},
					tourn => $tourn->id,
					start => $start,
					end   => $end
				});
			} else {
				$otimeslot->name($timeslot->{name});
				$otimeslot->start($timeslot->{start});
				$otimeslot->end($timeslot->{end});
				$otimeslot->update();
			}

			$translator{timeslot}{$timeslot->{id}} = $otimeslot;
		}
	}

	# SITES
	if ($jdata->{sites}) {

		my @sites = $tourn->sites;
		my %site_by_id = map {$_->id => $_} @sites;
		my %site_by_name = map {$_->name => $_} @sites;

		foreach my $site (@{$jdata->{sites}}) {

			my $osite;
			$osite = $site_by_id{$site->id};

			unless ($osite) {
				$osite = $site_by_name{$site->name};
			}

			if ($osite) {
				$osite->name($site->{name});
				$osite->update();
			} else {
				$osite = Tab::Site->create({
					name => $site->{name},
					circuit => $tourn->circuits->first
				});
			}

			$translator{site}{$site->{id}} = $osite;

			# ROOMS
			foreach my $room ($site->{rooms}) {

				my @rooms = $osite->rooms;
				my %room_by_id = map {$_->id => $_} @rooms;
				my %room_by_name = map {$_->name => $_} @rooms;

				my $oroom;
				$oroom = $room_by_id{$room->id};

				unless ($oroom) {
					$oroom = $room_by_name{$room->name};
				}

				if ($oroom) {

					$oroom->name($room->{name});
					$oroom->rows($room->{rows});
					$oroom->seats($room->{seats});
					$oroom->ada($room->{ada});
					$oroom->inactive($room->{inactive});

					$oroom->quality($room->{quality});
					$oroom->capacity($room->{capacity});
					$oroom->notes($room->{notes});
					$oroom->url($room->{url});

				} else {

					$oroom = Tab::Room->create({
						site     => $osite->id,
						name     => $room->{name},
						rows     => $room->{rows},
						seats    => $room->{seats},
						ada      => $room->{ada},
						inactive => $room->{inactive},
						quality  => $room->{quality},
						capacity => $room->{capacity},
						notes    => $room->{notes},
						url      => $room->{url},
					});
				}
			}
		}
	}

	# WEEKENDS
	if ($jdata->{weekends}) {

		my @weekends = $tourn->weekends;
		my %weekend_by_id = map {$_->id => $_} @weekends;
		my %weekend_by_name = map {$_->name => $_} @weekends;

		foreach my $weekend (@{$jdata->{weekends}}) {

			my $oweekend;
			$oweekend = $weekend_by_id{$weekend->id};

			unless ($oweekend) {
				$oweekend = $weekend_by_name{$weekend->name};
			}

			my $start          = parse_date($site->{start});
			my $end            = parse_date($site->{end});
			my $reg_start      = parse_date($site->{reg_start});
			my $reg_end        = parse_date($site->{reg_end});
			my $fine_deadline  = parse_date($site->{fine_deadline});
			my $judge_deadline = parse_date($site->{judge_deadline});
			my $drop_deadline  = parse_date($site->{drop_deadline});

			if ($oweekend) {

				$oweekend->end($end);
				$oweekend->start($start);
				$oweekend->reg_end($reg_end);
				$oweekend->reg_start($reg_start);
				$oweekend->drop_deadline($drop_deadline);
				$oweekend->freeze_deadline($freeze_deadline);
				$oweekend->judge_deadline($judge_deadline);
				$oweekend->fine_deadline($fine_deadline);

			} else {

				$oweekend = Tab::Weekend->create({
					end             => $end,
					start           => $start,
					reg_end         => $reg_end,
					reg_start       => $reg_start,
					drop_deadline   => $drop_deadline,
					freeze_deadline => $freeze_deadline,
					judge_deadline  => $judge_deadline,
					fine_deadline   => $fine_deadline,
				});
			}

			$translator{weekend}{$weekend->{id}} = $oweekend;
		}
	}

	my $log;
	my %schools;

	if ($jdata->{schools} && (not defined $jdata->{event_only})) {

		my @schools = $tourn->schools;
		my %school_by_id = map {$_->id => $_} @schools;
		my %school_by_name = map {$_->name => $_} @schools;

		$m->print("<p class='action'> Importing ".scalar @{$jdata->{schools}}." school registrations</p>");

		# SCHOOLS
		foreach my $school (@{$jdata->{schools}}) {

			my $oschool;
			$oschool = $school_by_id{$school->id};
			my $chapter;

			unless ($oschool) {
				$oschool = $school_by_name{$school->name};
			}

			if ($oschool) {

				$m->print("<p class='specific'> School $school found for ".$school->{id}." </p>");

				$oschool->name($school->{name});
				$oschool->code($school->{code});
				$oschool->onsite($school->{onsite});
				$oschool->region($school->{region});
				$oschool->district($school->{district});

				$chapter = $oschool->chapter;

				if ($chapter) {
					if ($school->{nsda} && (not defined $chapter->nsda)) {
						$chapter->nsda($school->{nsda});
						$chapter->update();
					}
				}

			} else {

				$m->print("<p class='specific'> No School $school found for ".$school->{id}." ".$school->{name}." Creating:</p>");

				$chapter = Tab::Chapter->retrieve($school->{chapter})
					if $school->{chapter};

				if ((not defined $chapter) && $school->{nsda}) {

					$chapter = Tab::Chapter->search(nsda => $school->{nsda})->first;

					unless ($chapter) {
						my $nsda_school = Tab::NSDA::MemberSchool->search(
							school_id => $school->{nsda}
						)->first;

						$m->print("<p class='specific'>No chapter with NSDA ID ".$school->{nsda}." found.  Importing from NSDA DB</p>");
						if ($nsda_school) {
							$chapter = $m->comp(
								"/funclib/chapter_import.mas",
									nsda_school => $nsda_school,
									person      => $person,
									nome        => "yup"
							);
						}
					}

					unless ($chapter) {

						$chapter = Tab::Chapter->create({
							name => $school->{name}
						});

						$m->print("<p class='specific'>No chapter with name ".$school->{name}." or NSDA ID ".$school->{nsda}." found.  Created $chapter</p>");
					}
				}

				my %data;

				if ($chapter) {
					$data{chapter} = $chapter->id;
					$data{state} = $chapter->state;
				}

				$oschool->create({
					tourn    => $tourn->id,
					chapter  => $data{chapter},
					state    => $data{state},
					name     => $school->{name},
					code     => $school->{code},
					region   => $school->{region},
					district => $school->{district},
				});

				$m->print("<p class='specific'>Created school $school with $chapter</p>");
			}

			$translator{school}{$school->{id}} = $oschool->id;

			if ($oschool) {

				$schools{$school->{id}} = $oschool;

				#SCHOOL SETTINGS
				if ($school->{settings})  {
					$m->print("<p class='specific'> Loading ".scalar @{$school->{settings}}." school settings </p>");

					Tab::SchoolSetting->set_sql(rm_all => "
						delete from school_setting where school = ?
					");

					Tab::SchoolSetting->sql_rm_all->execute($school->id);

					foreach my $jsetting (@{$school->{settings}}) {
						my @reply = parse_setting($jsetting);
						$school->setting(@reply) if @reply;
					}
				}

				# STUDENTS
				my @students = $chapter->students();
				my %students_by_id = map {$_->id => $_} @students;
				my %students_by_nsda = map {$_->nsda => $_} @students;
				my %students_by_name = map {$_->first."-".$_->last => $_} @students;

				foreach my $student (@{$school->{students}}) {

					my $ostudent;
					$ostudent = $student_by_id{$student->{id}};
					$ostudent = $student_by_nsda{$student->{nsda}} unless $ostudent;
					$ostudent = $student_by_name{$student->{first}." ".$student->{last}} unless $ostudent;

					unless ($ostudent) {
						$ostudent->create({
							chapter => $chapter->id,
							first   => $student->{first},
							last    => $student->{last},
							middle  => $student->{middle},
							nsda    => $student->{nsda}
						});

						$student_by_id{$ostudent->id} = $ostudent;
						$student_by_nsda{$ostudent->nsda} = $ostudent;
						$student_by_name{$ostudent->first."-".$ostudent->last} = $ostudent;

					} else {

						$ostudent->first($student->{first});
						$ostudent->last($student->{last});
						$ostudent->middle($student->{middle});
						$ostudent->nsda($student->{nsda});
						$ostudent->update();
						$student_by_id{$ostudent->id} = $ostudent;
					}

					$translator{"student"}{$student->{id}} = $ostudent;
				}

				# ENTRIES
				my @entries = $oschool->entries;
				my %entry_by_id = map {$_->id => $_} @entries;
				my %entry_by_name = map {$_->name => $_} @entries;
				my %entry_by_code = map {$_->code => $_} @entries;

				$m->print("<p class='action'>".$school->name." has ".scalar @{$school->{entries}}." entries</p>");
				my $created;
				my $found;

				foreach my $entry (@{$school->{entries}}) {

					my $oentry;
					$oentry = $entry_by_id{$entry->{id}};
					$oentry = $entry_by_name{$entry->{name}} unless $oentry;
					$oentry = $entry_by_code{$entry->{code}} unless $oentry;

					my $oevent = $translator{event}{$entry->{event}};

					unless ($oentry) {

						$oentry = Tab::Entry->create({
							event => $event->id,
							name  => $entry->{name},
							code  => $entry->{code},
							ada   => $entry->{ada}
						});

						$entry_by_id{$oentry->id} = $oentry;
						$entry_by_name{$oentry->name} = $oentry;
						$entry_by_code{$oentry->code} = $oentry;
						$created++;

					} else {
						$found++;
						$oentry->name($entry->{name});
						$oentry->code($entry->{code});
						$oentry->event($event->id);
						$oentry->update();
					}

					$translator{"entry"}{$entry->{id}} = $oentry;

					#ENTRY SETTINGS
					if ($entry->{settings})  {
						$m->print("<p class='specific'> Loading ".scalar @{$entry->{settings}}." entry settings </p>");
						Tab::EntrySetting->set_sql(rm_all => "
							delete from entry_setting where entry = ?
						");
						Tab::EntrySetting->sql_rm_all->execute($entry->id);
						foreach my $jsetting (@{$entry->{settings}}) {
							my @reply = parse_setting($jsetting);
							$entry->setting(@reply) if @reply;
						}
					}

					#ENTRY STUDENTS
					my @es = Tab::EntryStudent->search( entry => $entry->id);
					my %esen = map {$_->student->id => $_} @es;

					foreach my $student_id (@{$entry->{students}}) {
						my $translated = $translator{student}{$student_id};

						if ($esen{$translated->id}) {
							delete $esen{$translated->id};
						} else {
							Tab::EntryStudent->create({
								entry   => $oentry->id,
								student => $translated->id
							});
						}
					}

					# REMOVE THOSE NOT PART
					foreach my $key (keys %taken) {
						$taken{$key}->delete();
						delete $taken{$key};
					}
				}

				# SCHOOL JUDGES

				# Ordinarily the judges are stored with the categories to
				# account for neutral/hired judges but if you are importing a
				# school on its own this includes the judges here.

				if ($jdata->{school_only}) {

					my @judges = $chapter->judges();
					my %judges_by_id = map {$_->id => $_} @judges;
					my %judges_by_nsda = map {$_->nsda => $_} @judges;
					my %judges_by_name = map {$_->first."-".$_->last => $_} @judges;

					unless ($ojudge) {

						$ojudge->create({
							code         => $judge->{code},
							middle       => $judge->{middle},
							first        => $judge->{first},
							last         => $judge->{last},
							nsda         => $judge->{nsda},
							category     => $judge->{category},
							alt_category => $judge->{alt_category},
							covers       => $judge->{covers},
							active       => $judge->{active},
							ada          => $judge->{ada},
							obligation   => $judge->{obligation},
							hired        => $judge->{hired},
							school       => $judge->{school}
						});

						$judge_by_id{$ojudge->id} = $ojudge;
						$judge_by_nsda{$ojudge->nsda} = $ojudge;
						$judge_by_name{$ojudge->first."-".$ojudge->last} = $ojudge;

					} else {

						$ojudge->first($judge->{first});
						$ojudge->last($judge->{last});
						$ojudge->middle($judge->{middle});
						$ojudge->nsda($judge->{nsda});
						$ojudge->update();
						$judge_by_id{$ojudge->id} = $ojudge;
					}

					$translator{"judge"}{$judge->{id}} = $ojudge;

					#SCHOOL JUDGE SETTINGS
					if ($judge->{settings})  {

						$m->print("<p class='specific'> Loading ".scalar @{$judge->{settings}}." judge settings </p>");

						Tab::JudgeSetting->set_sql(rm_all => "
							delete from judge_setting where judge = ?
						");

						Tab::JudgeSetting->sql_rm_all->execute($judge->id);

						foreach my $jsetting (@{$judge->{settings}}) {
							my @reply = parse_setting($jsetting);
							eval{$judge->setting(@reply)}; if @reply;
						}
					}
				}
			}
		}
	}

	Tab::RoomStrike->set_sql( search_site => "
		select rs.*
		from room_strike rs, room
		where rs.room = room.id
			and room.site = ?
			and rs.tourn = ?
	");

	foreach my $site (@{$jdata->{sites}}) {

		my $osite = $translator{site}{$site->{id}};

		my @blocks = Tab::RoomStrike->search_site( $osite->id, $tourn->id);
		my %block_by_id = map {$_->id => $_} @blocks;

		foreach my $block ($site->{blocks}) {

			my $oblock;
			$oblock = $block_by_id{$block->{id}};

			if ($oblock) {
				$oblock->type($block->{tag});
				$oblock->room($block->{room});
			} else {
				$oblock = Tab::RoomStrike->create({
					type => $block->{tag},
					room => $block->{room},
				});
			}

			if ($block->{start} && $block->{end}) {
				my $start_dt = parse_date($block->{start});
				my $end_dt = parse_date($block->{end});
			}

			$oblock->start($start_dt);
			$oblock->end($end_dt);

			foreach my $key ("event", "judge", "entry") {
				if ($block->{$key}) {
					my $obj = $translator{$key}{$block->{$key}};
					$oblock->$key($obj->id) if $obj > 0;
				}
			}

			$oblock->update();
		}
	}

	sub parse_date {
		my $string = shift;
		return eval {
			return DateTime::Format::MySQL->parse_datetime($string);
		};
	}

	sub parse_setting {
		my $json_ref = shift;

		if ($json_ref->{meta} eq "date") {
			my $dt = parse_date($json_ref->{value});
			return unless $dt;
			return ($json_ref->{tag}, $json_ref->{meta}, $dt);
		} elsif ($json_ref->{meta} eq "text") {
			return ($json_ref->{tag}, $json_ref->{meta}, $json_ref->{value});
		} else {
			return ($json_ref->{tag}, $json_ref->{value});
		}
	}

</%init>
