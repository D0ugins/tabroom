<%args>
	$tourn
	$sweep_set
</%args>
<%init>

	my $novice_only;
	my %skip_round;
	my $prelim_seeds;

	return unless $sweep_set && $sweep_set->id;

	my @rules = $sweep_set->rules;

	foreach my $rule (@rules) { 

		$novice_only++ 
			if $rule->tag eq "novice_only" 
			&& $rule->value == 1;

		$skip_round{$rule->value}++
			if $rule->tag eq "ignore_round";

		$prelim_seeds++ if $rule->tag eq "prelim_seed";

	}

	my @all_events = $sweep_set->events;
	return unless @all_events;

	my @events;
	my %used;

	foreach my $event (@all_events) {
		next unless $event && $event->id;
		next if $used{$event}++;
		push @events, $event;
	}

	my %event_include = map {$_->id => $_} @events;

	my @entries;
	my %entry_code;
	my %entry_event;
	my %entry_school;
	my %entry_manual;

	my $dbh = Tab::DBI->db_Main();

	my $entry_sth = $dbh->prepare("
		select entry.id, entry.code, entry.event, entry.school
		from entry, event
		where entry.event = event.id
		and event.tourn  = ?
		order by entry.code
	");

    $entry_sth->execute($tourn->id);

    while (
		my ($id, $code, $event, $school)  
		= $entry_sth->fetchrow_array() 
	) { 
	
		next unless $event_include{$event};

		push @entries, $id;

		$entry_event{$id}  = $event;
		$entry_school{$id} = $school;
		$entry_code{$id}   = $code;
	}

	foreach my $event (@events) { 

		next unless $event;

		my @manual_sweeps = $m->comp(
			"/funclib/event_entry_settings.mas", 
				event => $event,
				tag   => "sweeps"
			);

		foreach my $manual (@manual_sweeps) { 
			$entry_manual{$manual->entry->id} = $manual->value;
		}
	}


	my $sth = $dbh->prepare("
		select score.id, entry.id, event.id, 
			round.type, round.id, 
			score.tag, score.value, 
			panel.id, 
			student.novice

		from score, ballot, panel, round, event, entry, entry_student, student
		where score.ballot = ballot.id
		and ballot.panel = panel.id
		and panel.round = round.id
		and round.event = event.id
		and event.tourn = ?
		and ballot.entry = entry.id
		and entry.active = 1
		and entry.dq != 1

		and not exists (
			select entry_setting.id
			from entry_setting
			where entry_setting.entry = entry.id
			and entry_setting.tag = 'exclude_from_sweeps'
			and entry_setting.value > 0
		)
		
		and entry.id = entry_student.entry
		and entry_student.student = student.id
		group by score.id
		order by event.id, round.name
	");

    $sth->execute($tourn->id);

	my %event_scores;
	my %entry_scores;
	my %entry_panels;
	my %entry_round_panel;

	my %score_entry;
	my %score_type;
	my %score_tag;
	my %score_value;
	my %score_panel;
	my %score_round;
	my %score_event;
	my %score_novice;
	my %entry_novice;

	my @scores;

    while (
		my ($id, $entry, $event, $type, $round, $tag, $value, $panel, $novice)  
		= $sth->fetchrow_array() 
	) { 

		next unless $event_include{$event};
		next if $skip_round{$round};

		$entry_novice{$entry} = $novice;
		next if $novice_only && $novice < 1;


		push @scores, $id;
		push @{$event_scores{$event}}, $id;
		push @{$entry_scores{$entry}}, $id;
		push @{$entry_panels{$entry}},$panel;

		$entry_round_panel{$entry."-".$round} = $panel;

		$score_tag{$id} = $tag;

		$type = "prelim" 
			if $type eq "preset" 
			|| $type eq "highhigh" 
			|| $type eq "highlow";

		$score_type{$id} = $type;

		$score_entry{$id} = $entry;
		$score_value{$id} = $value;
		$score_panel{$id} = $panel;
		$score_round{$id} = $round;
		$score_event{$id} = $event;
		$score_novice{$id} = $novice;

	}


	my $bye_sth = $dbh->prepare("
		select entry.id, event.id, round.type, round.id, panel.id, panel.bye, ballot.bye
		from panel, round, event, entry, ballot
		where ballot.panel = panel.id
		and panel.round = round.id
		and round.event = event.id
		and event.tourn = ? 
		and ballot.entry = entry.id
		and entry.active = 1
		and entry.dq != 1

		and not exists (
			select entry_setting.id
			from entry_setting
			where entry_setting.entry = entry.id
			and entry_setting.tag = 'exclude_from_sweeps'
			and entry_setting.value > 0
		)
		
		group by ballot.id
		order by event.id, round.name
	");

    $bye_sth->execute($tourn->id);

	my %entry_byes;
	my %entry_byes_by_type;

    while (
		my ($entry, $event, $type, $round, $panel, $panel_bye, $ballot_bye)  
		= $bye_sth->fetchrow_array() 
	) { 

		next if $skip_round{$round};
		next unless $event_include{$event};
		next unless $panel_bye || $ballot_bye;

		next if $novice_only && $entry_novice{$entry};

		$entry_byes{$entry}++;

		$type = "prelim" 
			if $type eq "preset" 
			|| $type eq "highhigh" 
			|| $type eq "highlow";

		$entry_byes_by_type{$entry}{$type}++;

		push @{$entry_panels{$entry}}, $panel;
		$entry_round_panel{$entry."-".$round} = $panel;

	}

	my %seen = (); 
	@entries = grep { ! $seen{$_} ++ } @entries;

	my %entry_points;
	my %entry_placement;

	my %places = (); 
	my $places_done;
	my $places_above_done;
	my $placement_done;

	foreach my $rule (@rules) { 
		$places{$rule->place} = $rule->value 
			if $rule->place && $rule->tag ne "cume";
	}

	my %prelim_seeding = ();

	if ($prelim_seeds) { 

		foreach my $event (@events) { 

			my $last_prelim;

			foreach my $round ($event->rounds) { 
				next if $round->type eq "elim";
				next if $round->type eq "final";
				$last_prelim = $round if (not defined $last_prelim);
				$last_prelim = $round if $round->name > $last_prelim->name;
			}

			my (@results) = $m->comp(
				"/tabbing/results/order_entries.mas", 
				round => $last_prelim
			); 

			my $fullref = pop @results if @results;

			$prelim_seeding{$event->id} = $fullref->{"by_place"};

		}
	}

	foreach my $rule (@rules) { 

		if ($rule->tag eq "points_per") {

			my $points = $rule->value;
			my $count = $rule->count;

			foreach my $entry (@entries) { 

				my @panels;

				SCORE:
				foreach my $score (@{$entry_scores{$entry}}) { 
					
					unless ( (not defined $count) || $count eq "all") { 

						next if $score_type{$score} eq "prelim" && $count ne "prelim";
						next if $score_type{$score} eq "elim" && $count ne "elim";
						next if $score_type{$score} eq "final" && $count ne "final";

					}

					next if $novice_only && not defined $score_novice{$score};

					push @panels, $score_panel{$score};
				}

				my %pseen = ();
				@panels = grep { ! $pseen{$_} ++ } @panels;

				$entry_points{$entry} += ($points * (scalar @panels));
			}
		}

		if ($rule->tag eq "points_per_rank") {

			my $points = $rule->value;
			my $place = $rule->place;
			my $count = $rule->count;

			foreach my $entry (@entries) { 

				my %used;

				SCORE:
				foreach my $score (@{$entry_scores{$entry}}) { 

					next if $used{$score}++;
					next unless $score_tag{$score} eq "rank";

					unless (not defined $count || $count eq	"all") { 
						next SCORE if $score_type{$score} ne $count;
					}

					next if $novice_only && not defined $score_novice{$score};
					$entry_points{$entry} += $points if $score_value{$score} == $place;
				}
			}
		}

		if ($rule->tag eq "points_per_elim") {

			my $points = $rule->value;

			foreach my $entry (@entries) { 

				my @panels;

				foreach my $score (@{$entry_scores{$entry}}) { 

					next if $score_type{$score} ne "elim";
					next if $novice_only && not defined $score_novice{$score};
					push @panels, $score_panel{$score};
				}

				my %pseen = ();
				@panels = grep { ! $pseen{$_} ++ } @panels;
				$entry_points{$entry} += ($points * (scalar @panels));
			}
		}

		if ($rule->tag eq "points_per_final" ) {

			my $points = $rule->value;

			foreach my $entry (@entries) { 

				my @panels;

				foreach my $score (@{$entry_scores{$entry}}) { 
					next if $score_type{$score} ne "final";
					next if $novice_only && not defined $score_novice{$score};
					push @panels, $score_panel{$score};
				}

				my %pseen = ();
				@panels = grep { ! $pseen{$_} ++ } @panels;
				$entry_points{$entry} += ($points * (scalar @panels));
			}
		}

		if ($rule->tag eq "rev_per_rank" || $rule->tag eq "rev_per_rank_sansworst" ) {

			my $dropworst++ if $rule->tag eq "rev_per_rank_sansworst";
			my $points = $rule->value;
			my %entry_worst;

			my $count = $rule->count;

			SCORE:
			foreach my $score (@scores) { 

				my $entry = $score_entry{$score};

				unless (not defined $count || $count eq "all") { 
					next SCORE if $score_type{$score} ne $count;
				}

				next if $novice_only && not defined $score_novice{$score};
				next unless $score_tag{$score} eq "rank";
		
				my $points;

				if ($dropworst && $entry_worst{$entry} < $score_value{$score}) {

					if ($entry_worst{$entry}) { 
						$points = 6 - $entry_worst{$entry};
						$points = 1 if $points < 1;
						$entry_worst{$entry} = $score_value{$score};
					} else { 
						$points = 6 - $score_value{$score};
						$points = 1 if $points < 1;
					}

				} else { 
					$points = 6 - $score_value{$score};
					$points = 1 if $points < 1;
				}

				$entry_points{$entry} += $points;
			}
		}
		
		if ($rule->tag eq "cume") {

			my $points = $rule->value;
			my $place = $rule->place;

			my %entry_cume;

			foreach my $score (@scores) { 
				next if $novice_only && not defined $score_novice{$score};
				next unless $score_tag{$score} eq "rank";
				next if $score_type{$score} eq "elim";
				next if $score_type{$score} eq "final";
				$entry_cume{$score_entry{$score}} += $score_value{$score};
			}

			foreach my $entry (@entries) { 
				$entry_points{$entry} += $points 
					if $entry_cume{$entry} == $place;
			}

		}

		if ($rule->tag eq "prelim_seed") { 

			my $limit = $rule->place;
			my $points = $rule->value;
			my %done;
			
			foreach my $event (@events) { 

				next unless $event && $event->id;

				foreach my $place (
					sort {$a <=> $b} 
					keys %{$prelim_seeding{$event->id} }
				)  {

					next if $place > $limit;

					Tab::debuglog("Event ".$event->name." limit is $limit place is $place");

					foreach my $entry_id (@{$prelim_seeding{$event->id}{$place}}) { 

						Tab::debuglog("Entry $entry_id");

						next if $done{$entry_id}++;

						Tab::debuglog("Counting");

						$entry_points{$entry_id} += $points;

					}

				}
			}

		}

		if ($rule->tag eq "rev_per_place") { 

			my $type = $rule->count;
			
			foreach my $event (@events) { 

				next unless $event && $event->id;
			
				foreach my $round ($event->rounds) { 

					next if $skip_round{$round->id};
					next unless $round->type eq $type;


					my ($entries_ref, $tbs_ref, $desc_ref, $forfeit_ref) 
						= $m->comp("/tabbing/results/order_entries.mas", 
						round => $round
					); 

					my %panel_place;

					foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {

						foreach my $entry (@{${$entries_ref}{$key}}) {

							next if $novice_only && not defined $entry_novice{$entry};

							my $panel = $entry_round_panel{$entry."-".$round->id};
							$panel_place{$panel}++;
							
							my $points = 6 - $panel_place{$panel};
							$points = 1 if $points < 1;

							$entry_points{$entry} += $points;
						}

					}
				}
			}
		}

		if ($rule->tag eq "rev_composite" && $rule->tiebreak_set) { 

			my $type = $rule->count;
			my $tiebreak_set = $rule->tiebreak_set;

			foreach my $event (@events) { 

				next unless $event && $event->id;
			
				foreach my $round ($event->rounds) { 
					
					next if $skip_round{$round->id};

					next unless ($round->type eq $type) 
						|| $type eq "all";

					my @results = $m->comp(
						"/tabbing/results/order_entries.mas", 
							round        => $round,
							tiebreak_set => $tiebreak_set,
							section_rank => 1
					); 

					my $entries_ref = pop @results;

					my %panel_place;

					foreach my $entry_id (sort {$a <=> $b} keys %{$entries_ref->{"section_rank"}}) {

						my $rank = $entries_ref->{"section_rank"}{$entry_id};

						next unless $rank;

						my $points = 6 - $rank;
						$points = 1 if $points < 1;

						$entry_points{$entry_id}  += $points;

					}
				}
			}
		}

		if ($rule->tag eq "percentage" && $rule->tiebreak_set) { 

			my $type = $rule->count;

			my $tiebreak_set = $rule->tiebreak_set;

			my $points = $rule->value;

			foreach my $event (@events) { 

				next unless $event && $event->id;

				my @rounds;

				if ($type eq "all") { 

					foreach my $round ($event->rounds) { 
						next if $skip_round{$round->id};
						push @rounds, $round;
					}

				} elsif ($type eq "prelim") { 

					foreach my $round ($event->rounds) { 
						next if $skip_round{$round->id};
						push @rounds, $round if (
							$round->type ne "elim" 
							&& $round->type ne "final"
						);
					}

				} elsif ($type eq "elim") { 

					foreach my $round ($event->rounds) { 
						next if $skip_round{$round->id};

						push @rounds, $round 
							if $round->type eq "elim";
					}

				} elsif ($type eq "final") { 

					foreach my $round ($event->rounds) { 
						next if $skip_round{$round->id};
						push @rounds, $round 
							if $round->type eq "final";
					}

				} elsif ($type eq "last_prelim") { 

					my $last_prelim;

					foreach my $round ($event->rounds) { 

						next if $skip_round{$round->id};
						next if $round->type eq "elim";
						next if $round->type eq "final";

						$last_prelim = $round 
							if (not defined $last_prelim);

						$last_prelim = $round 
							if $last_prelim 
							&& $last_prelim->name < $round->name;
					}

					push @rounds, $last_prelim;

				}

				foreach my $round (@rounds) { 

					my @results = $m->comp(
						"/tabbing/results/order_entries.mas", 
							round        => $round,
							tiebreak_set => $tiebreak_set
					); 

					my $entries_ref = pop @results;

					my $entries_count = scalar( keys %{$entries_ref->{"by_place"}} );

					my $threshold = ceil($rule->place * .01 * $entries_count);

					foreach my $place (
						sort {$a <=> $b} keys %{$entries_ref->{"by_place"}}
					) { 

						next if $place > $threshold;

						if ($entries_ref->{"by_place"}{$place}) { 

							foreach my $entry_id (@{$entries_ref->{"by_place"}{$place}}) {

								$entry_points{$entry_id}  += $points;
							}

						}

					}

				}

			}

		}


		if (
			$rule->tag eq "rev_per_overall_place" 
			|| $rule->tag eq "place"
			|| $rule->tag eq "place_above"
			|| $rule->tag eq "nsda_place"
		) {

			unless ($placement_done) { 

				foreach my $event (@events) { 

					next unless $event;

					my @rounds = sort {$b->name <=> $a->name} $event->rounds;

					my $final;

					while (@rounds && (not defined $final)) { 
						$final = shift @rounds;
						undef $final if $skip_round{$final->id};
					}

					next unless $final;

					my $final_tiebreaks = $final->tiebreak_set;

					if ($event->type eq "debate") { 

						$final_tiebreaks = Tab::TiebreakSet->search(
							tourn => $tourn->id,
							name => "Debate Final"
						)->first;

					}

					my $limit = 7;
			
					my ($entries_ref, $tbs_ref, $desc_ref, $forfeit_ref) 
						= $m->comp(
							"/tabbing/results/order_entries.mas", 
							round        => $final,
							tiebreak_set => $final_tiebreaks,
							all_entries  => 1
					); 

					my $max_key;
					my %done;

					foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {

						foreach my $entry (@{${$entries_ref}{$key}}) {
							next if $limit < 1;
							next if $novice_only && not defined $entry_novice{$entry};
							$entry_placement{$entry} = $key;

							$max_key++;
							$limit--;
							$done{$entry}++;
						}

					}

					if ($rule->tag eq "nsda_place" && $limit > 0) { 

						my $round_count = $final->name;

						while ($limit > 0 && $round_count > 0) { 

							$round_count--;

							my $next_round = Tab::Round->search(
								name  => $round_count,
								event => $event->id
							)->first;

							if ($next_round) { 

								my ($entries_ref, $tbs_ref, $desc_ref, $forfeit_ref) 
									= $m->comp(
										"/tabbing/results/order_entries.mas", 
										round        => $next_round,
										tiebreak_set => $final_tiebreaks,
										all_entries  => 1
								); 


								foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {

									foreach my $entry (@{${$entries_ref}{$key}}) {

										next if $limit < 1;
										next if $done{$entry}++;

										next if $novice_only && not defined $entry_novice{$entry};

										$entry_placement{$entry} = $key;

										$limit--;
									}

								}

							} else { 

								$limit--;

							}

						}
						
					}

				}

				$placement_done++;
			}

			if ($rule->tag eq "rev_per_overall_place") { 

				foreach my $entry (@entries) { 
					next unless $entry_placement{$entry};
					my $points = 6 - $entry_placement{$entry};
					$points = 0 unless $points;
					$entry_points{$entry} += $points;
				}

			}

			if ($rule->tag eq "place_above" && not defined $places_above_done) { 

				$places_done++;

				foreach my $entry (@entries) { 

					next unless $entry_placement{$entry};
					next if $entry_placement{$entry} > $rule->place;
					$entry_points{$entry} += $rule->value;
				}
			}


			if ($rule->tag eq "place" && not defined $places_done) { 
				$places_above_done++;

				foreach my $entry (@entries) { 
					next unless $entry_placement{$entry};
					$entry_points{$entry} += $places{$entry_placement{$entry}};
				}
			}

			if ($rule->tag eq "nsda_place") { 
			
				foreach my $entry (@entries) { 

					next unless $entry_placement{$entry};
					next unless $entry_placement{$entry} < 7;

					my $event = $event_include{$entry_event{$entry}};

					my $baseline_score = 10;

					$baseline_score-- if $event->type eq "speech";

					my $field_size = scalar @entries;

					if ($event->setting("max_entry") > 1) { 

						$baseline_score-- if $field_size < 50;
						$baseline_score-- if $field_size < 30;

					} else { 

						$baseline_score-- if $field_size < 58;
						$baseline_score-- if $field_size < 38;
					}

					my $points = 0;
					
					if (
						($entry_placement{$entry} < 7)
						&& ($entry_placement{$entry} > 0)
					) { 
					
						$points = $baseline_score - $entry_placement{$entry};
					}

					$entry_points{$entry} += $points;
				}

			}

		}

		if ($rule->tag eq "debate_win" || $rule->tag eq "debate_loss" ) {

			my $winner++ if $rule->tag eq "debate_win";
			my $points = $rule->value;
			my $count = $rule->count;

			SCORE:
			foreach my $score (@scores) { 

				if ($count && $count ne "all") { 
					next SCORE if $score_type{$score} ne $count;
				}

				my $entry = $score_entry{$score};

				next if $novice_only && not defined $score_novice{$score};

				next unless $score_tag{$score} eq "ballot";

				if ($rule->tag eq "debate_win") { 
					$entry_points{$score_entry{$score}} += $points 
						if $score_value{$score} == 1;
				}

				if ($rule->tag eq "debate_loss") { 
					$entry_points{$score_entry{$score}} += $points 
						if $score_value{$score} == 0;
				}
			}

		}

		if ($rule->tag eq "debate_round_win" || $rule->tag eq "debate_round_loss" ) {

			my $winner++ if $rule->tag eq "debate_round_win";

			my $points = $rule->value;
			my $count = $rule->count;

			my @round_keys;
			my @entries;
			my %round_ballots_won;
			my %round_ballots_lost;

			SCORE:
			foreach my $score (@scores) { 

				if ($count && $count ne "all") { 
					next SCORE if $score_type{$score} ne $count;
				}

				my $entry = $score_entry{$score};
				my $round = $score_round{$score};
			
				next if $novice_only && not defined $score_novice{$score};
				next unless $score_tag{$score} eq "ballot";

				$round_ballots_won{$entry}{$round}++ 
					if $score_value{$score} == 1;

				$round_ballots_lost{$entry}{$round}++ 
					if $score_value{$score} == 0;

				push @round_keys, $round 
					if exists $score_value{$score};

				push @entries, $entry
					if exists $score_value{$score};
			}

			my %seen = (); 
			@round_keys = grep { ! $seen{$_} ++ } @round_keys;

			my %eseen = (); 
			@entries = grep { ! $eseen{$_} ++ } @entries;

			foreach my $key (@round_keys) { 

				foreach my $entry (@entries) { 

					if ($rule->tag eq "debate_round_win") { 

						$entry_points{$entry} += $points 
							if $round_ballots_won{$entry}{$key} > $round_ballots_lost{$entry}{$key};

					} elsif ($rule->tag eq "debate_round_loss") { 

						$entry_points{$entry} += $points 
							if $round_ballots_won{$entry}{$key} < $round_ballots_lost{$entry}{$key};
					}

				}
			}
		}

		if ($rule->tag eq "debate_round_bye") {

			my $points = $rule->value;
			my $count = $rule->count;

			foreach my $entry (@entries) { 

				if ($count && $count ne "all") { 
					$entry_points{$entry} += $entry_byes_by_type{$entry}{$count} * $points;
				} else { 
					$entry_points{$entry} += $entry_byes{$entry} * $points;
				}
			}
		}

		if ($rule->tag eq "manual" ) {

			foreach my $entry (@entries) { 
				$entry_points{$entry} += $entry_manual{$entry};
			}

		}
	}

	return \%entry_points, \@entries, \%entry_school, \%entry_event, \%entry_code;

</%init>
