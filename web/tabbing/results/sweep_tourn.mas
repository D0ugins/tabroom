<%args>
	$tourn
	$sweep_set
</%args>
<%init>

	my %tourn_settings = $tourn->all_settings();
	my $districts    = $tourn_settings{"nsda_district"};
	my $nsda_nats    = $tourn_settings{"nsda_nats"};

	my $novice_only;
	my %skip_round;
	my $prelim_seeds;

	return unless $sweep_set && $sweep_set->id;
	my @rules = $sweep_set->rules;

	foreach my $rule (@rules) {
		$novice_only++ if $rule->tag eq "novice_only" && $rule->value == 1;
		$skip_round{$rule->value}++ if $rule->tag eq "ignore_round";
		$prelim_seeds++ if $rule->tag eq "prelim_seed";
	}

	my @all_events = $sweep_set->events;
	return unless @all_events;

	my @events;
	my %used;

	foreach my $event (@all_events) {
		next unless $event && $event->id;
		next if $used{$event}++;
		push @events, $event;
	}

	my %event_include = map {$_->id => $_} @events;

	my @entries;
	my %entries;

	my %entry_code;
	my %event_count;
	my %entry_event;
	my %entry_school;

	my $dbh = Tab::DBI->db_Main();

	my $entry_sth = $dbh->prepare("
		select entry.id, entry.code, entry.name, entry.event, event.abbr,
			entry.school,
			school.name as schoolname, chapter.state as state, chapter.nsda as nsda,
			district.id as districtid, district.name as districtname,
			region.name, region.code,
			student.id, student.first, student.middle, student.last
		from (entry, event)
			left join school on entry.school  = school.id
			left join chapter on chapter.id   = school.chapter
			left join district on district.id = school.district
			left join region on region.id = school.region
			left join entry_student es on es.entry = entry.id
			left join student on student.id = es.student
		where entry.event = event.id
			and event.tourn  = ?
			and entry.unconfirmed = 0

			and not exists (
				select entry_setting.id
				from entry_setting
				where entry_setting.entry = entry.id
				and entry_setting.tag = 'exclude_from_sweeps'
				and entry_setting.value > 0
			)
		order by entry.code
	");

    $entry_sth->execute($tourn->id);

    while (
		my (
			$entry_id, $code, $name,
			$event, $event_abbr,
			$school, $schoolname,
			$state, $nsda,
			$region_name, $region_code,
			$districtid, $districtname,
			$student_id, $student_first, $student_middle, $student_last
		) = $entry_sth->fetchrow_array()
	) {

		next unless $event_include{$event};

		unless ($entries{$entry_id}{"code"}) {
			push @entries, $entry_id;

			$entries{$entry_id}{"code"} = $code;
			$entries{$entry_id}{"name"} = $name;
			$entries{$entry_id}{"event"} = $event;
			$entries{$entry_id}{"eventabbr"} = $event_abbr;

			$entries{$entry_id}{"school"}     = $school;
			$entries{$entry_id}{"schoolname"} = $schoolname;
			$entries{$entry_id}{"state"}      = $state;

			$entries{$entry_id}{"regionname"} = $region_name;
			$entries{$entry_id}{"regioncode"} = $region_code;

			$entries{$entry_id}{"districtid"} = $districtid;
			$entries{$entry_id}{"nsda_school_id"} = $nsda;
			$entries{$entry_id}{"districtname"} = $districtname;

			$entry_event{$entry_id}  = $event;
			$entry_school{$entry_id} = $school;
			$entry_code{$entry_id}   = $code;
			$event_count{$event}++;
		}

		unless ($entries{$entry_id}{students}{$student_id}) {
			$entries{$entry_id}{students}{$student_id}{"first"}   = $student_first;
			$entries{$entry_id}{students}{$student_id}{"middle"}  = $student_middle;
			$entries{$entry_id}{students}{$student_id}{"last"}    = $student_last;
			$entries{$entry_id}{students}{$student_id}{"full"}    = $student_first." ";
			$entries{$entry_id}{students}{$student_id}{"full"}   .= $student_middle." " if $student_middle;
			$entries{$entry_id}{students}{$student_id}{"full"}   .= $student_last." " if $student_last;
		}
	}

	foreach my $event (@events) {

		next unless $event;

		my @manual_sweeps = $m->comp(
			"/funclib/event_entry_settings.mas",
				event => $event,
				tag   => "sweeps"
			);

		foreach my $manual (@manual_sweeps) {
			$entries{$manual->entry->id}{manual} = $manual->value;
		}
	}

	my $sth = $dbh->prepare("
		select score.id, entry.id, event.id,
			round.type, round.id, round.name,
			score.tag, score.value,
			panel.id,
			student.novice

		from (score, ballot, panel, round, event, entry)
			left join student on student.id = score.student
		where score.ballot = ballot.id
			and ballot.panel = panel.id
			and panel.round = round.id
			and round.event = event.id
			and event.tourn = ?
			and ballot.entry = entry.id
			and entry.active = 1
			and entry.dq != 1

		and not exists (
			select entry_setting.id
			from entry_setting
			where entry_setting.entry = entry.id
			and entry_setting.tag = 'exclude_from_sweeps'
			and entry_setting.value > 0
		)

		group by score.id
		order by event.id, round.name
	");

    $sth->execute($tourn->id);

	my %scores;

    while (
		my (
			$score_id, $entry, $event,
			$round_type, $round_id, $round_name,
			$tag, $value, $panel, $novice
		) = $sth->fetchrow_array()
	) {

		next if $round_type eq "runoff";

		next unless $event_include{$event};
		next if $skip_round{$round_id};

		$entries{$entry}{"rounds"}{$round_id}++;
		push @{$entries{$entry}{"scores"}}, $score_id;
		$entries{$entry}{"round_panel"}{$round_id} = $panel;

		$scores{$score_id}{"tag"} = $tag;

		$round_type = "prelim"
			if $round_type eq "preset"
			|| $round_type eq "highhigh"
			|| $round_type eq "highlow";

		$scores{$score_id}{"round_type"} = $round_type;
		$scores{$score_id}{"round_name"} = $round_name;

		$scores{$score_id}{"entry"}    = $entry;
		$scores{$score_id}{"value"}    = $value;
		$scores{$score_id}{"panel_id"} = $panel;
		$scores{$score_id}{"round_id"} = $round_id;
		$scores{$score_id}{"novice"}   = $novice;

	}

	$sth->finish();

	my %entry_round;

	if ($tourn_settings{nsda_nats}) {

		$sth = $dbh->prepare("
			select entry.id, panel.id, round.id, round.name, round.type
			from (entry, school, ballot, panel, round)

			where school.tourn = ?
			and school.id = entry.school
			and entry.unconfirmed = 0
			and entry.dq != 1
			and entry.id = ballot.entry
			and ballot.panel = panel.id
			and panel.round = round.id
		");

		$sth->execute($tourn->id);

		while (
			my (
				$entry_id, $panel_id, $round_id, $round_name, $round_type
			) = $sth->fetchrow_array()
		) {

			next if $skip_round{$round_id};
			$entry_round{$entry_id}{$round_id}{"name"} = $round_name;
			$entry_round{$entry_id}{$round_id}{"type"} = $round_type;
			$entry_round{$entry_id}{$round_id}{"panel"} = $panel_id
		}
	}

	my $student_sth = $dbh->prepare("
		select student.id, student.nsda, student.novice, entry.id
		from student, entry_student, entry, event
		where event.tourn = ?
			and event.id = entry.event
			and entry.unconfirmed = 0
			and entry.id = entry_student.entry
			and entry_student.student = student.id
	");

	$student_sth->execute($tourn->id);

	while(
		my (
			$student, $nsda, $novice, $entry
		) = $student_sth->fetchrow_array()
	) {

		$entries{$entry}{"novice"} = $novice;
		next if $novice_only && $novice < 1;

		if ($nsda) {
			$entries{$entry}{"students"}{$student}{"nsda"} = $nsda;
		}

		$entries{$entry}{"students"}{$student}{"novice"} = $novice;
	}

	$student_sth->finish();

	my $bye_sth = $dbh->prepare("
		select entry.id, event.id,
			round.type, round.id, round.name,
			panel.id, panel.bye, ballot.bye
		from panel, round, event, entry, ballot
		where ballot.panel = panel.id
			and panel.round = round.id
			and round.event = event.id
			and event.tourn = ?
			and ballot.entry = entry.id
			and entry.active = 1
			and entry.dq != 1

			and (ballot.bye = 1 or panel.bye = 1)

		and not exists (
			select entry_setting.id
			from entry_setting
			where entry_setting.entry = entry.id
			and entry_setting.tag = 'exclude_from_sweeps'
			and entry_setting.value > 0
		)

		group by ballot.id
		order by event.id, round.name
	");

    $bye_sth->execute($tourn->id);

    while (
		my (
			$entry_id, $event,
			$round_type, $round_id, $round_name,
			$panel, $panel_bye, $ballot_bye
		) = $bye_sth->fetchrow_array()
	) {

		next if $skip_round{$round_id};
		next unless $event_include{$event};
		next unless $panel_bye || $ballot_bye;

		next if $novice_only && $entries{$entry_id}{"novice"};

		$entries{$entry_id}{"byes"}++;
		$entries{$entry_id}{"round_bye"}{$round_name}++;

		$round_type = "prelim"
			if $round_type eq "preset"
			|| $round_type eq "highhigh"
			|| $round_type eq "highlow";

		$entries{$entry_id}{"bye_type"}{$round_type}++;
		$entries{$entry_id}{"round_panel"}{$round_id} = $panel;
	}

	$bye_sth->finish();

	my %seen = ();
	@entries = grep { ! $seen{$_} ++ } @entries;

	my %entry_points;
	my %entry_placement_event;

	my %places = ();
	my $placement_done;

	foreach my $rule (@rules) {
		$places{$rule->place} = $rule->value if $rule->place && $rule->tag ne "cume";
	}

	my %prelim_seeding = ();

	if ($prelim_seeds) {

		foreach my $event (@events) {

			my $last_prelim;

			foreach my $round ($event->rounds) {
				next if $round->type eq "elim";
				next if $round->type eq "final";
				$last_prelim = $round if (not defined $last_prelim);
				$last_prelim = $round if $round->name > $last_prelim->name;
			}

			my (@results) = $m->comp(
				"/tabbing/results/order_entries.mas",
				round => $last_prelim
			);

			my $fullref = pop @results if @results;
			$prelim_seeding{$event->id} = $fullref->{"by_place"};

		}
	}

	my %rules;

	foreach my $rule (@rules) {

		my $rule_tag = $rule->tag;
		my $rule_id = $rule->id;

		if ($rule_tag eq "points_per") {

			my $points      = $rule->value;
			my $count       = $rule->count;
			my $count_round = $rule->count_round;

			foreach my $entry_id (@entries) {

				my @panels;

				if ($tourn_settings{nsda_nats}) {

					ROUND:
					foreach my $round_id (keys %{$entry_round{$entry_id}}) {
						if ($count eq "specific") {
							next ROUND if $entry_round{$entry_id}{$round_id}{"name"} ne $count_round;
						} elsif ($count eq "all") {
						} else {
							next ROUND if $entry_round{$entry_id}{$round_id}{"type"} ne $count;
						}

						push @panels, $entry_round{$entry_id}{$round_id}{"panel"};
					}

				} else {

					SCORE:
					foreach my $score_id (@{$entries{$entry_id}{"scores"}}) {

						if ($count eq "specific") {
							next SCORE if $scores{$score_id}{"round_name"} ne $count_round;
						} elsif ($count eq "all") {

						} else {
							next SCORE if $scores{$score_id}{"round_type"} ne $count;
						}

						if ($novice_only && (not defined $scores{$score_id}{"novice"})) {
							next SCORE;
						}

						push @panels, $scores{$score_id}{"panel_id"};
					}
				}

				my %pseen = ();
				@panels = grep { ! $pseen{$_} ++ } @panels;

				if (@panels) {
					$entries{$entry_id}{$rule_id} += ($points * (scalar @panels));
				} elsif ($count eq "specific" && $entries{$entry_id}{"round_bye"}{$count_round}) {
					$entries{$entry_id}{$rule_id} += $points;
				}

			}
		}

		if ($rule_tag eq "points_per_rank") {

			my $points = $rule->value;
			my $place = $rule->place;
			my $count = $rule->count;

			foreach my $entry_id (@entries) {

				my %used;

				SCORE:
				foreach my $score_id (@{$entries{$entry_id}{"scores"}}) {

					next if $used{$score_id}++;
					next unless $scores{$score_id}{"tag"} eq "rank";

					if ($count && $count ne "all") {
						next SCORE if $scores{$score_id}{"round_type"} ne $count;
					}

					next if $novice_only && (not defined $scores{$score_id}{"novice"});

					$entries{$entry_id}{$rule_id} += $points if $scores{$score_id}{"value"} == $place;
				}
			}
		}

		if ($rule_tag eq "points_per_elim") {

			my $points = $rule->value;

			foreach my $entry_id (@entries) {

				my @panels;

				foreach my $score_id (@{$entries{$entry_id}{"scores"}}) {

					next if $scores{$score_id}{"round_type"} ne "elim";
					next if $novice_only && (not defined $scores{$score_id}{"novice"});
					push @panels, $scores{$score_id}{"panel_id"};
				}

				my %pseen = ();
				@panels = grep { ! $pseen{$_} ++ } @panels;
				$entries{$entry_id}{$rule_id} += ($points * (scalar @panels));
			}
		}

		if ($rule_tag eq "points_per_final" ) {

			my $points = $rule->value;

			foreach my $entry_id (@entries) {

				my @panels;

				foreach my $score_id (@{$entries{$entry_id}{"scores"}}) {
					next if $scores{$score_id}{"round_type"} ne "final";
					next if $novice_only && (not defined $scores{$score_id}{"novice"});
					push @panels, $scores{$score_id}{"panel_id"};
				}

				my %pseen = ();
				@panels = grep { ! $pseen{$_} ++ } @panels;
				$entries{$entry_id}{$rule_id} += ($points * (scalar @panels));
			}
		}

		if ($rule_tag eq "rev_per_rank" || $rule_tag eq "rev_per_rank_sansworst" ) {

			my $dropworst++ if $rule_tag eq "rev_per_rank_sansworst";
			my $points = $rule->value;
			my %entry_worst;

			my $count = $rule->count;

			SCORE:
			foreach my $score_id (keys %scores) {

				my $entry_id = $scores{$score_id}{"entry"};

				unless (not defined $count || $count eq "all") {
					next SCORE if $scores{$score_id}{"round_type"} ne $count;
				}

				next if $novice_only && (not defined $scores{$score_id}{"novice"});
				next unless $scores{$score_id}{"tag"} eq "rank";

				my $points;

				if ($dropworst && $entry_worst{$entry_id} < $scores{$score_id}{"value"}) {

					if ($entry_worst{$entry_id}) {
						$points = 6 - $entry_worst{$entry_id};
						$points = 1 if $points < 1;
						$entry_worst{$entry_id} = $scores{$score_id}{"value"};
					} else {
						$points = 6 - $scores{$score_id}{"value"};
						$points = 1 if $points < 1;
					}

				} else {
					$points = 6 - $scores{$score_id}{"value"};
					$points = 1 if $points < 1;
				}

				$entries{$entry_id}{$rule_id} += $points;
			}
		}

		if ($rule_tag eq "cume") {

			my $points = $rule->value;
			my $place = $rule->place;

			my %entry_cume;

			foreach my $score_id (keys %scores) {
				next if $novice_only && (not defined $scores{$score_id}{"novice"});
				next unless $scores{$score_id}{"tag"} eq "rank";
				next if $scores{$score_id}{"round_type"} eq "elim";
				next if $scores{$score_id}{"round_type"} eq "final";
				$entry_cume{$scores{$score_id}{"entry"}} += $scores{$score_id}{"value"};
			}

			foreach my $entry_id (@entries) {
				$entries{$entry_id}{$rule_id} += $points
					if $entry_cume{$entry_id} == $place;
			}

		}

		if ($rule_tag eq "prelim_seed") {

			my $limit = $rule->place;
			my $points = $rule->value;
			my %done;

			foreach my $event (@events) {

				next unless $event && $event->id;

				foreach my $place (
					sort {$a <=> $b}
					keys %{$prelim_seeding{$event->id} }
				)  {

					next if $place > $limit;

					foreach my $entry_id (@{$prelim_seeding{$event->id}{$place}}) {

						next if $done{$entry_id}++;

						$entries{$entry_id}{$rule_id} += $points;

					}
				}
			}
		}

		if ($rule_tag eq "rev_per_place") {

			my $round_type = $rule->count;

			foreach my $event (@events) {

				next unless $event && $event->id;

				foreach my $round ($event->rounds) {

					next if $skip_round{$round->id};
					next unless $round->type eq $round_type;


					my ($entries_ref, $tbs_ref, $desc_ref, $forfeit_ref)
						= $m->comp("/tabbing/results/order_entries.mas",
						round => $round
					);

					my %panel_place;

					foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {

						foreach my $entry_id (@{${$entries_ref}{$key}}) {

							next if $novice_only && not defined $entries{$entry_id}{"novice"};

							my $panel = $entries{$entry_id}{"round_panel"}{$round->id};
							$panel_place{$panel}++;

							my $points = 6 - $panel_place{$panel};
							$points = 1 if $points < 1;

							$entries{$entry_id}{$rule_id} += $points;
						}

					}
				}
			}
		}

		if ($rule_tag eq "points_per_composite_rank") {

			my $round_type = $rule->count;

			foreach my $event (@events) {

				next unless $event && $event->id;

				foreach my $round ($event->rounds) {

					next if $skip_round{$round->id};
					next unless $round->type eq $round_type;

					my ($entries_ref, $tbs_ref, $desc_ref, $forfeit_ref)
						= $m->comp("/tabbing/results/order_entries.mas",
							round         => $round,
							composite_set => $rule->tiebreak_set
					);

					my %panel_place;

					foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {

						foreach my $entry_id (@{${$entries_ref}{$key}}) {

							next if $novice_only && not defined $entries{$entry_id}{"novice"};

							my $panel = $entries{$entry_id}{"round_panel"}{$round->id};
							$panel_place{$panel}++;

							my $points = $rule->value
								if $panel_place{$panel} == $rule->place;

							$points = 0 if $points < 1;

							$entries{$entry_id}{$rule_id} += $points;
						}
					}
				}
			}
		}

		if ($rule_tag eq "rev_composite" && $rule->tiebreak_set) {

			my $round_type = $rule->count;
			my $tiebreak_set = $rule->tiebreak_set;

			foreach my $event (@events) {

				next unless $event && $event->id;

				foreach my $round ($event->rounds) {

					next if $skip_round{$round->id};

					next unless ($round->type eq $round_type)
						|| $round_type eq "all";

					my @results = $m->comp(
						"/tabbing/results/order_entries.mas",
							round        => $round,
							tiebreak_set => $tiebreak_set,
							section_rank => 1
					);

					my $entries_ref = pop @results;

					my %panel_place;

					foreach my $entry_id (sort {$a <=> $b} keys %{$entries_ref->{"section_rank"}}) {

						my $rank = $entries_ref->{"section_rank"}{$entry_id};

						next unless $rank;

						my $points = 6 - $rank;
						$points = 1 if $points < 1;

						$entries{$entry_id}{$rule_id} += $points;
					}
				}
			}
		}

		if (
			$rule_tag eq "rev_overall"
			|| $rule_tag eq "rev_overall_base"
			|| $rule_tag eq "place"
			|| $rule_tag eq "place_above"
			|| $rule_tag eq "rev_per_overall_place"
			|| $rule_tag eq "nsda_place"
		) {

			my $round_type   = $rule->count;
			my $tiebreak_set = $rule->tiebreak_set;

			unless ($placement_done eq $round_type."-".$tiebreak_set) {

				foreach my $event (@events) {

					if ($nsda_nats) {

						my $result_entries = $m->comp("/tabbing/report/nsda/final_placement.mas",
							event          => $event,
							tourn          => $tourn,
							tourn_settings => \%tourn_settings
						);

						foreach my $entry_id (keys %{$result_entries}) {
							$entries{$entry_id}{"placement"} = $result_entries->{$entry_id}{"place"};
							$entry_placement_event{$event->id}{$entry_id} = $entries{$entry_id}{"placement"};
						}

					} else {

						my $pilot++ if $tourn_settings{"nsda_pilot_".$event->type};

						next unless $event && $event->id;

						my @rounds = sort {$b->name <=> $a->name} $event->rounds();
						next unless @rounds;

						if ($districts && ($event->type eq "speech" || $event->type eq "debate")) {
							my $final;
							foreach my $round (@rounds) {
								$final = $round if $round->type eq "final";
								last if $final;
							}
							$tiebreak_set = $final->tiebreak_set if $final;
						}

						my $did_stuff;

						foreach my $round (@rounds) {

							next if $skip_round{$round->id};
							next unless ($round->type eq $round_type) || ($round_type eq "all");

							if ($pilot && $round->type ne "final" && $round->type ne "elim") {
								$tiebreak_set = $rule->tiebreak_set;
							}

							my @results = $m->comp(
								"/tabbing/results/order_entries.mas",
									round        => $round,
									tiebreak_set => $tiebreak_set
							);

							my $entries_ref = pop @results;
							my $counter;

							foreach my $key (sort {$a <=> $b} keys %{${$entries_ref}{"by_place"}}) {
								foreach my $entry_id (@{${${$entries_ref}{"by_place"}}{$key}}) {
									next if $entries{$entry_id}{"placement"};
									$entries{$entry_id}{"placement"} = $key;
									$entry_placement_event{$event->id}{$entry_id} = $key;
									$counter++;
								}
							}

							if ($counter) {
								last if $round->type eq "prelim";
								last if $round->type eq "highhigh";
								last if $round->type eq "highlow";
							}
						}

						$placement_done = $round_type."-".$tiebreak_set;
					}
				}
			}
		}

		if ($rule_tag eq "rev_overall" && $rule->tiebreak_set) {

			my $rule_id = $rule_id;

			foreach my $event (@events) {

				next unless $event > 0;
				my $event_id = $event->id;

				# The +1 is so the DFL entry doesn't get zero points and
				# therefore aren't told yet again how much THEY SUCK.

				# Because kindness matters or something -- CLP
				my $num_entries = scalar (keys %{$entry_placement_event{$event_id}}) + 1;

				my $multiplier = $rule->value;
				$multiplier = 1 unless $multiplier;

				foreach my $entry_id (keys %{$entry_placement_event{$event_id}}) {

					my $placement_points
						= ($num_entries - $entry_placement_event{$event_id}{$entry_id}) * $multiplier;

					$placement_points = 0 if $placement_points < 0;
					$entries{$entry_id}{$rule_id} = $placement_points;
				}
			}
		}

		if ($rule_tag eq "rev_overall_base" && $rule->tiebreak_set) {

			my $base = $rule->place;
			my $rule_id = $rule_id;

			foreach my $event (@events) {

				next unless $event > 0;
				my $event_id = $event->id;

				# The +1 is so the DFL entry doesn't get zero points and
				# therefore aren't told yet again how much THEY SUCK.

				# Because kindness matters or something -- CLP

				my $multiplier = $rule->value;
				$multiplier = 1 unless $multiplier;

				foreach my $entry_id (keys %{$entry_placement_event{$event_id}}) {

					my $placement_points = ($base - $entry_placement_event{$event_id}{$entry_id}) * $multiplier;

					$placement_points = 0 if $placement_points < 0;
					$entries{$entry_id}{$rule_id} = $placement_points;
				}
			}
		}

		if ($rule_tag eq "percentage" && $rule->tiebreak_set) {

			my $round_type = $rule->count;
			my $tiebreak_set = $rule->tiebreak_set;
			my $points = $rule->value;

			foreach my $event (@events) {

				next unless $event && $event->id;

				my @rounds;

				if ($round_type eq "all") {

					foreach my $round ($event->rounds) {
						next if $skip_round{$round->id};
						push @rounds, $round;
					}

				} elsif ($round_type eq "prelim") {

					foreach my $round ($event->rounds) {
						next if $skip_round{$round->id};
						push @rounds, $round if (
							$round->type ne "elim"
							&& $round->type ne "final"
						);
					}

				} elsif ($round_type eq "elim") {

					foreach my $round ($event->rounds) {
						next if $skip_round{$round->id};

						push @rounds, $round
							if $round->type eq "elim";
					}

				} elsif ($round_type eq "final") {

					foreach my $round ($event->rounds) {
						next if $skip_round{$round->id};
						push @rounds, $round
							if $round->type eq "final";
					}

				} elsif ($round_type eq "last_prelim") {

					my $last_prelim;

					foreach my $round ($event->rounds) {

						next if $skip_round{$round->id};
						next if $round->type eq "elim";
						next if $round->type eq "final";

						$last_prelim = $round
							if (not defined $last_prelim);

						$last_prelim = $round
							if $last_prelim
							&& $last_prelim->name < $round->name;
					}

					push @rounds, $last_prelim;

				}

				foreach my $round (@rounds) {

					my @results = $m->comp(
						"/tabbing/results/order_entries.mas",
							round        => $round,
							tiebreak_set => $tiebreak_set
					);

					my $entries_ref = pop @results;
					my $entries_count;

					foreach my $place (sort {$a <=> $b} keys %{$entries_ref->{"by_place"}}) {
						foreach my $entry_id (@{$entries_ref->{"by_place"}{$place}}) {
							$entries_count += scalar @{$entries_ref->{"by_place"}{$place}};
						}
					}

					my $threshold = POSIX::ceil($rule->place * .01 * $entries_count);

					foreach my $place (
						sort {$a <=> $b} keys %{$entries_ref->{"by_place"}}
					) {

						next if $place >= $threshold;
						if ($entries_ref->{"by_place"}{$place}) {
							foreach my $entry_id (@{$entries_ref->{"by_place"}{$place}}) {
								$entries{$entry_id}{$rule_id} += $points;
							}
						}
					}
				}
			}
		}

		if ($rule_tag eq "rev_per_overall_place") {
			foreach my $entry_id (@entries) {
				next unless $entries{$entry_id}{"placement"};
				my $points = 6 - $entries{$entry_id}{"placement"};
				$points = 0 unless $points;
				$entries{$entry_id}{$rule_id} += $points;
			}
		}

		if ($rule_tag eq "place_above") {
			my $points = $rule->value;
			foreach my $entry_id (@entries) {
				next unless $entries{$entry_id}{"placement"};
				next if $entries{$entry_id}{"placement"} > $rule->place;
				$entries{$entry_id}{$rule_id} += $points;
			}
		}

		if ($rule_tag eq "place") {
			foreach my $entry_id (@entries) {
				next unless $entries{$entry_id}{"placement"};
				next if $entries{$entry_id}{"placement"} != $rule->place;
				$entries{$entry_id}{$rule_id} += $places{$entries{$entry_id}{"placement"}};
			}
		}

		if ($rule_tag eq "nsda_place") {

			my %eseen = ();
			@entries = grep { ! $eseen{$_} ++ } @entries;

			foreach my $entry_id (@entries) {

				next unless $entries{$entry_id}{"placement"};
				next unless $entries{$entry_id}{"placement"} < 7;

				my $event = $event_include{$entries{$entry_id}{"event"}};
				my $baseline_score = 10;

				$baseline_score-- if $event->type eq "speech";
				$baseline_score-- if $event->type eq "congress";

				my $field_size = $event_count{$event};

				unless ($event->type eq "congress") {
					if ($event->setting("max_entry") > 1) {
						$baseline_score-- if $field_size < 50;
						$baseline_score-- if $field_size < 30;
					} else {
						$baseline_score-- if $field_size < 58;
						$baseline_score-- if $field_size < 38;
					}
				}

				my $points = 0;

				if (
					($entries{$entry_id}{"placement"} < 7)
					&& ($entries{$entry_id}{"placement"} > 0)
				) {

					$points = $baseline_score - $entries{$entry_id}{"placement"};
				}
				$entries{$entry_id}{$rule_id} += $points;

			}
		}

		if ($rule_tag eq "debate_win" || $rule_tag eq "debate_loss" ) {

			my $winner++ if $rule_tag eq "debate_win";
			my $points = $rule->value;
			my $count = $rule->count;

			SCORE:
			foreach my $score_id (keys %scores) {

				if ($count && $count ne "all") {
					next SCORE if $scores{$score_id}{"round_type"} ne $count;
				}

				my $entry_id = $scores{$score_id}{"entry"};
				next if $novice_only && (not defined $scores{$score_id}{"novice"});
				next unless $scores{$score_id}{"tag"} eq "winloss";

				if ($rule_tag eq "debate_win") {

					$entries{$entry_id}{$rule_id} += $points
						if $scores{$score_id}{"value"} == 1;
				}

				if ($rule_tag eq "debate_loss") {
					$entries{$entry_id}{$rule_id} += $points
						if $scores{$score_id}{"value"} == 0;
				}
			}
		}

		if ($rule_tag eq "debate_round_win" || $rule_tag eq "debate_round_loss" ) {

			my $winner++ if $rule_tag eq "debate_round_win";

			my $points = $rule->value;
			my $count = $rule->count;
			my @round_keys;
			my @entries;
			my %round_ballots_won;
			my %round_ballots_lost;

			SCORE:
			foreach my $score_id (keys %scores) {

				if ($count && $count ne "all") {
					next SCORE if $scores{$score_id}{"round_type"} ne $count;
				}

				my $entry_id = $scores{$score_id}{"entry"};
				my $round = $scores{$score_id}{"round_id"};

				next if $novice_only && (not defined $scores{$score_id}{"novice"});
				next unless $scores{$score_id}{"tag"} eq "winloss";

				$round_ballots_won{$entry_id}{$round}++
					if $scores{$score_id}{"value"} == 1;

				$round_ballots_lost{$entry_id}{$round}++
					if $scores{$score_id}{"value"} == 0;

				push @round_keys, $round
					if exists $scores{$score_id}{"value"};

				push @entries, $entry_id
					if exists $scores{$score_id}{"value"};
			}

			my %seen = ();
			@round_keys = grep { ! $seen{$_} ++ } @round_keys;

			my %eseen = ();
			@entries = grep { ! $eseen{$_} ++ } @entries;

			foreach my $key (@round_keys) {

				foreach my $entry_id (@entries) {

					if ($rule_tag eq "debate_round_win") {

						$entries{$entry_id}{$rule_id} += $points
							if $round_ballots_won{$entry_id}{$key} > $round_ballots_lost{$entry_id}{$key};

					} elsif ($rule_tag eq "debate_round_loss") {

						$entries{$entry_id}{$rule_id} += $points
							if $round_ballots_won{$entry_id}{$key} < $round_ballots_lost{$entry_id}{$key};
					}
				}
			}
		}

		if ($rule_tag eq "debate_round_bye") {

			my $points = $rule->value;
			my $count = $rule->count;

			foreach my $entry_id (@entries) {

				if ($count && $count ne "all" && $count ne "specific") {
					$entries{$entry_id}{$rule_id} += $entries{$entry_id}{"bye_type"}{$count} * $points;
				} else {
					$entries{$entry_id}{$rule_id} += $entries{$entry_id}{"byes"} * $points;
				}
			}
		}

		if ($rule_tag eq "points_per_po_round") {

			my $points = $rule->value;
			my $count = $rule->count;

			foreach my $entry_id (@entries) {

				my %rounds;

				SCORE:
				foreach my $score_id (@{$entries{$entry_id}{"scores"}}) {

					next unless $scores{$score_id}{"tag"} eq "po";

					unless ( (not defined $count) || $count eq "all") {
						next if $scores{$score_id}{"round_type"} eq "prelim" && $count ne "prelim";
						next if $scores{$score_id}{"round_type"} eq "elim" && $count ne "elim";
						next if $scores{$score_id}{"round_type"} eq "final" && $count ne "final";
					}

					next if $novice_only && (not defined $scores{$score_id}{"novice"});
					$rounds{$scores{$score_id}{"round_id"}}++;
				}
				$entries{$entry_id}{$rule_id} += ($points * (scalar (keys %rounds)));
			}
		}

		if ($rule_tag eq "manual") {
			foreach my $entry_id (@entries) {
				$entries{$entry_id}{$rule_id} += $entries{$entry_id}{"manual"};
			}
		}

		unless ($rules{$rule_id}{"tag"}) {

			$rules{$rule_id}{"short_tag"} = ucfirst($rule_tag);
			$rules{$rule_id}{"short_tag"} =~ s/points_per_po_round/PO/g;
			$rules{$rule_id}{"short_tag"} =~ s/points_per/Rnd/g;
			$rules{$rule_id}{"short_tag"} =~ s/place_above/Plc/g;
			$rules{$rule_id}{"short_tag"} =~ s/_/ /g;
			$rules{$rule_id}{"short_tag"} .= "  ".Lingua::EN::Numbers::Ordinate::ordinate($rule->place) if $rule->place;

			$rules{$rule_id}{"short_tag"} =~ s/Debate round win/Win/g;
			$rules{$rule_id}{"short_tag"} =~ s/Debate round loss/Loss/g;
			$rules{$rule_id}{"short_tag"} =~ s/Debate ballot win/BalWin/g;
			$rules{$rule_id}{"short_tag"} =~ s/Debate ballot loss/BalLoss/g;

			$rules{$rule_id}{"tag"} = ucfirst($rule_tag);
			$rules{$rule_id}{"tag"} =~ s/points_per_po_round/Elected PO/g;
			$rules{$rule_id}{"tag"} =~ s/points_per/In a round/g;
			$rules{$rule_id}{"tag"} =~ s/place_above/Placed above/g;
			$rules{$rule_id}{"tag"} =~ s/_/ /g;
			$rules{$rule_id}{"tag"} .= "  ".Lingua::EN::Numbers::Ordinate::ordinate($rule->place) if $rule->place;

			if ($rule->count && $rule->count ne "all") {
				$rules{$rule_id}{"tag"} .= " in ".ucfirst($rule->count)."s";
				$rules{$rule_id}{"tag"} =~ s/round//g;

				$rules{$rule_id}{"short_tag"} .= " in ".ucfirst($rule->count)."s";
				$rules{$rule_id}{"short_tag"} =~ s/round//g;
			}
		}

		foreach my $entry_id (@entries) {
			$entry_points{$entry_id} += $entries{$entry_id}{$rule_id};
			$entries{$entry_id}{"points"} += $entries{$entry_id}{$rule_id};
		}
	}

	foreach my $entry_id (keys %entries) {
		next if $entries{$entry_id}{"points"};
		delete $entries{$entry_id};
	}

	return \%rules, \%entries;

</%init>
