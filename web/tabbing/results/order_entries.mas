<%args>
	$round
	$nsda          => undef
	$seed_skip     => undef
	$skip_wins     => undef
	$breakout      => undef
	$opp_wins_only => undef
	$composite_set => undef
	$tiebreak_set  => undef
	$section_rank  => undef
	$all_entries   => undef
</%args>
<%init>

	return unless $round;
	use POSIX; 
	use Switch;
	use Math::Round qw(nearest);

	my $event = $round->event;
	my $event_type = $event->type;

	$event_type = "debate" 
		if $event_type eq "pf"
		|| $event_type eq "ld"
		|| $event_type eq "policy"
		|| $event_type eq "parli"
		|| $event_type eq "wsdc"
		|| $event_type eq "wudc";

	my $tourn = $event->tourn;

	my $seed = $tourn->start->epoch;

	my $this_round_name = $round->name;

	if ($composite_set) {

		# Check against composites of composites

		foreach my $tiebreak ($composite_set->tiebreaks) { 

			if ($tiebreak->child > 0) { 

				$m->print('<div class="main">');

				$m->print("<h3>No, not gonna do it</h3>");
				$m->print('<p class="strong redtext">You have a composite rank based on other composite ranks. </p>');
				$m->print('<p>That can lead to excessively long computation times and bring down the Tabroom server.</p>');
				$m->print('<p>Thus, they are not permitted.  Please reconfigure your tiebreakers</p>');

				$m->abort();

			}

		}

		$tiebreak_set = $composite_set;

	} elsif (not defined $tiebreak_set) { 

		$tiebreak_set = $round->tiebreak_set;

	}

	unless ($tiebreak_set) {  

		return if $nsda;

		my $err = "Round ".$round->realname." does not have a tiebreaker set applied to it.";
		$err .= "Please pick one and try again";
		$m->redirect("/setup/schedule/event.mhtml?event_id=".$event->id."&err=$err");
	}

	my %tb_settings = $tiebreak_set->all_settings;
	my %event_settings = $event->all_settings;
	my %tourn_settings = $tourn->all_settings;

	#Deduplicate Ballots
	$m->comp(
		"/funclib/event_dedupe.mas", 
		event => $event
	);

	#Settings
	my $mfl_time_violation = $tb_settings{"mfl_time_violation"};

	my $maverick_method = $event_settings{"mavericks"};
	$maverick_method = "average" unless $maverick_method;

	my $truncate = $tb_settings{"truncate_ranks_to"} 
		if $tb_settings{"truncate_ranks_to"};

	my $truncate_to_smallest = $tb_settings{"truncate_to_smallest"};

	my $truncate_prelims = $tb_settings{"truncate_prelims"};

	my $truncate_elims = $tb_settings{"truncate_elims"};

	my $truncate_finals = $tb_settings{"truncate_finals"};

	# This is for the purpose of determining NSDA points for posting

	if ($nsda) { 
		undef $truncate;
		undef $truncate_to_smallest;
		undef $truncate_prelims;
		undef $truncate_elims;
		undef $truncate_finals;
	}

	my $forfeits_never_break = $tb_settings{"forfeits_never_break"};

	my $wsdc_byes = $event_settings{"wsdc_bye_win_average"};

	$section_rank++ if $tb_settings{"equal_elims"};

	my $districts++ if $tourn_settings{"nsda_district"};

	my $round_robin++ if $event_settings{"round_robin"};
	my $team_points++ if $event_settings{"team_points"};

	undef $team_points if $event_type eq "congress"; # Redundant and harmful
	undef $team_points if $event_type eq "speech"; # Redundant and harmful

	undef $round_robin if $round->type eq "elim" || $round->type eq "final";

	my %tb_tiers = ();
	my %tb_count = ();
	my %tbid_tiers = ();

	foreach my $tb ($tiebreak_set->tiebreaks) { 

		$tb_count{$tb->id} = $tb->count;

		#This will only aggregate the present round for Points purposes.
		$tb_count{$tb->id} = "previous" if $nsda;

		if ($nsda && $round->type ne "elim" && $round->type ne "final") { 

			# If we're doing autopoints post on a prelim we have to not drop
			# scores or all will be tied.

			$tb->highlow("");
			$tb->highlow_count("");
		}
		push @{$tb_tiers{$tb->priority}}, $tb;
		push @{$tbid_tiers{$tb->priority}}, $tb->id;

	}   


	# Get the data you'll need for Teh Sortingz.
	my $dbh = Tab::DBI->db_Main();

	my %entries = ();
	my %scores = ();
	my %panels = ();
	my %rounds = ();

	my %pods;

	my @event_rounds = $event->rounds;

	%{$rounds{"type"}} = map {$_->id => $_->type} @event_rounds;
	%{$rounds{"name"}} = map {$_->id => $_->name} @event_rounds;

	foreach my $round (@event_rounds) { 
		$rounds{"type"}{$round} = "prelim" 
			if $rounds{"type"}{$round} eq "preset" 
			|| $rounds{"type"}{$round} eq "highhigh" 
			|| $rounds{"type"}{$round} eq "highlow" 
			|| $rounds{"type"}{$round} eq "random" 
			|| $rounds{"type"}{$round} eq "power";
	}

	my @scores;
	my @entries;

	my $dropped_limit = " and entry.active = 1 ";
	undef $dropped_limit if $nsda;

	my $round_limit;

	my $sth = $dbh->prepare("
		select 
			entry.id, entry.code, entry.name, entry.dq, entry.school,
			round.type, round.name, round.id,
			score.id, score.tag, score.value, 
			ballot.id, ballot.judge, ballot.forfeit, ballot.bye, ballot.tv, ballot.chair,
			panel.id, panel.bye, panel.letter

		from (ballot, panel, round, entry)
		left join score on score.ballot = ballot.id
		where ballot.panel = panel.id
		and panel.round = round.id

		and not exists ( 
			select round_setting.id 
			from round_setting 
			where round_setting.tag = 'ignore_results' 
			and round_setting.round = round.id
		)

		and round.event = ?
		and ballot.entry = entry.id
		$dropped_limit
		and entry.waitlist != 1
		group by score.id, ballot.id
		order by round.event, round.name
	");

	$sth->execute($event->id);

	my %already = ();

	while (my (
		$entry_id, $entry_code, $entry_name, $entry_dq, $entry_school_id,
		$round_type, $round_name, $round_id,
		$score_id, $score_tag, $score_value,
		$ballot_id, $ballot_judge, $ballot_forfeit, $ballot_bye, $ballot_tv, $ballot_chair,
		$panel_id, $panel_bye, $panel_letter
		)  = $sth->fetchrow_array()
	) {

		push @{$rounds{"panels"}{$round_id}}, $panel_id;

		if ($all_entries) { 

			push @entries, $entry_id unless $already{$entry_id}++;
			$entries{"rounds"}{$entry_id}{$round_id}++;

		} else { 
			push @entries, $entry_id if $round_id == $round->id;
		}

		push @{$entries{"panels"}{$entry_id}}, $panel_id;

		unless ($entries{"round_panel"}{$entry_id}{$round_id}) { 
			$entries{"round_panel"}{$entry_id}{$round_id} = $panel_id;
			push @{$panels{"entries"}{$panel_id}}, $entry_id;
		}

		$entries{"code"}{$entry_id} = $entry_code;
		$entries{"name"}{$entry_id} = $entry_name;
		$entries{"school_id"}{$entry_id} = $entry_school_id;

		$entries{"dq"}{$entry_id} = $entry_dq if $entry_dq;

		$entries{"letter"}{$entry_id} = $panel_letter;

		$entries{"forfeit"}{$entry_id}++ if $ballot_forfeit;
		$entries{"round_forfeit"}{$round_id}{$entry_id}++ if $ballot_forfeit;
		$entries{"round_bye"}{$round_id}{$entry_id}++ if $ballot_bye;
		$entries{"round_panel_bye"}{$round_id}{$entry_id} = 1 if $panel_bye;

		$entries{"bye"}{$entry_id}++ if $panel_bye;

		if ($score_id) { 

			push @scores, $score_id;
			push @{$entries{"scores"}{$entry_id}}, $score_id;

			push @{$entries{"round_scores"}{$entry_id}{$round_id}}, $score_id;

			$scores{"tag"}{$score_id} = $score_tag;
			$scores{"value"}{$score_id} = $score_value;
			$scores{"panel"}{$score_id} = $panel_id;
			$scores{"judge"}{$score_id} = $ballot_judge;
			$scores{"round"}{$score_id} = $round_name;
			$scores{"chair"}{$score_id}++ if $ballot_chair;
			$scores{"tv"}{$score_id} = $ballot_tv;


		}

		$panels{"section"}{$panel_id} = $panel_letter;
		$panels{"roundname"}{$panel_id} = $round_name;
	}

	my %eligible = ();

	if ($breakout) { 

		my @breakout_settings = $m->comp(
			"/funclib/event_entry_settings.mas", 
			event => $event,
			tag   => "breakout_".$breakout
		);

		foreach my $bs (@breakout_settings) { 
			$eligible{$bs->entry->id}++;
		}

		if ($event_settings{"breakout_".$breakout."_exclude_elims"}) { 

			my @in_elims = $m->comp("/funclib/event_entries.mas", 
				event    => $event,
				in_elims => "yessiree!"
			);

			foreach my $in_elim (@in_elims) { 
				undef $eligible{$in_elim->id};
			}
		}

	}

	my @all_rounds;

	foreach my $all_round (@event_rounds) { 

		next if $rounds{"name"}{$all_round} > $this_round_name;  # Do not measure the future

		push @all_rounds, $all_round->id;

		# Uniq the panels so there's no double counting

		my %pseen = (); 

		@{$rounds{"panels"}{$all_round}} = 
			grep { ! $pseen{$_}++ } 
			@{$rounds{"panels"}{$all_round}};

		foreach my $panel (@{$rounds{"panels"}{$all_round}}) {   

			# Uniq the panel entries so there's no double counting;
			my %eseen = (); 

			@{$panels{"entries"}{$panel}} = 
				grep { ! $eseen{$_} ++ } 
				@{$panels{"entries"}{$panel}};
		}
	}

	my %dq_panel_threshold = ();
	my @keys = keys %{$entries{"dq"}};

	foreach my $entry (keys %{$entries{"dq"}}) { 

		next unless $entries{"dq"}{$entry};

		foreach my $score (@{$entries{"scores"}{$entry}}) { 

			next unless $scores{"tag"}{$score} eq "rank";

			$dq_panel_threshold{$scores{"panel"}{$score}."-".$scores{"judge"}{$score}} 
				= $scores{"value"}{$score};
		}

	}

	if ($truncate_to_smallest) { 

		foreach my $round (@all_rounds) { 

			next if $rounds{"type"}{$round} eq "elim" && not defined $truncate_elims;
			next if $rounds{"type"}{$round} eq "final" && not defined $truncate_finals;
			next if $rounds{"type"}{$round} eq "prelim" && not defined $truncate_prelims;

			$rounds{"truncate"}{$round} = $truncate if $truncate > 0; # Upper limit is the hard cap, if any

			foreach my $panel (@{$rounds{"panels"}{$round}}) { 
				my $size = scalar @{$panels{"entries"}{$panel}} if $panels{"entries"}{$panel};
				next unless $size > 0;
				$rounds{"truncate"}{$round} = $size unless $rounds{"truncate"}{$round};
				$rounds{"truncate"}{$round} = $size if $rounds{"truncate"}{$round} > $size;
			}

		}
	}

	my %eseen = (); 
	@entries = grep { ! $eseen{$_} ++ } @entries;

	my %max_score_count;

	if ($round && ($round->type eq "elim" || $round->type eq "final")) { 

		#Eliminate everyone who has not advanced to the elim round in question.

		my @counted;
		my %last_round;
		my %done;

		foreach my $entry (@entries) { 

			next if $done{$entry}++;

			my @panels = @{$entries{"panels"}{$entry}};

			foreach my $panel (@{$entries{"panels"}{$entry}}) { 
				$last_round{$entry} = $panels{"roundname"}{$panel} 
					if $last_round{$entry} < $panels{"roundname"}{$panel};
			}

			next if $last_round{$entry} < $this_round_name;
			push @counted, $entry;
		}

		@entries = @counted;

	} elsif ($event_type eq "debate" || $team_points) { 

		# Balance scores for mavericks

		foreach my $entry (@entries) { 

			foreach my $score (@{$entries{"scores"}{$entry}}) { 
				next if $scores{"round"}{$score} > $this_round_name;

				$entries{"score_count"}{$entry."-".$scores{"tag"}{$score}."-".$scores{"round"}{$score}}++ 
					if $scores{"value"}{$score} > 0;
			}

			foreach my $score (@{$entries{"scores"}{$entry}}) { 

				$max_score_count{$scores{"tag"}{$score}} 
				= $entries{"score_count"}{$entry."-".$scores{"tag"}{$score}."-".$scores{"round"}{$score}}

				if $entries{"score_count"}{$entry."-".$scores{"tag"}{$score}."-".$scores{"round"}{$score}} 
				> $max_score_count{$scores{"tag"}{$score}};
			}
		}

	} elsif ($team_points) {
		$max_score_count{"rank"} = 1;
		$max_score_count{"points"} = 1;
	}

	my %tier_descs = ();
	my %tier_long_descs = ();
	my %tier_dir = ();

	my $win_loss;
	my $judge_var;

	my %composite_rounds;

	my $opp_seed;
	my $own_seed;

	$win_loss++ if $opp_wins_only;

	foreach my $key (sort {$a <=> $b} keys %tb_tiers) { 

		foreach my $tb (sort {$a <=> $b} @{$tb_tiers{$key}}) { 

			$opp_seed++ if $tb->name eq "opp_seed";
			$own_seed++ if $tb->name eq "seed";

			$win_loss++ if $tb->name eq "winloss";
			$win_loss++ if $tb->name eq "opp_wins";
			$win_loss++ if $tb->name eq "ballots";

			$judge_var++ if $tb->name eq "judgevar";
			$judge_var++ if $tb->name eq "judgevar2";

			if ($tb->child > 0) { 

				foreach my $round (@all_rounds) { 

					if ($rounds{"type"}{$round} eq "prelim") { 
					
						push @{$composite_rounds{$tb->id}}, $round 
							if $rounds{"type"}{$round} eq "prelim";

						push @{$composite_rounds{$tb->id}}, $round 
							if $rounds{"type"}{$round} eq "highhigh";

						push @{$composite_rounds{$tb->id}}, $round 
							if $rounds{"type"}{$round} eq "highlow";

					} elsif ($rounds{"type"}{$round} eq $tb_count{$tb->id}) { 

						push @{$composite_rounds{$tb->id}}, $round;

					} elsif ($tb_count{$tb->id} eq "all") { 

						push @{$composite_rounds{$tb->id}}, $round;

					}
				}

			}

			if ($tb->name eq "winloss"
				||$tb->name eq "opp_wins"
				||$tb->name eq "ballots"
			) { 

				if ($tb_count{$tb->id} eq "previous") { 

					%{$entries{"tb_wins"}{$tb->id}} = 
						$m->comp("/funclib/entry_wins.mas", 
							event => $event,
							round => $round,
							last  => 1
						);

				} elsif ($tb_count{$tb->id} eq "all") { 

					%{$entries{"tb_wins"}{$tb->id}} 
						= $m->comp("/funclib/entry_wins.mas", 
							event => $event,
							round => $round
						);

				} else { 

					%{$entries{"tb_wins"}{$tb->id}} 
						= $m->comp("/funclib/entry_wins.mas", 
							event => $event,
							round => $round,
							type  => $tb_count{$tb->id}
						);

				}

			}

			if ($tb->name eq "losses") { 

				if ($tb_count{$tb->id} eq "previous") { 

					%{$entries{"tb_losses"}{$tb->id}} = 
						$m->comp("/funclib/entry_losses.mas", 
							event => $event,
							round => $round,
							last  => 1
						);

				} elsif ($tb_count{$tb->id} eq "all") { 

					%{$entries{"tb_losses"}{$tb->id}} 
						= $m->comp("/funclib/entry_losses.mas", 
							event    => $event,
							round    => $round,
							elimstoo => 42
						);

				} else { 

					%{$entries{"tb_losses"}{$tb->id}} 
						= $m->comp("/funclib/entry_losses.mas", 
							event => $event,
							round => $round,
							type  => $tb_count{$tb->id}
						);

				}

			}

		}

	}


	# The factors that going into calculating jvar and jvar2 (aka z scores)

	my ($judge_avg_ref, $judge_ballot_count_ref, $judge_total_ref, $judge_stddev_ref, 
		$total_avg, $total_std, 
		$judge_z2_avg_ref, $judge_z2_ballot_count_ref, $judge_z2_total_ref, $judge_z2_stddev_ref) 

		= $m->comp("/funclib/judge_points_average.mas", event => $event) if $judge_var;


	# Calculate the composite ranks if that's a thing:

	foreach my $key (sort {$a <=> $b} keys %tb_tiers) { 

		foreach my $tb (sort {$a <=> $b} @{$tb_tiers{$key}}) { 
	
			#Avoid recursion
			next if $tb->child && $tb->child == $tiebreak_set;

			my %comp_seen = (); 

			my @comp_rounds =  @{$composite_rounds{$tb->id}} if $composite_rounds{$tb->id};

			@comp_rounds = grep { ! $comp_seen{$_} ++ } @comp_rounds;

			foreach my $round_id (@comp_rounds) { 

				my $rank_round = Tab::Round->retrieve(int($round_id));

				my @results = $m->comp(
					"/tabbing/results/order_entries.mas", 
					round        => $rank_round,
					tiebreak_set => $tb->child,
					section_rank => 1
				);

				my $full_entries_ref = pop @results;

				foreach my $panel (@{$rounds{"panels"}{$rank_round}}) { 

					foreach my $entry (@{$panels{"entries"}{$panel}}) { 

						my $rank = $full_entries_ref->{"section_rank"}{$entry};

						$entries{"composite_rank"}{$entry}{$rank_round} = $rank;
						$entries{"composite_rank_count"}{$panel}{$rank}++;
					} 

				}

			}

		}

	}

	my $opp_ranks;
	my $opp_points;
	my $ranks;
	my $points;

	if ($event_type eq "debate") {

		ENTRY:
		foreach my $entry (@entries) { 

			foreach my $this_round (@all_rounds) { 

				next if $rounds{"type"}{$this_round} eq "elim";
				next if $rounds{"type"}{$this_round} eq "final";

				next if $entries{"round_bye"}{$this_round}{$entry};
				next if $entries{"round_panel_bye"}{$this_round}{$entry};

				my %erseen = ();  

				@{$entries{"round_scores"}{$entry}{$this_round}} = 
					grep { ! $erseen{$_}++ } @{$entries{"round_scores"}{$entry}{$this_round}};

				unless (scalar @{$entries{"round_scores"}{$entry}{$this_round}} > 0) { 

					$entries{"forfeit"}{$entry}++;
					next ENTRY;
				}

			}
		}
	}

	my $bye_min;

	if ($round_robin) { 
		
		my @pods = $m->comp("/funclib/event_entry_settings.mas", 
			tag   => "pod",
			event => $event
		);

		%{$entries{"pod"}} = map {$_->entry->id => $_->value} @pods;

		foreach my $entry (sort {$entries{"bye"}{$b} <=> $entries{"bye"}{$a}} @entries) { 

			push @{$pods{$entries{"pod"}{$entry}}}, $entry;

			$bye_min = $entries{"bye"}{$entry} 
				if $entries{"bye"}{$entry} 
				&& not defined $bye_min;

			$bye_min = $entries{"bye"}{$entry} 
				if $entries{"bye"}{$entry} < $bye_min;
		}
	}

	my $test_round;
	my $seed_skipper++;

	if ($opp_seed || $own_seed) { 

		$test_round = $round if ($round->type ne "elim" && $round->type ne "final");

		unless ($test_round) { 

			my $test_round_id;

			foreach my $round (@all_rounds) { 
				$test_round_id = $round if $rounds{"type"}{$round} eq "prelim";
			}
			$test_round = Tab::Round->retrieve($test_round_id);
			undef $seed_skipper;
		}
	}

	if ($opp_seed && not defined $seed_skip) { 
		
		my ($entries_ref, @others) = 
			$m->comp("/tabbing/results/order_entries.mas", 
				round     => $test_round,
				seed_skip => $seed_skipper);

		foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
			foreach my $entry (@{${$entries_ref}{$key}}) {
				$entries{"opp_seed"}{$entry} = $key;
			}
		}

	}

	if ($own_seed && not defined $seed_skip) { 

		my ($entries_ref, @others) = 
			$m->comp("/tabbing/results/order_entries.mas", 
				round     => $test_round,
				seed_skip => $seed_skipper);

		foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
			foreach my $entry (@{${$entries_ref}{$key}}) {
				$entries{"seed"}{$entry} = $key;
			}
		}
	}

	my $seed_done;
	my $opp_seed_done;
	my $opp_wins_done;

	foreach my $key (sort keys %tb_tiers) { 

		my $tier_desc;
		my $tier_long_desc;

		next if $seed_done && $seed_skip;
		next if $opp_seed_done && $seed_skip;
		next if $opp_wins_done && $opp_wins_only;

		foreach my $tb (sort {$a <=> $b} @{$tb_tiers{$key}}) { 

			my $tb_name = $tb->name;

			# Tiebreakers where high values are better
			
			$tier_dir{$key} = "down" if (
				$tb_name eq "winloss" 
				|| $tb_name eq "reciprocals" 
				|| $tb_name eq "points" 
				|| $tb_name eq "ballots" 
				|| $tb_name eq "rounds" 
				|| $tb_name eq "judgepref" 
				|| $tb_name eq "headtohead" 
				|| $tb_name eq "opp_points" 
				|| $tb_name eq "opp_wins" 
				|| $tb_name eq "judgevar" 
				|| $tb_name eq "recipinround" 
				|| $tb_name eq "judgevar2"
			);

			# Tiebreakers where low values are better

			$tier_dir{$key} = "up" if (
				$tb_name eq "ranks" 
				|| $tb_name eq "opp_seed" 
				|| $tb_name eq "seed" 
				|| $tb_name eq "opp_ranks" 
				|| $tb_name eq "chair_ranks" 
				|| $tb_name eq "rankinround" 
				|| $tb_name eq "downs" 
				|| $tb_name eq "losses" 
				|| $tb_name eq "coinflip"
			);

			$tier_desc .= "+" if $tier_desc;

			$tier_long_desc .= "+" if $tier_long_desc;

			switch ($tb_name) { 

				case "ranks" {
					$tier_desc .= "Rk"; 
					$tier_long_desc .= "Ranks";
					$ranks++;
				}

				case "reciprocals" {
					$tier_desc .= "Rcp";
					$tier_long_desc .= "Reciprocals";
					$ranks++;
				}

				case "points" {
					$points++;
					$tier_desc .= "Pts";
					$tier_long_desc .= " Entry" if $team_points;
					$tier_long_desc .= " Points";
				}

				case "judgepref" {
					$tier_desc .= "JP";
					$tier_long_desc .= "Judge Preferences";
				}

				case "headtohead" {
					$tier_desc .= "H2H";
					$tier_long_desc .= "Head to Head Ballots";
				}

				case "coinflip" {
					$tier_desc .= "Rand";
					$tier_long_desc .= "Random";
				}

				case "opp_ranks" {
					$tier_desc .= "ORk";
					$tier_long_desc .= "Opponents Ranks";
					$opp_ranks++;
				}

				case "chair_ranks" {
					$tier_desc .= "CRk";
					$tier_long_desc .= "Chair Judge Ranks";
				}

				case "winloss" {
					$tier_desc .= "Prev " if $tb_count{$tb->id} eq "previous";
					$tier_desc .= "Win";
					$tier_long_desc .= "Wins";
				}

				case "losses" {
					$tier_desc .= "Prev " if $tb_count{$tb->id} eq "previous";
					$tier_desc .= "Loss";
					$tier_long_desc .= "Losses";
				}

				case "downs" {
					$tier_desc .= "Dwn";
					$tier_long_desc .= "Ranked Down (Bottom Half of Room)";
				}

				case "seed" {
					$tier_desc .= "Sd";
					$tier_long_desc .= "Prelim Seed Position";
					$own_seed++;
				}

				case "opp_seed" {
					$tier_desc .= "OSd";
					$tier_long_desc .= "Opponent Seed Position";
					$opp_seed++;
				}

				case "opp_wins" {
					$tier_desc .= "OpW";
					$tier_long_desc .= "Opponent Wins";
				}

				case "opp_points" {
					$tier_desc .= "OPt";
					$tier_long_desc .= "Opponent Points";
					$opp_points++;
				}

				case "judgevar" {
					$tier_desc .= "Z1";
					$tier_long_desc .= "ZScore1: Judge Points Variance";
				}

				case "judgevar2" {
					$tier_desc .= "Z2";
					$tier_long_desc .= "ZScore2: Sample Judge Points Variance";
				}

				case "ballots" {
					$tier_desc .= "Bal";
					$tier_long_desc .= "Ballot Total";
				}

				case "rounds" {
					$tier_desc .= "Rnds";
					$tier_long_desc .= "Rounds Debated In";
				}
			}

			my $tb_highlow = $tb->highlow;

			if ($tb_highlow) {

				$tier_desc .= " -".$tb->highlow_count;
				$tier_long_desc .= " -".$tb->highlow_count;

				if ($tb_highlow == 1 || $tb_highlow == 2) { 
					$tier_desc .= "HL";
					$tier_long_desc .= " Best & Worst";
				}

				if ($tb_highlow == 3) { 
					$tier_desc .= "H";
					$tier_long_desc .= " Best";
				}

				if ($tb_highlow == 4) { 
					$tier_desc .= "L";
					$tier_long_desc .= " Worst";
				}
			}

			if ($tb->child > 0 ) { 
				$tier_desc = "C".$tier_desc;
				$tier_long_desc .= " Composite based on ".$tb->child->name;
			}

			$tier_long_desc .= " in ".ucfirst($tb_count{$tb->id})." round(s) " 
				if $tb_count{$tb->id};

			$tier_long_desc .= " Rounds" if $tb_count{$tb->id} && ($tb_count{$tb->id} eq "all");

			$tier_long_desc .= "s" 
				if $tb_count{$tb->id} 
				&& ($tb_count{$tb->id} eq "prelim" || $tb_count{$tb->id} eq "elim");

			$tier_long_desc .= " multplied by ".$tb->multiplier 
				if $tb->multiplier != 1;

			$tier_desc .= " x".$tb->multiplier if $tb->multiplier != 1;

			if ($opp_wins_only) { 
				$tier_desc = "OpW";
				$tier_long_desc = "Opponent Wins";
			}

			$points++ if $opp_points;
			$opp_ranks++ if $opp_ranks;

		}

		$tier_desc = "SOP" if $tier_desc eq "Sd+OSd";
		$tier_desc = "SOP" if $tier_desc eq "OSd+Sd";

		$tier_descs{$key} = $tier_desc;
		$tier_long_descs{$key} = $tier_long_desc;

		my %tb_info = ();

		foreach my $tb (@{$tb_tiers{$key}}) { 

			$tb_info{$tb->id}{"name"}          = $tb->name;
			$tb_info{$tb->id}{"child"}         = $tb->child->id if $tb->child;
			$tb_info{$tb->id}{"highlow"}       = $tb->highlow;
			$tb_info{$tb->id}{"truncate"}      = $tb->truncate;
			$tb_info{$tb->id}{"multiplier"}    = $tb->multiplier;
			$tb_info{$tb->id}{"highlow_count"} = $tb->highlow_count;

			foreach my $oround (@all_rounds) { 

				if ($rounds{"type"}{$oround} eq $tb_count{$tb->id}) { 
					push (@{$tb_info{$tb->id}{"rounds"}}, $oround);
				}

				if ($tb_count{$tb->id} eq "all") { 
					push (@{$tb_info{$tb->id}{"rounds"}}, $oround);
				}

				if ($tb_count{$tb->id} eq "previous" && $rounds{"name"}{$oround} == $round->name) { 
					push (@{$tb_info{$tb->id}{"rounds"}}, $oround);
				}
			}

		}

		ENTRY:
		foreach my $entry (@entries) { 

			my %seen = (); 
			@{$entries{"panels"}{$entry}} = grep { ! $seen{$_} ++ } @{$entries{"panels"}{$entry}};

			my $tier_total;

			foreach my $tb (@{$tbid_tiers{$key}}) { 

				my $name = $tb_info{$tb}{"name"};

				next unless $tb_info{$tb}{"rounds"};

				my @rounds = @{$tb_info{$tb}{"rounds"}};

				my $tb_highlow = $tb_info{$tb}{"highlow"};

				my $tb_highlow_count = $tb_info{$tb}{"highlow_count"};


				if ($opp_wins_only) { 
					$name = "opp_wins";
					$opp_wins_done++;
					undef @rounds;
					undef $tb_highlow;

					foreach my $oround (@all_rounds) { 
						push (@rounds, $oround) 
							if $rounds{"type"}{$oround} ne "elim" 
							&& $rounds{"type"}{$oround} ne "final";
					}
				}

				my $total; 

				# WINS WINLOSS 

				if ($name eq "winloss") { 

					$total += sprintf("%d", 100 * $entries{"tb_wins"}{$tb}{$entry}) unless $skip_wins;

				# LOSSES 

				} elsif ($name eq "losses") { 

					$total += sprintf("%d", 100 * $entries{"tb_losses"}{$tb}{$entry}) unless $skip_wins;

				# RANKS RANKINGS RECIPS RECIPROCALS ONES TWOS

				} elsif (
					$name eq "ranks" 
					|| $name eq "reciprocals" 
					|| $name eq "chair_ranks"
				) { 

					my @drop_best;
					my @drop_worst;

					my $count;
					my $bye;

					my $local_truncate = $tb_info{$tb}{"truncate"};

					foreach my $this_round (@rounds) { 

						$bye += $max_score_count{"rank"} 
							if $entries{"round_panel_bye"}{$this_round}{$entry};

						$bye += $max_score_count{"rank"} 
							if $entries{"round_bye"}{$this_round}{$entry} 
							&& not defined $entries{"round_scores"}{$entry}{$this_round};

						$bye += $max_score_count{"rank"} 
							if $entries{"round_forfeit"}{$this_round}{$entry} 
							&& not defined $entries{"round_scores"}{$entry}{$this_round};

						next if $entries{"round_panel_bye"}{$this_round}{$entry};

						next if $entries{"round_bye"}{$this_round}{$entry} 
							&& not defined $entries{"round_scores"}{$entry}{$this_round};

						next if $entries{"round_forfeit"}{$this_round}{$entry} 
							&& not defined $entries{"round_scores"}{$entry}{$this_round};

						my %used_scores;
						my $round_count;
						my $round_score;
						my %round_done;

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) { 

							next if $round_done{$entry}{$this_round};

							if ($scores{"tag"}{$score} eq "rank") { 

								my $rank;

								if ($tb_info{$tb}{"child"}) { 

									$rank = $entries{"composite_rank"}{$entry}{$this_round};
									$round_done{$entry}{$this_round}++;

								} else {

									next if $name eq "chair_ranks" 
										&& $scores{"chair"}{$score} < 1;

									next if $used_scores{$score}++;

									$round_count++;
								
									$rank = $scores{"value"}{$score};
							
									if ($dq_panel_threshold{$scores{"panel"}{$score}."-".$scores{"judge"}{$score}}) { 
										$rank-- if $dq_panel_threshold{$scores{"panel"}{$score}."-".$scores{"judge"}{$score}} < $rank;
									}

									# Bump the rank up if it's a time
									# violation.  Truncation below will correct
									# if this makes it bigger (ie if the TV was
									# last place);

									$rank++ if $scores{"tv"}{$score} && $mfl_time_violation;

									if (
										(	$rounds{"type"}{$this_round} eq "prelim" 
											&& defined $truncate_prelims
										) || (
											$rounds{"type"}{$this_round} eq "final" 
											&& defined $truncate_finals
										) || (
											$rounds{"type"}{$this_round} eq "elim" 
											&& defined $truncate_elims) 
										) { 

										# Promote anyone over the hard cap for truncation
										$rank = $truncate if $truncate && $rank > $truncate;

										# Promote anyone over the per-round floating cap for truncation
										$rank = $rounds{"truncate"}{$this_round} 
											if $truncate_to_smallest 
											&& $rank > $rounds{"truncate"}{$this_round};
									
									}

									if ($local_truncate) { 
										#Tiebreaker specific truncation limit
										$rank = $local_truncate if $rank > $local_truncate;
									}

									#Rank cannot be greater than the size of the round
									my $panel_id = $entries{"round_panel"}{$entry}{$this_round};

									$rank = scalar @{$panels{"entries"}{$panel_id}} 
										if $rank > scalar @{$panels{"entries"}{$panel_id}}
										&& $event_type ne "debate";

								}

								$round_score += sprintf("%d", 100 * $rank) 
									if $name eq "ranks" 
									|| $name eq "chair_ranks";

								$total += sprintf("%d", 100 * ( 1 / $rank )) 
									if $rank > 0 
									&& $name eq "reciprocals";

								$count++ if $name eq "ranks";

								if ($tb_highlow) {  

									#drop the best

									if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 3) {

										if (scalar @drop_best < $tb_highlow_count) {
											push @drop_best, $rank;
										} else {
											my $least_best = pop @drop_best;
											push @drop_best, $least_best if $least_best <= $rank;
											push @drop_best, $rank if $least_best > $rank;
										}

										@drop_best = sort {$b <=> $a} @drop_best;
									}

									#drop the worst

									if (
										$tb_highlow == 1 
										|| $tb_highlow == 2 
										|| $tb_highlow == 4
									) {

										if (scalar @drop_worst < $tb_highlow_count) {

											push @drop_worst, $rank;

										} else {

											my $least_worst = pop @drop_worst;

											push @drop_worst, $least_worst 
												if $least_worst >= $rank;

											push @drop_worst, $rank 
												if $least_worst < $rank;

										}

										@drop_worst = sort {$a <=> $b} @drop_worst;
									}
								}
							}
						}

						if ($name eq "ranks" || $name eq "chair_ranks") {

							if ($maverick_method eq "double") { 

								if ($round_count && $round_count < $max_score_count{"rank"}) {
									$round_score = $round_score * $max_score_count{"rank"} / $round_count;
									$count +=  ($max_score_count{"rank"} / $round_count) - 1;
								}

							}

							if ($maverick_method eq "average") { 
								if ($round_count && $round_count < $max_score_count{"rank"}) {
									$round_score += 4;
									$count +=  ($max_score_count{"rank"} / $round_count) - 1;
								}
							}
						}

						$total += sprintf("%d", $round_score) 
							if $name eq "ranks" 
							|| $name eq "chair_ranks";


					}

					$bye = $bye - ($bye_min * $max_score_count{"rank"}) if $round_robin;

					my $average;

					if ($bye) { 
						$average = $total / $count if $count;
						$total += sprintf("%d", ($average * $bye));
					}

                    foreach my $rank (@drop_best, @drop_worst) {
                        $total -= sprintf("%d", 100 * $rank) 
							if $name eq "ranks" 
							|| $name eq "chair_ranks";

                        $total -= sprintf("%d", 100 * (1 / $rank)) 
							if $rank 
							&& $name eq "reciprocals";

						$count-- if $name eq "ranks";
						$total = 0 if $total < 0;
                    }

					$entries{"ranks"}{$entry} = $total / $count if $count;
	
				# DOWNS DOUBLEDOWN DROPS DOUBLEDROPS

				} elsif ($name eq "downs") { 

					foreach my $this_round (@rounds) { 

						my $panel_id = $entries{"round_panel"}{$entry}{$this_round};

						my $rank = $entries{"composite_rank"}{$entry}{$this_round};

						my $rank_count = $entries{"composite_rank_count"}{$panel_id}{$rank};

						my $size_of_panel = 
							scalar @{$panels{"entries"}{$panel_id}}
							if $panels{"entries"}{$panel_id};

						my $first_limit = floor($size_of_panel / 2);
						my $absolute_limit = ceil($size_of_panel / 2);

						$absolute_limit++ if $first_limit == $absolute_limit;

						# The NSDA.  Where formulas take a backseat to lists. 

						if ($districts) { 

							switch ($size_of_panel) { 

								case (4) { 
									$first_limit    = 2;
									$absolute_limit = 4;
								}

								case (5) { 
									$first_limit    = 3;
									$absolute_limit = 4;
								}

								case (6) { 
									$first_limit    = 3;
									$absolute_limit = 4;
								}

								case (7) { 
									$first_limit    = 3;
									$absolute_limit = 4;
								}

							}

						}

						my $rank_position = $rank + ($rank_count - 1);

						if ($rank_count > 1) { 

							$total++ if $rank > $absolute_limit;

						} else { 

							$total++ if $rank > $first_limit;
						}

					}

					$total = $total * 100;


				# SPEAKS SPEAKER POINTS
				} elsif ($name eq "points") { 

					my $bye;
					my $count;
					my $averages;
					my $num_rounds;

					my @drop_best;
					my @drop_worst;
					my %points_have_bye;

					foreach my $this_round (@rounds) { 

						$num_rounds++;

						$bye += $max_score_count{"points"}  
							if $entries{"round_panel_bye"}{$this_round}{$entry};
						
						next if $entries{"round_panel_bye"}{$this_round}{$entry};

						my $round_count;
						my $round_score;
						my %judge_points;

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) { 

							if ($scores{"tag"}{$score} eq "points" 
								|| $scores{"tag"}{$score} eq "rebuttal_points"
							) { 

								my $points = sprintf("%d", 100 * $scores{"value"}{$score});

								$count++;
								$round_count++;

								$judge_points{$this_round."-".$scores{"judge"}{$score}} 
									+= sprintf("%d", 100 *$scores{"value"}{$score});

								$round_score += $points;
							}

						}

						my $average_round_count;

						unless ($team_points) {

							if ($maverick_method eq "double") { 

								if ($round_count && $round_count < $max_score_count{"points"}) {
									$count +=  ($max_score_count{"points"} / $round_count) - 1;
									$round_score = $round_score * $max_score_count{"points"} / $round_count;
								}

							} elsif ($maverick_method eq "average") { 

								if ($round_count && $round_count < $max_score_count{"points"}) {
									$average_round_count++;
									$count +=  ($max_score_count{"points"} / $round_count) - 1;
									$averages += ($max_score_count{"points"} / $round_count) - 1;
								}
							}
						}

						if ($round_count) { 

							unless ($round_score) { 
								$bye += $round_count if $entries{"round_bye"}{$this_round}{$entry};
								$bye += $round_count if $entries{"round_forfeit"}{$this_round}{$entry};
							}

						} elsif ($event_type eq "debate") { 

							unless (defined $round_score) { 
								$bye += $max_score_count{"points"} if $entries{"round_bye"}{$this_round}{$entry};
								$bye += $max_score_count{"points"} if $entries{"round_forfeit"}{$this_round}{$entry};
							}

							unless ($bye) { 
								$average_round_count += $max_score_count{"points"};
								$count += $max_score_count{"points"};
								$averages += $max_score_count{"points"};
							}

						}

						# This judgekey thing deals with multi judge prelims

						foreach my $judgekey (keys %judge_points) { 
							
							my $points = $judge_points{$judgekey};

							if ($tb_highlow) { 			

								if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 3) {

									if (scalar @drop_best < $tb_highlow_count) {
										push @drop_best, $points;
									} else {
										my $least_best = shift @drop_best;
										push @drop_best, $least_best if $least_best >= $points;
										push @drop_best, $points if $least_best < $points;
									}

									@drop_best = sort {$a <=> $b} @drop_best;
								}

								#drop the worst

								if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 4) {

									if (scalar @drop_worst < $tb_highlow_count) {
										push @drop_worst, $points;
									} else {
										my $least_worst = shift @drop_worst;
										push @drop_worst, $least_worst if $least_worst <= $points;
										push @drop_worst, $points if $least_worst > $points;
									}

									@drop_worst = sort {$b <=> $a} @drop_worst;
								}
							}
						}

						$total += $round_score;
						next if $bye && not defined $round_score;
						$points_have_bye{$round_score} = $average_round_count;

					
					}

					$bye = $bye - ($bye_min * $max_score_count{"points"}) if $round_robin;

					my $average;

					if ($bye) { 
						$average = $total / $count if $count;
						$total += sprintf("%d", $average * $bye);
						$count += $bye;
					}

					if ($averages) { 

						$average = $total / ($count - $averages) 
							if $count && ($count - $averages) > 0;

						$total += sprintf("%d", $average * $averages);
						$count += $averages;
					}

					my $how_many  = $count / (scalar @rounds) if scalar @rounds;

					if ($tb_highlow) { 
						if ($tb_highlow == 1 || $tb_highlow == 2) { 
							$how_many -= 2 * $tb_highlow_count;
						} else { 
							$how_many -= $tb_highlow_count;
						}
					}

                    foreach my $points (@drop_best, @drop_worst) {
					
						next unless $tb_highlow;
                        $total -= sprintf("%d", $points);
						$total -= sprintf("%d", $average * $points_have_bye{$points});
						$total = 0 if $total < 0;
						$count--;
                    }

					$total = sprintf("%d", $total / $how_many) 
						if $team_points && $how_many;

					$entries{"points"}{$entry} += ($total / $count) 
						if $count; #used for opp wins and opp points.

				# BALLOT COUNT BALLOTS

				} elsif ( $name eq "ballots") { 

					my $bye;
					my $ballot_score;
					my $ballot_round_count;

					foreach my $this_round (@rounds) { 

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) { 

							if ($scores{"tag"}{$score} eq "ballot") { 
								$ballot_score++ if $scores{"value"}{$score} == 1;
							}

						}
			
						if ($entries{"round_bye"}{$this_round}{$entry} 
							|| $entries{"round_panel_bye"}{$this_round}{$entry}) {

							$bye++;
						} else { 
							$ballot_round_count++;
						}

					}

					$bye = $bye - $bye_min if $round_robin;

					if ($bye) { 

						if ($wsdc_byes) { 
					
							my $ballot_average = ($ballot_score / $ballot_round_count);
							$ballot_score += $ballot_average * $bye;

						} else {

							$ballot_score += ($max_score_count{"ballot"} * $bye);

						}
					}

					$total += sprintf("%d", 100 * $ballot_score);

				# ROUNDS DEBATED IN

				} elsif ( $name eq "rounds") { 					

					my $num_rounds;

					foreach my $this_round (@rounds) { 
						$num_rounds++ if $entries{"rounds"}{$entry}{$this_round};
					}

					$total += sprintf("%d", 100 * $num_rounds);
					
				# COINFLIP RANDOM
				} elsif ( $name eq "coinflip") { 

					# This is only semi random; product of the date epoch and
					# the random entry ID's last four digits.  But it will be
					# the same every time this function is run and random
					# enough in that it cannot be pre-guessed easily.

					my $random_seed = $entry * $seed;
					$total = substr($random_seed, -8, -5);

				# JUDGEPREF

				} elsif ( $name eq "judgepref") { 

					my $chosen_panel;
					my @chosen_entries;

					my $local_truncate = $tb_info{$tb}{"truncate"};

					foreach my $this_round (@rounds) { 

						# Only counts in the current round;

						PANEL:
						foreach my $panel (@{$rounds{"panels"}{$this_round}}) {    

							my @entries = @{$panels{"entries"}{$panel}};
							next PANEL unless grep {$_ == $entry} @entries;
							$chosen_panel = $panel;
							@chosen_entries = @entries;
						} 

						my %beseen = (); 
						@chosen_entries = grep { ! $beseen{$_} ++ } @chosen_entries;

						my $entry_string;

						foreach my $okey (sort keys %tb_tiers) { 
							next if $key == $okey;
							$entry_string .= "-" if $entry_string;
							$entry_string .= $entries{"tbs"}{$entry."-".$okey};
						}

						my @ties;

						foreach my $oentry (@chosen_entries) { 

							next if $oentry == $entry;

							my $test_string;

							foreach my $okey (sort keys %tb_tiers) { 
								next if $key == $okey;
								$test_string .= "-" if $test_string;
								$test_string .= $entries{"tbs"}{$oentry."-".$okey};
							}

							push(@ties, $oentry) if $test_string eq $entry_string;
						}

						if (scalar @ties == 1) { 

							my $tie_id = shift @ties;

							my %judge_score = ();

							if ($chosen_panel && $entry) { 

								my %done;

								foreach my $score (@{$entries{"scores"}{$entry}}) { 

									next if $done{$score}++;
									next unless $scores{"tag"}{$score} eq "rank";
									next unless $scores{"panel"}{$score} == $chosen_panel;
									$judge_score{$scores{"judge"}{$score}} = $scores{"value"}{$score};

									$judge_score{$scores{"judge"}{$score}} = $local_truncate 
										if $local_truncate 
										&& $judge_score{$scores{"judge"}{$score}};

								}

								# If my rank is better (lower) than the tie's
								# rank, I get a JP point

								foreach my $tie_score (@{$entries{"scores"}{$tie_id}}) {

									next if $done{$tie_score}++;
									next unless $scores{"tag"}{$tie_score} eq "rank";
									next unless $scores{"panel"}{$tie_score} == $chosen_panel;

									$total += 100 
										if $scores{"value"}{$tie_score} > 
											$judge_score{$scores{"judge"}{$tie_score}}; 


								}
							}
						}
					}

				} elsif ( $name eq "headtohead") { 

					my $chosen_panel;
					my @chosen_entries;

					foreach my $this_round (@rounds) { 

						# Only counts in the current round;

						PANEL:
						foreach my $panel (@{$rounds{"panels"}{$this_round}}) {    
							my @entries = @{$panels{"entries"}{$panel}};
							next PANEL unless grep {$_ == $entry} @entries;
							$chosen_panel = $panel;
							@chosen_entries = @entries;
						} 

						my %beseen = (); 
						@chosen_entries = grep { ! $beseen{$_} ++ } @chosen_entries;

						my $entry_string;

						foreach my $okey (sort keys %tb_tiers) { 
							next if $key == $okey;
							$entry_string .= "-" if $entry_string;
							$entry_string .= $entries{"tbs"}{$entry."-".$okey};
						}

						my @ties;

						foreach my $oentry (@chosen_entries) { 
							next if $oentry == $entry;
							my $test_string;
							foreach my $okey (sort keys %tb_tiers) { 
								next if $key == $okey;
								$test_string .= "-" if $test_string;
								$test_string .= $entries{"tbs"}{$oentry."-".$okey};
							}
							push(@ties, $oentry) if $test_string eq $entry_string;
						}

						if (scalar @ties == 1) { 

							my $tie_id = shift @ties;
							my %panel_ballots = ();

							if ($chosen_panel && $entry) { 

								my %done;
								foreach my $score (@{$entries{"scores"}{$entry}}) { 
									next if $done{$score}++;
									next unless $scores{"tag"}{$score} eq "ballot";
									next unless $scores{"panel"}{$score} == $chosen_panel;
									$panel_ballots{$chosen_panel} += $scores{"value"}{$score};
									$total += 100 if $scores{"value"}{$score} > 0;
								}
							}
						}
					}

				} elsif ( $name eq "opp_wins") { 

					my $count;
					my $sub_total;

					foreach my $panel (@{$entries{"panels"}{$entry}}) { 

						next if $panels{"roundname"}{$panel} > $this_round_name;

						foreach my $other (@{$panels{"entries"}{$panel}}) { 

							next if $other == $entry;
							$sub_total += $entries{"tb_wins"}{$tb}{$other};
							$count++;

						}
					}

					$total += sprintf "%.2d", 100 * $sub_total/$count if $count;

				} elsif ( $name eq "opp_points") { 

					my $count;
					my $sub_total;

					foreach my $panel (@{$entries{"panels"}{$entry}}) { 

						next if $panels{"roundname"}{$panel} > $this_round_name;

						foreach my $other (@{$panels{"entries"}{$panel}}) { 
							next if $other == $entry;

							$sub_total += $entries{"points"}{$other};
							$count++;
						}
					}

					$total += sprintf "%d", $sub_total / $count if $count;

				} elsif ( $name eq "opp_ranks") { 

					my $count;
					my $sub_total;

					foreach my $panel (@{$entries{"panels"}{$entry}}) { 

						next if $panels{"roundname"}{$panel} > $this_round_name;

						foreach my $other (@{$panels{"entries"}{$panel}}) { 
							next if $other == $entry;
							$sub_total += $entries{"ranks"}{$other};
							$count++;
						}
					}

					$total += sprintf "%d", $sub_total / $count if $count;

				} elsif ( $name eq "seed") { 

					$seed_done++;
					$total += sprintf "%d", 100 * $entries{"seed"}{$entry};

				} elsif ( $name eq "opp_seed") { 

					$opp_seed_done++;
					my $count;
					my $sub_total;

					foreach my $panel (@{$entries{"panels"}{$entry}}) { 

						next if $panels{"roundname"}{$panel} > $this_round_name;

						foreach my $other (@{$panels{"entries"}{$panel}}) { 
							next if $other == $entry;
							$sub_total += $entries{"opp_seed"}{$other};
							$count++;
						}
					}

					$total += sprintf "%d", 100 * $sub_total / $count if $count;

				} elsif ( $name eq "judgevar") { 

					my $sub_total;
					my $sub_count;
					my $sub_byes;

					foreach my $this_round (@rounds) { 

						my $round_done;

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) { 

							next unless $scores{"tag"}{$score} eq "points";   #No rebuttal points here either

							my $judge_avg  = ${$judge_avg_ref}{$scores{"judge"}{$score}};
							my $judge_stddev  = ${$judge_stddev_ref}{$scores{"judge"}{$score}};

							next unless $judge_stddev > 0;

							$sub_total += ( (  ($scores{"value"}{$score} - $judge_avg) / $judge_stddev) * $total_std) + $total_avg;
							$sub_count++;
							$round_done++;
						}

						$sub_byes++ unless $round_done;
					}

					my $average = ($sub_total / $sub_count) if $sub_count;
					$total += sprintf "%d", 100 * $average * $sub_byes if $sub_byes;
					$total += sprintf "%d", 100 * $sub_total;

				} elsif ($name eq "judgevar2") { 

					my $sub_total;
					my $sub_count;
					my $sub_byes;

					foreach my $this_round (@rounds) { 

						my $round_done;

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) { 
							next unless $scores{"tag"}{$score} eq "points";

                            my $judge_avg  = ${$judge_avg_ref}{$scores{"judge"}{$score}};
                            my $judge_stddev  = ${$judge_stddev_ref}{$scores{"judge"}{$score}};

                            # These sample only the schools/stddevs for the
                            # debaters the judge has judged, not all debaters.

                            my $judge_sample_avg  = ${$judge_z2_avg_ref}{$scores{"judge"}{$score}};
                            my $judge_sample_stddev  = ${$judge_z2_stddev_ref}{$scores{"judge"}{$score}};

                            next unless $judge_stddev > 0; 

                            $sub_total += 
								( 
									(
										($scores{"value"}{$score} - $judge_avg) 
										/ $judge_stddev
									) 
									* $judge_sample_stddev
								) + $judge_sample_avg;


							$sub_count++;
							$round_done++;

						}

						$sub_byes++ unless $round_done;
					}

					my $average = ($sub_total / $sub_count) if $sub_count;
					$total += sprintf "%d", 100 * $average * $sub_byes if $sub_byes;
					$total += sprintf "%d", 100 * $sub_total;

				}

				$tier_total += $total * $tb_info{$tb}{"multiplier"} if $tb_info{$tb}{"multiplier"};

			}

			$entries{"tbs"}{$entry."-".$key} = $tier_total;
			$entries{"tiebreak"}{$key}{$entry} = $tier_total;
			
		}

	}


	if ($opp_points || $opp_ranks) { 
		
		my $err;

		if ($opp_points &! $points) { 
			$err .= " Danger Will Robinson!<br /> You have defined Opp Points as ";
			$err .= " a tiebreaker without first defining Points.  That cannot work";
			$err .= " both technically and philosophically.  Fix please! <br /><br />";
		}

		if ($opp_ranks &! $ranks) { 
			$err .= " Danger Will Robinson!<br />You have defined Opp Ranks as a ";
			$err .= " tiebreaker without first defining Ranks.  That cannot work both";
			$err .= " technically and philosophically.  Fix please!";
		}

		$m->redirect("/setup/rules/tiebreaks.mhtml?tiebreak_set_id=".$tiebreak_set->id."&err=$err") if $err;

	}


	foreach my $key (reverse sort {$a <=> $b} keys %tb_tiers) { 

		@entries = sort { $entries{"tbs"}{$a."-".$key} <=> $entries{"tbs"}{$b."-".$key} } @entries 

			if $tier_dir{$key} eq "up";

		@entries = sort { $entries{"tbs"}{$b."-".$key} <=> $entries{"tbs"}{$a."-".$key} } @entries 
			if $tier_dir{$key} eq "down";

	}


	if ($section_rank) { 

		foreach my $panel (@{$rounds{"panels"}{$round->id}}) { 

			my @pan_entries = @{$panels{"entries"}{$panel}};

			foreach my $key (reverse sort keys %tb_tiers) { 

				@pan_entries = sort { $entries{"tbs"}{$a."-".$key} <=> $entries{"tbs"}{$b."-".$key}  } 
					@pan_entries if $tier_dir{$key} eq "up";

				@pan_entries = sort { $entries{"tbs"}{$b."-".$key} <=> $entries{"tbs"}{$a."-".$key} } 
					@pan_entries if $tier_dir{$key} eq "down";
			}

			my %already; 

			my $count;
			my $delayed_count;
			my $last_count;
			my $last_string;

			foreach my $panel_entry (@pan_entries) { 

				my $tier_string = tier_string($panel_entry, \%tb_tiers, \%entries);

				if ($tier_string eq $last_string) { 
					$delayed_count++;
				} else {
					$count++;
					$count += $delayed_count;

					$last_string = $tier_string;
					undef $delayed_count;
				}

				next if $already{$panel_entry}++;

				next if $entries{"dq"}{$panel_entry};

				push @{$entries{"panel_order"}{$panel}{$count}}, $panel_entry if $panel_entry;

				$entries{"section_rank"}{$panel_entry} = $count;
				$entries{"section"}{$panel_entry} = $panels{"section"}{$panel};

				$entries{"panel"}{$panel_entry} = $panel;

			}

			if ($tourn_settings{"nsda_speech_method"} eq "california_2" ||
				$tourn_settings{"nsda_speech_method"} eq "california_3") { 

				# At NSDA districts, California plan, three way ties should get
				# the MIDDLE ranking.

				foreach my $place (sort keys %{$entries{"panel_order"}{$panel}}) { 

					if (scalar @{$entries{"panel_order"}{$panel}{$place}} == 3) { 

						@{$entries{"panel_order"}{$panel}{($place + 1)}} 
							= @{$entries{"panel_order"}{$panel}{$place}};

						@{$entries{"panel_order"}{$panel}{$place}} = ();

						delete $entries{"panel_order"}{$panel}{$place};

					}

				}

				foreach my $place (keys %{$entries{"panel_order"}{$panel}}) { 

					foreach my $panel_entry (@{$entries{"panel_order"}{$panel}{$place}}) { 
						$entries{"section_rank"}{$panel_entry} = $place;
					}

				}

			}

		}
	
		@entries = sort { $entries{"section"}{$a} cmp $entries{"section"}{$b} } @entries;

		@entries = sort { length($entries{"section"}{$a}) <=> length($entries{"section"}{$b}) } @entries;

		@entries = sort { $entries{"section_rank"}{$a} <=> $entries{"section_rank"}{$b} } @entries;


	} elsif ($round_robin) { 

		foreach my $seed (keys %pods) { 

			my @pod_entries = @{$pods{$seed}};

			foreach my $key (reverse sort {$a <=> $b} keys %tb_tiers) { 
				@pod_entries = sort { $entries{"tbs"}{$a."-".$key} <=> $entries{"tbs"}{$b."-".$key}  } 
					@pod_entries if $tier_dir{$key} eq "up";

				@pod_entries = sort { $entries{"tbs"}{$b."-".$key} <=> $entries{"tbs"}{$a."-".$key} } 
					@pod_entries if $tier_dir{$key} eq "down";
			}

			my $count = 1;

			my %already; 

			foreach my $pe (@pod_entries) { 
				next if $already{$pe};
				next if $entries{"dq"}{$pe};
				$already{$pe}++;
				$entries{"section_rank"}{$pe} = $count++;
				$entries{"section"}{$pe} = $seed;
				$entries{"panel"}{$pe} = $seed;
			}
		}
	
		@entries = sort { $entries{"section_rank"}{$a} <=> $entries{"section_rank"}{$b} } @entries;

	} else { 

		foreach my $panel (@{$rounds{"panels"}{$round->id}}) { 
			foreach my $pe (@{$panels{"entries"}{$panel}}) { 
				$entries{"section"}{$pe} = $panels{"section"}{$panel};
				$entries{"panel"}{$pe} = $panel;
			}
		}
	}

	@entries = 
		sort { $entries{"forfeit"}{$a} <=> $entries{"forfeit"}{$b} } @entries 
		if $forfeits_never_break;

	my $count;
	
	my $last_string;
	my $delayed_count;
	my $three_way;

	foreach my $entry (@entries) { 

		next if $entries{"dq"}{$entry};
		next if $breakout && not defined $eligible{$entry};

		my $tier_string = tier_string($entry, \%tb_tiers, \%entries);

		if ($tier_string eq $last_string) { 
			$delayed_count++;
		} else {
			$count++;
			$count += $delayed_count;
			undef $delayed_count;
		}

		$last_string = $tier_string;

		push (@{$entries{"by_place"}{$count}}, $entry);

		$entries{"seed"}{$entry} = $count;

		@{$entries{"by_place"}{$count}} = sort @{$entries{"by_place"}{$count}};

		#Normalize the 100x back to actual values
		foreach my $key (sort {$a <=> $b} keys %tb_tiers) { 

			$entries{"tbs"}{$entry."-".$key} 
				= $entries{"tbs"}{$entry."-".$key} / 100;

			$entries{"tbs"}{$entry."-".$key} 
				= nearest(.01, $entries{"tbs"}{$entry."-".$key});

			$entries{"tiebreak"}{$key}{$entry} 
				= $entries{"tiebreak"}{$key}{$entry} / 100;

			$entries{"tiebreak"}{$key}{$entry}
				= nearest(.01, $entries{"tiebreak"}{$key}{$entry});

		}
	}

	$entries{"tier_description"} = \%tier_descs;

	$entries{"tier_direction"} = \%tier_dir;

	$entries{"tier_long_description"} = \%tier_long_descs;

	return (
		$entries{"by_place"},
		$entries{"tbs"},
		\%tier_descs,
		$entries{"forfeit"},
		\%tier_dir,
		$entries{"section_rank"},
		$entries{"letter"},
		\%tier_long_descs,
		$entries{"code"},
		$entries{"bye"},
		$entries{"panel"},
		\%entries
	);  # <-- Hope to gradually replace all the above with just this. 


	sub tier_string { 

		my ($entry, $tb_tiers_ref, $entries_ref) = @_;

		my $tier_string;

		foreach my $key (sort {$a <=> $b} keys %{$tb_tiers_ref}) { 

			my $value = $entries_ref->{"tbs"}{$entry."-".$key} / 100;

			$value= nearest(.01, $value);

			$tier_string .= "-" if $tier_string;

			$tier_string .= $value;

		}

		return $tier_string;

	}

</%init>
