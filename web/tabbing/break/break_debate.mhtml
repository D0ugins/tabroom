<%args>
	$tourn
	$person
	$from_id         => undef
	$into_id         => undef
	$site_id         => undef
	$timeslot_id     => undef
	$tiebreak_set_id => undef
	$label           => undef
	$start           => undef
	$end             => undef
	$type            => undef
	$breakout        => undef
</%args>
<%init>

	use List::Util 'shuffle';

	my $from = Tab::Round->retrieve($from_id) if $from_id;
	my $into = Tab::Round->retrieve($into_id) if $into_id;

	if ($ARGS{"override"} > 0) {
		$end = $ARGS{"override"};
	}

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;
	my $now = DateTime->now(time_zone => $tz);

	unless ($from && $from > 0 && $into > 0 && $from->event) {
		$m->print("<div class='main'><h4>No rounds set to break from or into</h4>");
		$m->print("<p>Hit Back and try again</p></h4></div>");
	}

	my $event = $from->event;
	my %event_settings = $event->all_settings;

	$m->comp("/funclib/autopublish_round.mas", event => $event);

	my $ignore_schools = $event_settings{"school_debates_self"} if $from && $event;

	my $err;

	if ($into) {

		if ($from->type ne "elim") {
			$err .= "You must specify the starting seed of whom to break  " unless $start;
			$err .= "You must specify the ending seed of whom to break  " unless $end;
		}

		return $err if $ARGS{'return'} && $err;
		$m->redirect("index.mhtml?from_id=".$from_id."&into_id=".$into_id."&err=".$err) if $err;

		$into->tiebreak_set($tiebreak_set_id) if $tiebreak_set_id;
		$into->site($site_id) if $site_id;
		$into->timeslot($timeslot_id) if $timeslot_id;
		$into->label($label) if $label;
		$into->type($type) if $type;
		$into->update;

	} else {

		my $err = " Missing timeslot " unless $timeslot_id;
		$err .= " Missing site " unless ($site_id || $event_settings{"online"});

		if ($from->type ne "elim") {
			$err .= " Missing starting entry " unless $start;
			$err .= " Missing ending entry " unless $end;
		}

		$err .= " Missing tiebreaker set " unless $tiebreak_set_id;
		$err .= " Missing round type " unless $type;

		return $err if $ARGS{'return'} && $err;
		$m->redirect("index.mhtml?from_id=".$from."&preset_id=".$into."&err=".$err) if $err;

		my $judges = 1;
		$judges    = 3 if $type eq "elim";
		$judges    = 3 if $type eq "final";

		return $err if $ARGS{'return'} && $err;
		$m->redirect("index.mhtml?from_id=".$from."&err=".$err) if $err;

		my $timeslot = Tab::Timeslot->retrieve($timeslot_id);

		$into = Tab::Round->create({
			event        => $event->id,
			timeslot     => $timeslot_id,
			start_time   => $timeslot->start,
			tiebreak_set => $tiebreak_set_id,
			label        => $label,
			type         => $type
		});

		$into->setting('num_judges', $judges);
		$into->setting("use_for_breakout", $breakout);
		$m->comp("/funclib/renumber_rounds.mas", event_id => $event->id);

	}

	if ($from->id == $into->id) {
		my $err = "This would break ".$from->realname." into....".$into->realname;
		$err .= " You cannot advance a round into itself, or things get very strange very fast.";
		$err .= " Ask Mikaela Malsin how that goes. Try again.";
		return $err if $ARGS{'return'} && $err;
		$m->redirect("index.mhtml?from_id=".$from."&preset_id=".$into."&err=".$err) if $err;
	}

	my $bracket_label = "Bracket";

	if ($breakout > 0) {
		$bracket_label = $into->event->setting("breakout_".$breakout."_label")." Bracket";
	}

	my $bracket = Tab::ResultSet->search(
		event => $event->id,
		label => $bracket_label
	)->first;

	unless ($bracket) {
		$bracket = Tab::ResultSet->create({
			tourn     => $tourn->id,
			event     => $event->id,
			label     => $bracket_label,
			generated => $now,
			bracket   => 1
		});
	}

	my %keys = map {$_->tag => $_} $bracket->result_keys();

	if ($into->panels) {
		#Clear whatever is in this round
		$m->comp("/funclib/round_dump.mas",
			round  => $into,
			person => $person
		);
	}

    Tab::Result->set_sql(
		rm_bracket => "delete from result where round = ? and result_set = ? "
	);

	Tab::Result->sql_rm_bracket->execute($into->id, $bracket->id );

	my @results = $m->comp(
		"/tabbing/results/order_entries.mas",
			round    => $from,
			breakout => $breakout
	);

	my $dbh = Tab::DBI->db_Main();
	my $entries = pop @results;

	my %breaks;
	my %losers;
	my $max_loser;

	my $ineligibles = $m->comp(
		"/funclib/event_entry_settings.mas",
			event => $event,
			tag   => "no_elims",
			hash  => 1
	);

	my $count = 1;

	if ($from->type ne "elim" && $from->type ne "final") {

		SEED:
		foreach my $seed (sort {$a <=> $b} keys %{$entries->{"by_place"}}) {
			foreach my $entry (@{$entries->{"by_place"}{$seed}}) {

				next if $ineligibles->{$entry};
				if ($count >= $start && $count <= $end) {
					$breaks{$count} = $entry;
				} elsif ($count > $end) {
					last SEED;
				}
				$count++;
			}
		}

	} else {

		# Seeding elim to elim is determined by the bracket position from the
		# last elim.  If you defeat the 1 seed you become the 1 seed, etc

		my $sth = $dbh->prepare("
			select entry.id, panel.bracket
				from entry, ballot, panel
			where entry.id = ballot.entry
				and ballot.panel = panel.id
				and panel.round = ?
		");

		$sth->execute($from->id);

		while(
			my (
				$entry_id, $panel_bracket
			) = $sth->fetchrow_array()
		) {

			unless ($panel_bracket) {

				my $msg = "Your elim panels are horked.  There are no bracket numbers listed ";
				$msg .= "for each section so Tabroom cannot advance to the next debate.";

				$m->comp("/funclib/abort.mas",
					message => $msg
				);
			}

			$entries->{bracket}{$entry_id} = $panel_bracket;
		}

		my $num_advancers;

		foreach my $entry_id (sort keys %{$entries->{"tbs"}}) {

			if ($event_settings{"double_elimination"}) {

				if ($entries->{tbs}{$entry_id}{1} == 0) {

					# I advance to the winners bracket if I have no losses
					$breaks{$entries->{bracket}{$entry_id}} = $entry_id;
					$num_advancers++;

				} elsif ($entries->{tbs}{$entry_id}{1} == 1) {

					# I advance to the losers bracket if I have 1 loss
					$losers{$entries->{bracket}{$entry_id}} = $entry_id;
					$num_advancers++;

				}

			} else {

				# I advance if I won the last round
				if ($entries->{tbs}{$entry_id}{1} == 1) {
					$breaks{$entries->{bracket}{$entry_id}} = $entry_id;
				}
			}
		}

		if ($num_advancers == 2) {

			#Time for finals
			my %replace;

			foreach my $seed (keys %breaks, keys %losers) {

				my $entry_id = $breaks{$seed};
				$entry_id = $losers{$seed} unless $entry_id;
				next unless $entry_id;

				$seed = 2 if $seed > 2;

				$replace{$seed} = $entry_id;
			}

			%breaks = %replace;
			%losers = ();
		}
	}

	# Do the winner's bracket first.
	my $num_winners = scalar(keys %breaks);
	my $num_advancers = $num_winners + scalar(keys %losers);

	if (
		((scalar (keys %losers)) == 1)
		&& $num_winners == 1
	) {
		#Final round time
		%breaks = (%breaks, %losers);
		%losers = ();
	}

	# The target number must always be a power of 2 or else promoted up to the
	# next power of 2 and byes filled in.

	my $target_bracket = 1;

	while ($target_bracket < $num_winners) {
		$target_bracket = $target_bracket * 2;
	}

	Tab::debuglog("Target bracket is $target_bracket");

	my $master_seed = $target_bracket + 1;

	my %byes;
	my %debates;
	my %done;
	my $break_count;

	foreach my $seed (sort {$a <=> $b} keys %breaks) {

		my $entry_id = $breaks{$seed};

		my $result = Tab::Result->create({
			result_set => $bracket->id,
			entry      => $entry_id,
			round      => $into->id,
			rank       => $seed,
			place      => $seed
		});

		my $target = $master_seed - $seed;

		unless ($done{$entry_id}++) {

			my $debate_seed = $target;
			$debate_seed = $seed if $seed < $debate_seed;

			if ($breaks{$target} && $target != $seed) {

				# I have an opponent which adds up to my target!
				$debates{$debate_seed}{1} = $entry_id;
				$debates{$debate_seed}{0} = $breaks{$target};
				$done{$breaks{$target}}++;

			} else {
				# I have no such opponent which means this is a partial
				$byes{$debate_seed} = $entry_id;
			}
		}
	}

	if ($event_settings{"double_elimination"} && keys %losers) {

		# First establish the seed of the first-time losers.  They will by
		# default carry in the seeding from winner of the debate they just
		# lost, and need instead the seeding of the loser of the debate they
		# just lost.

		my $lowest_seed;
		my $highest_seed;

		foreach my $seed (keys %losers) {

			Tab::debuglog("Entry ".$entries->{"code"}{$losers{$seed}}." has seed $seed");

			if ($seed > $num_winners) {

				if ($highest_seed < $seed) {
					$highest_seed = $seed;
				}

				if ($lowest_seed > $seed || (not defined $lowest_seed)) {
					$lowest_seed = $seed;
				}

				Tab::debuglog("Highest is $highest_seed, lowest is $lowest_seed");
				next;
			}

			my $new_seed = $seed + $num_winners;

			$losers{$new_seed} = $losers{$seed};
			delete $losers{$seed};

			Tab::debuglog("Reassigned to seed $new_seed.");

			if ($lowest_seed > $new_seed
				|| (not defined $lowest_seed)
			) {
				$lowest_seed = $new_seed;
			}

			if ($highest_seed < $new_seed) {
				$highest_seed = $new_seed;
			}
			Tab::debuglog("Highest is $highest_seed, lowest is $lowest_seed");

		}

		foreach my $seed (keys %losers) {
			my $result = Tab::Result->create({
				result_set => $bracket->id,
				entry      => $losers{$seed},
				round      => $into->id,
				rank       => $seed,
				place      => $seed
			});
		}

		Tab::debuglog("I am here");

		my @seeds = sort ({$a <=> $b} keys %losers);

		# The bracket must also be a power of two; the top seeds are bye'd
		# until it is

		my $pure_byes = $from->setting("loser_bracket_byes");
		my $num_losers = $num_advancers - $num_winners;
		$num_losers += $pure_byes;

		my $bracket_limit = $num_losers;

		Tab::debuglog("Num losers is $num_losers with $num_advancers advancers, $pure_byes byes, and $num_winners winners");

		if ($num_losers % 2) {
			$bracket_limit--;
		}

		my $bracket_target = 1;

		Tab::debuglog("Bracket target is $bracket_target and limit is $bracket_limit");

		while ($bracket_target < $bracket_limit) {
			$bracket_target = $bracket_target * 2;
		}

		Tab::debuglog("Bracket target is now $bracket_target");

		unless ($num_losers == $bracket_target) {
			my $bye_count = $bracket_target - $bracket_limit;

			if ($num_losers % 2) {
				$bye_count++;
			}

			Tab::debuglog("Bye count is $bye_count, seeds is @seeds");

			while ($bye_count) {

				Tab::debuglog("Bye count is $bye_count and seeds is ".@seeds);

				if (@seeds) {
					my $seed = shift @seeds;
					$byes{$seed} = $losers{$seed};
					$bye_count--;
				} else {
					$bye_count--;
				}
			}

			Tab::debuglog("Lowest seed is $lowest_seed");

			while ($byes{$lowest_seed}) {
				$lowest_seed++;
			}

			Tab::debuglog("Clear");
		}

		# Find the target seeding
		my $seed_target = $lowest_seed + $highest_seed;

		Tab::debuglog("Seed target is $seed_target with $lowest_seed low seed and $highest_seed high seed");
		# Next we have to check for repeat debates in elims.  If a loser's
		# bracket round is going to be repeated the bracket is reversed,
		# otherwise it goes through.

		my $elim_sth = $dbh->prepare("
			select aff.id, neg.id, round.name

			from entry aff, entry neg, ballot ba, ballot bn, panel, round

			where round.event = ?
				and round.type = 'elim'
				and round.id = panel.round
				and panel.id = ba.panel
				and panel.id = bn.panel
				and ba.side = 1
				and bn.side = 2
				and ba.entry = aff.id
				and bn.entry = neg.id
		");

		$elim_sth->execute($event->id);

		my %repeats;

		while (
			my (
				$aff, $neg, $round_name
			) = $elim_sth->fetchrow_array()
		) {
			$repeats{$aff}{$neg} = $round_name;
		}

		my $repeated;

		foreach my $seed (@seeds) {

			my $entry_id = $losers{$seed};
			my $target_id = $losers{($seed_target - $seed)};

			if ($repeats{$entry_id}{$target_id}	|| $repeats{$target_id}{$entry_id}) {
				$repeated++;
				last;
			}
		}

		my $loser_debates;

		foreach my $seed (@seeds) {

			my $entry_id = $losers{$seed};
			next if $done{$entry_id}++;

			my $target_id;

			# Flip the brackets by aiming for the target seed to be one off;
			# only one possible matchup will exist.

			if ($repeated) {

				if ($seed % 2) {
					$target_id = $losers{($seed_target - $seed - 1)};
				} else {
					$target_id = $losers{($seed_target - $seed + 1)};
				}

			} else {

				#Otherwise pull the usual target
				$target_id = $losers{$seed_target - $seed};
			}

			$loser_debates++;

			if ($target_id) {

				$done{$target_id}++;
				$debates{$seed}{0} = $entry_id;
				$debates{$seed}{1} = $target_id;
				$done{$target_id}++;

			} else {

				$byes{$seed} = $entry_id;
			}
		}

		my $double_byes = ($num_winners / 2) - ($loser_debates);
		$into->setting("loser_bracket_byes", $double_byes) if $double_byes > 0;
	}

	my $letter = 1;
	$letter = "A" if $event_settings{"panel_labels"} eq "letters";

	my @debates;

	foreach my $seed (sort {$a <=> $b} keys %debates) {

		my $aff = $debates{$seed}{0};
		my $neg = $debates{$seed}{1};

		my $bye = 0;
		my %seed;

		if (
			(not defined $ignore_schools)
			&& ($entries->{"school_id"}{$aff} == $entries->{"school_id"}{$neg})
		) {
			$bye++;
			$seed{$aff} = $m->comp("/funclib/entry_seed.mas", entry => $aff);
			$seed{$neg} = $m->comp("/funclib/entry_seed.mas", entry => $neg);
		}


		my $panel = Tab::Panel->create({
			letter  => $letter,
			round   => $into->id,
			flight  => 1,
			bracket => $seed,
			bye     => $bye
		});

		Tab::debuglog("Creating a ballot for $aff on side aff with $neg on neg");

		my $ballot = Tab::Ballot->create({
			panel => $panel->id,
			judge => 0,
			entry => $aff,
			side  => 1
		});

		my $other_ballot = Tab::Ballot->create({
			panel => $panel->id,
			judge => 0,
			entry => $neg,
			side  => 2
		});

		if ($seed{$aff} < $seed{$neg}) {

            Tab::Score->create({
                ballot => $ballot->id,
                tag    => "winloss",
                value  => 1
            });

            Tab::Score->create({
                ballot => $other_ballot->id,
                tag    => "winloss",
                value  => 0
            });

		} else {

            Tab::Score->create({
                ballot => $ballot->id,
                tag    => "winloss",
                value  => 0
            });

            Tab::Score->create({
                ballot => $other_ballot->id,
                tag    => "winloss",
                value  => 1
            });

		}

		my $due_aff = $m->comp("/funclib/round_elim_dueaff.mas", panel => $panel);

		if ($due_aff != $aff) {
			$m->comp("/funclib/swap_sides.mas", panel => $panel);
		}

		$letter++;

	}

	foreach my $seed (sort keys %byes) {

		my $panel = Tab::Panel->create({
			letter  => $letter,
			round   => $into->id,
			flight  => 1,
			bracket => $seed,
			bye     => 1
		});

		my $ballot = Tab::Ballot->create({
			panel => $panel->id,
			judge => 0,
			entry => $byes{$seed},
			side  => 1
		});

		$letter++;
	}

	$into->created_at($now);
	$into->post_primary(0);  # People always do this
	$into->post_secondary(0);  # People always do this
	$into->post_feedback(0);  # People always do this
	$into->update();

	my $msg = ucfirst($type)." round sectioned";
	return $msg if $ARGS{'return'};
	$m->redirect("/panel/schemat/show.mhtml?round_id=".$into->id."&msg=$msg");

</%init>
