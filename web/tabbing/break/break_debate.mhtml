<%args>
	$tourn
	$person
	$from_id         => undef
	$into_id         => undef
	$site_id         => undef
	$timeslot_id     => undef
	$tiebreak_set_id => undef
	$label           => undef
	$start           => undef
	$end             => undef
	$type            => undef
	$breakout        => undef
</%args>
<%init>

	use List::Util 'shuffle';

	my $from = Tab::Round->retrieve($from_id) if $from_id;
	my $into = Tab::Round->retrieve($into_id) if $into_id;

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;
	my $now = DateTime->now(time_zone => $tz);

	unless ($from && $from > 0 && $into > 0 && $from->event) {
		$m->print("<div class='main'><h4>No rounds set to break from or into</h4>");
		$m->print("<p>Hit Back and try again</p></h4></div>");
	}

	my $event = $from->event;
	my %event_settings = $event->all_settings;

	$m->comp("/funclib/autopublish_round.mas", event => $event);

	my $ignore_schools = $event_settings{"school_debates_self"} if $from && $event;

	my $err;

	if ($into) {

		$err .= "You must specify the starting seed of whom to break  " unless $start;
		$err .= "You must specify the ending seed of whom to break  " unless $end;

		$m->redirect("index.mhtml?from_id=".$from_id."&into_id=".$into_id."&err=".$err) if $err;

		$into->tiebreak_set($tiebreak_set_id) if $tiebreak_set_id;
		$into->site($site_id) if $site_id;
		$into->timeslot($timeslot_id) if $timeslot_id;
		$into->label($label) unless $label;
		$into->type($type) unless $type;
		$into->update;

	} else {

		my $err = " Missing timeslot " unless $timeslot_id;
		$err .= " Missing site " unless $site_id;
		$err .= " Missing starting entry " unless $start;
		$err .= " Missing ending entry " unless $end;
		$err .= " Missing tiebreaker set " unless $tiebreak_set_id;
		$err .= " Missing round type " unless $type;
		$err .= " Missing site " unless $site_id;

		$m->redirect("index.mhtml?from_id=".$from."&preset_id=".$into."&err=".$err) if $err;

		my $judges = 1;
		$judges    = 3 if $type eq "elim";
		$judges    = 3 if $type eq "final";

		$m->redirect("index.mhtml?from_id=".$from."&err=".$err) if $err;

		my $timeslot = Tab::Timeslot->retrieve($timeslot_id);

		$into = Tab::Round->create({
			event        => $event->id,
			timeslot     => $timeslot_id,
			start_time   => $timeslot->start,
			tiebreak_set => $tiebreak_set_id,
			label        => $label,
			type         => $type
		});

		$into->setting('num_judges', $judges);
		$into->setting("use_for_breakout", $breakout);

		$m->comp("/funclib/renumber_rounds.mas", event_id => $event->id);

	}

	if ($from->id == $into->id) {
		my $err = "This would break ".$from->realname." into....".$into->realname;
		$err .= " You cannot advance a round into itself, or things get very strange very fast.";
		$err .= " Ask Mikaela Malsin how that goes. Try again.";
		$m->redirect("index.mhtml?from_id=".$from."&preset_id=".$into."&err=".$err) if $err;
	}

	my $bracket_label = "Bracket";

	if ($breakout > 0) {
		$bracket_label = $into->event->setting("breakout_".$breakout."_label")." Bracket";
	}

	my $bracket = Tab::ResultSet->search(
		event => $event->id,
		label => $bracket_label
	)->first;

	unless ($bracket) {
		$bracket = Tab::ResultSet->create({
			tourn     => $tourn->id,
			event     => $event->id,
			label     => $bracket_label,
			generated => $now,
			bracket   => 1
		});
	}

	my %keys = map {$_->tag => $_} $bracket->result_keys();

	#Clear whatever is in this round
	$m->comp("/funclib/round_dump.mas",
		round  => $into,
		person => $person
	);

    Tab::Result->set_sql(
		rm_bracket => "delete from result where round = ? and result_set = ? "
	);

	Tab::Result->sql_rm_bracket->execute($into->id, $bracket->id );

	my @results = $m->comp(
		"/tabbing/results/order_entries.mas",
			round    => $from,
			breakout => $breakout
	);

	my $dbh = Tab::DBI->db_Main();
	my $entries = pop @results;

	my %breaks;
	my %losers;

	my %ineligibles = $m->comp(
		"/funclib/event_entry_settings.mas",
			event => $event,
			tag   => "no_elims",
			hash  => 1
	);

	my $count = 1;

	if ($from->type ne "elim") {

		SEED:
		foreach my $seed (sort {$a <=> $b} keys %{$entries->{"by_place"}}) {

			foreach my $entry (@{$entries->{"by_place"}{$seed}}) {

				next if $ineligibles{$entry};

				if ($count >= $start && $count <= $end) {
					$breaks{$count} = $entry;
				} elsif ($count > $end) {
					last SEED;
				}

				$count++;
			}
		}

	} else {

		# Seeding elim to elim is determined by the bracket position from the
		# last elim.  If you defeat the 1 seed you become the 1 seed, etc

		my $sth = $dbh->prepare("
			select entry.id, panel.bracket
			from entry, ballot, panel
			where entry.id = ballot.entry
			and ballot.panel = panel.id
			and panel.round = ?
		");

		$sth->execute($from->id);

		while(
			my ($entry_id, $panel_bracket) = $sth->fetchrow_array()
		) {

			unless ($panel_bracket) {
				$m->comp("/funclib/abort.mas",
					message => "Your elim panels are horked.  There are no bracket numbers listed for each section so Tabroom cannot advance to the next debate."
				);
			}

			$entries->{bracket}{$entry_id} = $panel_bracket;
		}

		foreach my $entry_id (sort keys %{$entries->{"tbs"}}) {

			if ($event_settings{"double_elimination"}) {

				# I advance to the winners bracket if I have no losses
				if ($entries->{tbs}{$entry_id}{1} == 0) {
					$breaks{$entries->{bracket}{$entry_id}} = $entry_id;

				# I advance to the losers bracket if I have 1 loss
				} elsif ($entries->{tbs}{$entry_id}{1} == 1) {
					$losers{$entries->{bracket}{$entry_id}} = $entry_id;
				}

			} else {
				# I advance if I won the last round
				if ($entries->{tbs}{$entry_id}{1} == 1) {
					$breaks{$entries->{bracket}{$entry_id}} = $entry_id;
				}
			}
		}
	}

	# Do the winner's bracket first.
	my $num_advancers = scalar(keys %breaks);

	# The target number must always be a power of 2 or else promoted up to the
	# next power of 2 and byes filled in.

	my $target_bracket = 2;

	while ($target_bracket < $num_advancers) {
		$target_bracket = $target_bracket * 2;
	}

	my $master_seed = $target_bracket + 1;

	my %byes;
	my %debates;
	my %done;

	my $break_count;

	foreach my $seed (sort {$a <=> $b} keys %breaks) {

		my $entry_id = $breaks{$seed};

		my $result = Tab::Result->create({
			result_set => $bracket->id,
			entry      => $entry_id,
			round      => $into->id,
			rank       => $seed,
			place      => $seed
		});

		my $target = $master_seed - $seed;

		unless ($done{$entry_id}++) {

			if ($breaks{$target}) {
				# I have an opponent which adds up to my target!
				$debates{$seed}{1} = $entry_id;
				$debates{$seed}{0} = $breaks{$target};
				$done{$breaks{$target}}++;
			} else {
				# I have no such opponent which means this is a partial
				$byes{$seed} = $entry_id;
			}
		}
	}

	if ($event_settings{"double_elimination"}) {

		# First establish the seed of the first-time losers.  They will carry
		# in the seeding from winner of the debate they just lost, and need
		# instead the seeding of the loser of the debate they just lost.

		my $seed_factor = ($target_bracket * 2) + 1;

		foreach my $seed (keys %losers) {

			next if $seed > $num_advancers;
			my $new_seed = $seed_factor - $seed;
			$losers{$new_seed} = $losers{$seed};
			delete $losers{$seed};
		}

		foreach my $seed (keys %losers) {
			my $result = Tab::Result->create({
				result_set => $bracket->id,
				entry      => $losers{$seed},
				round      => $into->id,
				rank       => $seed,
				place      => $seed
			});
		}

		my @seeds = sort (keys %losers);

		# The bracket must also be a power of two; the top seeds are bye'd until it is

		my $num_losers = 1;
		while ($num_losers < scalar @seeds) {
			$num_losers = $num_losers * 2;
		}

		unless ($num_losers == scalar @seeds) {

			my $bye_count = $num_losers - scalar @seeds;

			while ($bye_count) {
				my $seed = shift @seeds;
				$byes{$seed} = $losers{$seed};
				$bye_count--;
			}
		}

		# Find the target seeding
		my $seed_sum;
		foreach my $seed (@seeds) {
			$seed_sum += $seed;
		}

		my $seed_target = (2 * $seed_sum) / (scalar @seeds);

		# Next we have to check for repeat debates in elims.  If a loser's
		# bracket round is going to be repeated the bracket is reversed,
		# otherwise it goes through.

		my $elim_sth = $dbh->prepare("
			select aff.id, neg.id

			from entry aff, entry neg, ballot ba, ballot bn, panel, round

			where round.event = ?
				and round.type = 'elim'
				and round.id = panel.round
				and panel.id = ba.panel
				and panel.id = bn.panel
				and ba.side = 1
				and bn.side = 2
				and ba.entry = aff.id
				and bn.entry = neg.id
		");

		$elim_sth->execute($event->id);

		my %repeats;

		while (
			my ($aff, $neg) = $elim_sth->fetchrow_array()
		) {
			$repeats{$aff}{$neg}++;
		}

		my $repeated;

		foreach my $seed (@seeds) {

			my $entry_id = $losers{$seed};
			my $target_id = $losers{$seed_target - $seed};

			if ($repeats{$entry_id}{$target_id}	|| $repeats{$target_id}{$entry_id}) {
				$repeated++;
				last;
			}
		}

		foreach my $seed (@seeds) {

			my $entry_id = $losers{$seed};
			next if $done{$entry_id}++;

			my $target_id;

			# Flip the brackets by aiming for the target seed to be one off;
			# only one possible matchup will exist.

			if ($repeated) {

				$target_id = $losers{$seed_target - $seed - 1};
				$target_id = $losers{$seed_target - $seed + 1} unless $target_id;

			} else {

				#Otherwise pull the usual target
				$target_id = $losers{$seed_target - $seed};
			}

			if ($target_id) {

				$done{$target_id}++;

				$debates{$seed}{0} = $entry_id;
				$debates{$seed}{1} = $target_id;
				$done{$target_id}++;

			} else {

				$byes{$seed} = $entry_id;
			}
		}
	}

	my $letter = 1;
	$letter = "A" if $event_settings{"panel_labels"} eq "letters";

	my @debates;

	foreach my $seed (sort keys %debates) {

		my $aff = $debates{$seed}{0};
		my $neg = $debates{$seed}{1};

		my $bye = 0;
		if ($entries->{"school_id"}{$aff} == $entries->{"school_id"}{$neg}) {
			$bye++;
		}

		my $panel = Tab::Panel->create({
			letter  => $letter,
			round   => $into->id,
			flight  => 1,
			bracket => $seed,
			bye     => $bye
		});

		my $ballot = Tab::Ballot->create({
			panel => $panel->id,
			judge => 0,
			entry => $aff,
			side  => 1
		});

		my $other_ballot = Tab::Ballot->create({
			panel => $panel->id,
			judge => 0,
			entry => $neg,
			side  => 2
		});

		my $due_aff = $m->comp("/funclib/round_elim_dueaff.mas", panel => $panel);

		if ($due_aff != $aff) {
			$m->comp("/funclib/swap_sides.mas", panel => $panel);
		}
	}

	foreach my $seed (sort keys %byes) {

		my $panel = Tab::Panel->create({
			letter  => $letter,
			round   => $into->id,
			flight  => 1,
			bracket => $seed,
			bye     => 1
		});

		my $ballot = Tab::Ballot->create({
			panel => $panel->id,
			judge => 0,
			entry => $byes{$seed},
			side  => 1
		});

		$letter++;
	}

	$into->created($now);
	$into->post_results(0);  # People always do this
	$into->update();

	my $msg = ucfirst($type)." round sectioned";
	$m->redirect("/panel/schemat/show.mhtml?round_id=".$into->id."&msg=$msg");

</%init>
