<%args>
	$tourn
	$person
	$from_id         => undef
	$into_id         => undef
	$site_id         => undef
	$timeslot_id     => undef
	$tiebreak_set_id => undef
	$label           => undef
	$start           => undef
	$end             => undef
	$type            => undef
	$breakout        => undef
</%args>
<%init>

	use List::Util 'shuffle';

	my $from = Tab::Round->retrieve($from_id) if $from_id;
	my $into = Tab::Round->retrieve($into_id) if $into_id;

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;
	my $now = DateTime->now(time_zone => $tz);

	unless ($from && $from > 0 && $into > 0 && $from->event) { 
		$m->print("<div class='main'><h4>No rounds set to break from or into</h4>");
		$m->print("<p>Hit Back and try again</p></h4></div>");
	}

	my $event = $from->event;
	my %event_settings = $event->all_settings;

	$m->comp(
		"/funclib/autopublish_round.mas", 
		event => $event
	);

	my $ignore_schools = $event_settings{"school_debates_self"} if $from && $event;

	my $err;

	if ($into) { 

		$err .= "You must specify the starting seed of whom to break  " unless $start;
		$err .= "You must specify the ending seed of whom to break  " unless $end;

		$m->redirect("index.mhtml?from_id=".$from->id."&preset_id=".$into->id."&err=".$err) if $err;

		$into->tiebreak_set($tiebreak_set_id) if $tiebreak_set_id;
		$into->site($site_id) if $site_id;
		$into->timeslot($timeslot_id) if $timeslot_id;
		$into->label($label) unless $label;
		$into->type($type) unless $type;
		$into->created($now);
		$into->update;

	} else { 

		my $err = " Missing timeslot " unless $timeslot_id;
		$err .= " Missing site " unless $site_id;
		$err .= " Missing starting entry " unless $start;
		$err .= " Missing ending entry " unless $end;
		$err .= " Missing tiebreaker set " unless $tiebreak_set_id;
		$err .= " Missing round type " unless $type;
		$err .= " Missing site " unless $site_id;

		$m->redirect("index.mhtml?from_id=".$from."&preset_id=".$into."&err=".$err) if $err;

		my $judges = 1;
		$judges    = 3 if $type eq "elim";
		$judges    = 3 if $type eq "final";

		$m->redirect("index.mhtml?from_id=".$from."&err=".$err) if $err;

		my $timeslot = Tab::Timeslot->retrieve($timeslot_id);

		$into = Tab::Round->create({
			event        => $event->id,
			timeslot     => $timeslot_id,
			start_time   => $timeslot->start,
			tiebreak_set => $tiebreak_set_id,
			label        => $label,
			type         => $type,
			created      => $now,
		});

		$into->setting('num_judges', $judges);
		$into->setting("use_for_breakout", $breakout); 

		$m->comp("/funclib/renumber_rounds.mas", event_id => $event->id);

	}

	if ($from->id == $into->id) { 

		my $err = "This would break ".$from->realname." into ".$into->realname;
		$err .= " You cannot advance a round into itself or the known universe will be sundered.";
		$err .= " Ask Mikaela Malsin how that goes. Try again.";
		$m->redirect("index.mhtml?from_id=".$from."&preset_id=".$into."&err=".$err) if $err;

	}

	my $bracket_label = "Bracket";

	if ($breakout > 0) { 
		$bracket_label = $into->event->setting("breakout_".$breakout."_label")." Bracket";
	}

	my $bracket = Tab::ResultSet->search( 
		event => $event->id,
		label => $bracket_label
	)->first;

	unless ($bracket) { 

		$bracket = Tab::ResultSet->create({
			tourn     => $tourn->id,
			event     => $event->id,
			label     => $bracket_label,
			generated => $now,
			bracket   => 1
		});

	}

    Tab::ResultValue->set_sql( rm_bracket => "
		delete result_value.* 
			from result, result_value 
			where result.id = result_value.result 
			and result.round = ? 
			and result.result_set = ? 
		");

	Tab::ResultValue->sql_rm_bracket->execute( $into->id, $bracket->id );

    Tab::Result->set_sql( 
		rm_bracket => "delete from result where round = ? and result_set = ? "
	);

	Tab::Result->sql_rm_bracket->execute( $into->id, $bracket->id );

	my ($entries_ref, $tbs_ref, $desc_ref, $forfeit_ref, $bah, $mah, $entry_letter_ref) 
		= $m->comp(
		"/tabbing/results/order_entries.mas", 
			round    => $from,
			breakout => $breakout
		);

	if ($from->type ne "elim") { 

		my @breaks;
		my $count;

		my %entry_tb = ();
		my %entry_seed = ();
		my %entry_school = ();

		my %id_entry = 
			map {$_->id => $_} 
			$event->entries;

		my @ineligibles = $m->comp(
			"/funclib/event_entry_settings.mas",
				event => $event,
				tag   => "no_elims"
			);

		my %ineligible = map {$_->entry->id => $_->value} @ineligibles;
		my $skip_count;

		foreach my $seed (sort {$a <=> $b} keys %{$entries_ref}) { 

			foreach my $entry_id (@{${$entries_ref}{$seed}}) { 

				if ($ineligible{$entry_id}) { 
					$skip_count++;
				 	next;
				}

				$count++;
				next if $count > $end;
				next if $count < $start;

				my $entry = $id_entry{$entry_id};

				push @breaks, $entry_id;
				$entry_seed{$entry_id} = $seed - $skip_count;
				$entry_school{$entry_id} = $entry->school->id;

				my $result = Tab::Result->create({
					result_set => $bracket->id,
					entry      => $entry_id,
					round      => $into->id
				});

				Tab::ResultValue->create({
					result    => $result->id,
					value     => $entry_seed{$entry_id},
					priority  => 1,
					sort_desc => 0,
					tag       => "Seed",
					no_sort   => 0
				});

			}
		}

		foreach my $seed (sort {$a <=> $b} keys %{$entries_ref}) { 

			foreach my $entry (@{${$entries_ref}{$seed}}) {

				my $one;	

				foreach my $key (sort {$a <=> $b} keys %{$desc_ref}) {
					next if $one;
					$entry_tb{$entry} = ${$tbs_ref}{$entry."-".$key};
					$one++;
				}
			}
		}

		my $step = 2;
		my $num_breaks = scalar @breaks;

		while ($step < $num_breaks) { 
			$step = $step * 2;
		}

		if ($step != $num_breaks) { 
			my $byes = $step - $num_breaks;
			foreach (1 .. $byes) { 
				push @breaks, "BYE";
			}
		}

		my @existing_panels = $into->panels;
		my @use_panels;	
		my $num_panels = $step / 2;

		my $letter = 1;
		$letter = "A" if $event_settings{"panel_labels"} eq "letters";

		foreach my $count (1 .. $num_panels) { 

			my $existing = shift @existing_panels if @existing_panels;

			if ($existing) {

				push @use_panels, $existing;

			} else { 

				my $new = Tab::Panel->create({
					round  => $into->id,
					letter => $letter,
					flight => 1
				});

				push @use_panels, $new;

			}
			$letter++;
		}

		foreach my $ep (@existing_panels) { 
			$ep->delete;   #KILL THE SPARES
		}

		@use_panels = shuffle(@use_panels);
		my @snake_panels = @use_panels;

		my %panel_entries = ();

		if (scalar @use_panels == 1) { 

			@{$panel_entries{$use_panels[0]->id}} = @breaks;

		} else { 

			foreach my $entry (@breaks) {

				unless (@snake_panels) { 
					@snake_panels = reverse (@use_panels);
				}

				my $panel = shift @snake_panels;
				push @{$panel_entries{$panel->id}}, $entry;
			}
		}	

		foreach my $panel (@use_panels) { 

			my @entries = @{$panel_entries{$panel->id}};

			my @judges = $m->comp(
				"/funclib/panel_judges.mas", 
				panel => $panel
			);

			my $school_id;
			my $closeout;

			unless ($ignore_schools) { 
				foreach my $entry (@entries) { 
					next unless $entry;
					$closeout++ if $entry_school{$entry} == $school_id;
					$school_id = $entry_school{$entry};
				}
			}

			foreach my $ballot ($panel->ballots) {
				$ballot->delete();
			}

			my $aff; 

			if (@judges) { 

				my $side;
				foreach my $entry (@entries) {

					$side++;
					foreach my $judge (@judges) {

						next unless $entry;

						if ($entry eq "BYE") { 

							$panel->bye(1);
							$panel->update();

							foreach my $ballot ($panel->ballots) { 
								$ballot->audit(1);
								$ballot->update;
							}

						} else { 

							my $ballot = Tab::Ballot->create({
								panel        => $panel->id,
								judge        => $judge->id,
								entry        => $entry,
								seed         => $entry_seed{$entry},
								side         => $side
							});

							$panel->bracket($entry_seed{$entry}) if $panel->bracket > $entry_seed{$entry};
							$panel->bracket($entry_seed{$entry}) unless $panel->bracket;

						}
					}
				}

			} else { 

				my $side = 1;

				foreach my $entry (@entries) {

					next unless $entry;
				
					if ($entry eq "BYE") { 

						$panel->bye(1);
						$panel->update();

						foreach my $ballot ($panel->ballots) { 
							$ballot->audit(1);
							$ballot->update;
						}

					} else { 

						my $ballot = Tab::Ballot->create({
							panel => $panel->id,
							judge => 0,
							entry => $entry,
							seed  => $entry_seed{$entry},
							side  => $side
						});

						$panel->bracket($entry_seed{$entry}) if $panel->bracket > $entry_seed{$entry};
						$panel->bracket($entry_seed{$entry}) unless $panel->bracket;
						$aff = $entry if $side == 1; 
					}

					$side++;
				}
			}

			my $due_aff = $m->comp("/funclib/round_elim_dueaff.mas", panel => $panel);

			if ($due_aff != $aff) { 
				$m->comp("/funclib/swap_sides.mas", panel => $panel);
			}

			$panel->bye(1) if $closeout;
			$panel->update;
		}

		$into->created($now);
		$into->post_results(0);  # People always do this
		$into->update();

		my $msg = ucfirst($type)." round paneled";
		$m->redirect("/panel/schemat/show.mhtml?round_id=".$into->id."&msg=$msg");

	} else { 

		my %panel_entries;
		my %entry_seed;
		my %entry_school;

		Tab::Panel->set_sql( unscored_byes =>  "
			select distinct panel.* 
			from panel,ballot b1, ballot b2
			where panel.bye = 1 
			and panel.round = ? 
			and panel.id = b1.panel
			and panel.id = b2.panel
			and b2.entry != b1.entry
			and b1.bye = 0
			and b1.forfeit = 0
			and b2.bye = 0
			and b2.forfeit = 0
			and not exists 
			(select score.* from score, ballot 
				where score.ballot = ballot.id 
				and ballot.panel = panel.id 
				and score.tag=\"ballot\") ");

		my @undone_byes = Tab::Panel->search_unscored_byes($from->id);

		if (@undone_byes) { 

			$err = " You have coachovers or byes without a winner marked.";
			$err .= " Enter them on the Tabbing Enter Ballots screen and try again.";

			$m->redirect("index.mhtml?from_id=".$from."&preset_id=".$into."&err=".$err);
		}

		my %id_entry = map {$_->id => $_} $m->comp("/funclib/round_entries.mas", round => $from);

		foreach my $seed (sort {$a <=> $b} keys %{$entries_ref}) { 

			foreach my $entry_id (@{${$entries_ref}{$seed}}) { 

				
				$entry_seed{$entry_id} = $seed;
				$entry_school{$entry_id} = $id_entry{$entry_id}->school->id
					if $id_entry{$entry_id}->school;
			}
		}

		my @panels = $from->panels;

		my $num_panels;
		my $horked_bracket;
		my %already;

		foreach my $panel (@panels) { 
			$num_panels = $panel->bracket if $panel->bracket > $num_panels;
			$horked_bracket++ if $panel->bracket < 1;
			$horked_bracket++ if $already{$panel->bracket}++;

			@{$panel_entries{$panel->id}} = $m->comp("/funclib/panel_entries.mas", panel => $panel);

		}

		if ($horked_bracket) { 

			$err = " You have Issues with your brackets. <br /> The bracket of each debate must be set in seeding order so the next round can pair opponents correctly.  The winner of the top seed debate will hit the winner of the worst seed, etc.  Each seed must only appear once.";

			$m->redirect("/panel/manipulate/bracket_edit.mhtml?round_id=".$from."&err=".$err);
		}

		my $letter = 1;
		$letter = "A" if $event_settings{"panel_labels"} eq "letters";

		my @done_panels;
		my %destiny_count;

		my %sides; 

		foreach my $panel (@panels) { 

			my $destination_bracket;

			if ($panel->bracket <= ( $num_panels / 2 ) ) { 
				$destination_bracket = $panel->bracket;
			} else { 
				$destination_bracket = ($num_panels + 1 - $panel->bracket);
			}
		
			my $destination = Tab::Panel->search( 
				round   => $into->id,
				bracket => $destination_bracket
			)->first;

			my $opponent;

			if ($destination) { 

				$opponent = @{$panel_entries{$destination->id}}[0];

			} else { 

				$destination = Tab::Panel->create({
					round   => $into->id,
					bracket => $destination_bracket,
					letter  => $letter,
					flight  => 1
				});
			
				if ($letter eq "Z") { 
					$letter = "AA";
				} elsif ($letter eq "AZ") { 
					$letter = "BA";
				} elsif ($letter eq "BZ") { 
					$letter = "CA";
				} else { 
					$letter++;
				}

				push @done_panels, $destination;
			} 

			my @entries = 
				sort {$entry_seed{$a} <=> $entry_seed{$b}} @{$panel_entries{$panel->id}} 
				if $panel_entries{$panel->id};

			my $winner = shift @entries if @entries;
			push @{$panel_entries{$destination->id}}, $winner;

			my $closeout++ 
				if $opponent && $entry_school{$opponent} == $entry_school{$winner} 
				&& not defined $ignore_schools;

			$destination->bye(1) if $closeout;
			$destination->update();

			my $result = Tab::Result->create({
				result_set => $bracket->id,
				entry      => $winner,
				round      => $into->id
			});

			Tab::ResultValue->create({
				result    => $result->id,
				value     => $panel->bracket,
				priority  => 1,
				sort_desc => 0,
				tag       => "Seed",
				no_sort   => 0
			});

			my @judges = $m->comp(
				"/funclib/panel_judges.mas", 
				panel => $destination
			);

			my $side = 1 unless $sides{$destination->id};
			$side = 2 unless $side; 
			$sides{$destination->id}++;

			if (@judges &! $closeout) { 

				foreach my $judge (@judges) { 

					my @dummies = Tab::Ballot->search( 
						judge => $judge->id,
						panel => $destination->id,
						entry => 0
					);

					foreach my $dummy (@dummies) { 
						$dummy->delete;
					}

					Tab::Ballot->create({
						panel => $destination->id,
						judge => $judge->id,
						entry => $winner,
						chair => $judge->chair,
						audit => 0,
						side  => $side
					});
				}

			} else { 

				Tab::Ballot->create({
					panel => $destination->id,
					judge => 0,
					entry => $winner,
					chair => 0,
					audit => 0,
					side  => $side
				});
			}
		}

		foreach my $panel (@done_panels) { 

			my $due_aff = $m->comp("/funclib/round_elim_dueaff.mas", panel => $panel);
			my $aff_ballot = $panel->ballots( side => 1)->first; 

			if ($due_aff != $aff_ballot->entry) { 
				$m->comp("/funclib/swap_sides.mas", panel => $panel);
			}
		}

		$into->created($now);
		$into->post_results(0);  # People always do this
		$into->update;

		my $msg = ucfirst($type)." round paneled";
		$m->redirect("/panel/schemat/show.mhtml?round_id=".$into->id."&msg=$msg");
	} 

</%init>
