<%args>
	$tourn
	$tourn_settings
	$end             => undef
	$type            => undef
	$label           => undef
	$panels          => undef
	$from_id         => undef
	$into_id         => undef
	$site_id         => undef
	$tiebreak_set_id => undef
	$timeslot_id     => undef
</%args>
<%init>

	use List::Util 'shuffle';

	my $from = Tab::Round->retrieve($from_id) if $from_id;
	my $into = Tab::Round->retrieve($into_id) if $into_id;

	my $dbh = Tab::DBI->db_Main();

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;
	my $now = DateTime->now(time_zone => $tz);

	our %penalties = (
		school => "100000",
		prelim => "10"
	);

	if ($tourn_settings->{"nsda_nats"}) {
		$penalties{"district"} = "10000";
		$penalties{"state"} = "100";
	}

	my $event = $from->event;

	if ($into) {

		my $err = "You must specify the number of sections to be used  " unless $panels;
		$err .= "You must specify the ending position of whom to break  " unless $end;

		return $err if $ARGS{'return'} && $err;
		$m->redirect("index.mhtml?from_id=".$from->id."&preset_id=".$into->id."&err=".$err) if $err;

		$into->tiebreak_set($tiebreak_set_id) if $tiebreak_set_id;
		$into->site($site_id) if $site_id;
		$into->timeslot($timeslot_id) if $timeslot_id;
		$into->label($label) unless $label;
		$into->type($type) unless $type;
		$into->update;

	} else {

		my $err = " Missing timeslot " unless $timeslot_id;
		$err .= " Missing site " unless $site_id;
		$err .= " Missing number of breaks " unless $end;
		$err .= " Missing tiebreaker set " unless $tiebreak_set_id;
		$err .= " Missing round type " unless $type;
		$err .= " Missing site " unless $site_id;
		$err .= " Missing number of sections " unless $panels;

		return $err if $ARGS{'return'} && $err;
		$m->redirect("index.mhtml?from_id=".$from->id."&preset_id=".$into->id."&err=".$err) if $err;

		my $judges = 1;
		$judges = 3 if $type eq "elim";
		$judges = 3 if $type eq "final";

		return $err if $ARGS{'return'} && $err;
		$m->redirect("index.mhtml?from_id=".$from->id."&err=".$err) if $err;

		my $timeslot = Tab::Timeslot->retrieve($timeslot_id);

		$into = Tab::Round->create({
			event        => $event->id,
			timeslot     => $timeslot_id,
			start_time   => $timeslot->start,
			tiebreak_set => $tiebreak_set_id,
			label        => $label,
			type         => $type,
			site         => $site_id,
			created      => $now,
		});

		$into->setting("num_judges", $judges);
		$m->comp("/funclib/renumber_rounds.mas", event_id => $event->id);
	}

	$m->comp("/funclib/autopublish_round.mas", event => $event);

	my ($entries_ref, $tbs_ref, $desc_ref, $forfeit_ref) =
		$m->comp(
			"/tabbing/results/order_entries.mas",
			round => $from
		);

	my $ineligible = $m->comp(
		"/funclib/event_entry_settings.mas",
			event => $event,
			hash  => 1,
			tag   => "no_elims"
		);

	my @breaks;
	my $count;

	my %entry_data = ();

	my $entry_sth = $dbh->prepare("
		select entry.id, panel.id, panel.letter, school.id, region.id, district.id
		from (panel, ballot, entry)
			left join school on entry.school = school.id
			left join region on school.region = region.id
			left join district on school.district = district.id
		where panel.round = ?
			and panel.id = ballot.panel
			and ballot.entry = entry.id
			and entry.active = 1
	");

	$entry_sth->execute($from->id);

	while (
		my (
			$entry_id, $panel_id, $panel_letter, $school_id, $region_id, $district_id
		) = $entry_sth->fetchrow_array()
	) {

		$entry_data{$entry_id}{"panel"}    = $panel_id;
		$entry_data{$entry_id}{"prelim"}   = $panel_letter;
		$entry_data{$entry_id}{"school"}   = $school_id;
		$entry_data{$entry_id}{"region"}   = $region_id;
		$entry_data{$entry_id}{"district"} = $district_id;
	}

	$entry_sth->finish();
	$entry_sth->execute($into->id);

	my %already_broke = ();

	while (
		my (
			$entry_id, $panel_id, $panel_letter, $school_id, $region_id, $district_id
		) = $entry_sth->fetchrow_array()
	) {
			$entry_data{$entry_id}{"broke"}   = $panel_id;
			$entry_data{$entry_id}{"school"}   = $school_id;
			$entry_data{$entry_id}{"region"}   = $region_id;
			$entry_data{$entry_id}{"district"} = $district_id;
	}

	my %panel_count = ();

	# Advance the top X number of entries into the round, skipping anyone
	# already in

	foreach my $rank (sort {$a <=> $b} keys %{$entries_ref}) {

		foreach my $entry (@{${$entries_ref}{$rank}}) {

			next unless $entry;
			next if $ineligible->{$entry};
			next if $entry_data{$entry}{"broke"};

			my $panel = $entry_data{$entry}{"panel"};
			next if $panel_count{$panel} >= $end;

			$panel_count{$panel}++;
			my $seed = $panel_count{$panel};

			push @breaks, $entry;
			$entry_data{$entry}{"seed"} = $seed;
		}
	}

	#Sort them in seed order by the panel so the snaker is fine.
	@breaks = sort {$entry_data{$a}{"panel"} <=> $entry_data{$b}{"panel"}} @breaks;
	@breaks = sort {$entry_data{$a}{"seed"} <=> $entry_data{$b}{"seed"}} @breaks;

	foreach my $seed (sort {$a <=> $b} keys %{$entries_ref}) {
		foreach my $entry (@{${$entries_ref}{$seed}}) {
			my $one;
			foreach my $key (sort {$a <=> $b} keys %{$desc_ref}) {
				next if $one;
				$entry_data{$entry}{"tb"} = ${$tbs_ref}{$entry."-".$key};
				$one++;
			}
		}
	}

	my @existing_panels = $into->panels;
	my @use_panels;

	foreach my $count (1 .. $panels) {
		my $existing = shift @existing_panels if @existing_panels;

		if ($existing) {
			push @use_panels, $existing;

		} else {

			my $new = Tab::Panel->create({
				flight => 1,
				round  => $into->id,
				letter => $count
			});

			push @use_panels, $new;
		}
	}

	foreach my $ep (@existing_panels) {
		$ep->delete();   #KILL THE SPARES
	}

	my $method = $event->setting("elim_method");
	my @snake_panels = @use_panels;
	my %panel_entries = ();

	$count = 1;

	Tab::debuglog("Here I am!");

	if (scalar @use_panels == 1) {

		@{$panel_entries{$use_panels[0]->id}} = @breaks;

	} else {

		my $current_seed = 1;

		foreach my $entry (@breaks) {
			$count++;

			unless (@snake_panels) {

				unless ($current_seed == $entry_data{$entry}{"seed"}) {

					# this operation keeps competitors from the same chamber
					# from hitting each other as much as can be done.

					foreach (1 .. $current_seed) {
						my $shift = shift @use_panels;
						push @use_panels, $shift;
					}

					@snake_panels = @use_panels;
					$current_seed = $entry_data{$entry}{"seed"};

				} else {

					@snake_panels = reverse (@use_panels) if $count % 2;
					@snake_panels = @use_panels unless @snake_panels;
				}
			}

			my $panel = shift @snake_panels;
			push @{$panel_entries{$panel->id}}, $entry;

		}

		foreach my $entry_id (keys %entry_data) {
			my $panel_id = $entry_data{$entry_id}{"broke"};
			next unless $panel_id;
			push @{$panel_entries{$panel_id}}, $entry_data{$entry_id}{"entry"};
		}

		if ($method eq "snake_school"
			|| $method eq "snake_school_tight"
			|| $method eq "snake_school_rank"
			|| $method eq "snake_school_force"
		) {

			foreach (1 .. 7) {

				Tab::debuglog("Pass $_");

				foreach my $panel (@use_panels) {

					my $initial_score = score_elim_chamber(\@{$panel_entries{$panel->id}}, \%entry_data);
					next unless $initial_score > 0;

					my $panel_id = $panel->id;

					foreach my $entry (@{$panel_entries{$panel_id}}) {

						next if $entry_data{$entry}{"broke"};
						my @test = @{$panel_entries{$panel_id}};

						my $index = 0;
						$index++ until $test[$index] == $entry;
						splice(@test, $index, 1);

						my $test_score = score_elim_chamber(\@test, \%entry_data);

						if ($test_score < $initial_score) {

							my $swap_seed_dist = 99;
							my $swap_tb_dist   = 99;
							my $swap_score     = -99;
							my $swap_entry;
							my $swap_panel;

							foreach my $other (@use_panels) {

								my $other_id = $other->id;

								# Can't switch to the same panel
								next if $other_id == $panel_id;
								next if $entry_data{$other_id}{"broke"};

								# Find the other panel for scoring
								my @other_panel = @{$panel_entries{$other_id}};

								# Put me into this panel for testing
								my $other_score = score_elim_chamber(\@other_panel, \%entry_data);

								foreach my $other_entry (@{$panel_entries{$other_id}}) {

									my $seed_dist = abs(
										$entry_data{$other_entry}{"seed"}
										- $entry_data{$entry}{"seed"}
									);

									my $tb_dist = abs(
										$entry_data{$other_entry}{"tb"}
										- $entry_data{$entry}{"tb"}
									);

									next if ($seed_dist > 2 && $method eq "snake_school");
									next if ($seed_dist > 0 && $method eq "snake_school_tight");
									next if ($tb_dist > 0 && $method eq "snake_school_rank");

									# Remove swap candidate from the panel
									$index = 0;
									$index++ until $other_panel[$index] == $other_entry;
									splice(@other_panel, $index, 1);

									push (@test, $other_entry);

									my $new_initial_score = score_elim_chamber(\@test, \%entry_data);
									my $new_other_score = score_elim_chamber(\@other_panel, \%entry_data);

									my $diff =
										$other_score
										+ $initial_score
										- $new_other_score
										- $new_initial_score;

									if ( $diff > 0 && $diff > $swap_score) {
										$swap_entry = $other_entry;
										$swap_score = $diff;
										$swap_seed_dist = $seed_dist;
										$swap_tb_dist = $tb_dist;
										$swap_panel = $other_id;
									}

									if (
										($diff > 0
											&& $diff == $swap_score
											&& $seed_dist < $swap_seed_dist
											&& ($method eq "snake_school"
											   ||$method eq "snake_school_tight")
										)

									||
										($diff > 0
											&& $diff == $swap_score
											&& $tb_dist < $swap_tb_dist
											&& $method eq "snake_school_rank"
										)
									) {

										$swap_entry = $other_entry;
										$swap_score = $new_other_score;
										$swap_seed_dist = $seed_dist;
										$swap_tb_dist = $tb_dist;
										$swap_panel = $other_id;
									}

									# Reset the table

									if ( grep( /^$other_entry/, @test ) ) {
										$index = 0;
										$index++ until $test[$index] == $other_entry;
										splice(@test, $index, 1);
									}

									push (@other_panel, $other_entry);

								}

								if ( grep( /^$entry/, @other_panel ) ) {
									$index = 0;
									$index++ until $other_panel[$index] == $entry;
									splice(@other_panel, $index, 1);
								}
							}

							if ($swap_entry) {

								my @panel2 = @{$panel_entries{$swap_panel}};
								my @panel1 = @{$panel_entries{$panel_id}};

								push (@panel1, $swap_entry);

								my $swapdex = 0;
								$swapdex++ until $panel1[$swapdex] == $entry;
								splice(@panel1, $swapdex, 1);

								$swapdex = 0;
								$swapdex++ until $panel2[$swapdex] == $swap_entry;
								splice(@panel2, $swapdex, 1);

								push (@panel2, $entry);

								@{$panel_entries{$panel_id}} = @panel1;
								@{$panel_entries{$swap_panel}} = @panel2;

								$initial_score = score_elim_chamber(\@panel1, \%entry_data);

							}
						}
					}
				}
			}
		}
	}

	my @other_ballots = $m->comp("/funclib/other_ballots.mas", round => $into);
	my %total_positions_by_entry = ();
	my %positions_by_entry = ();

	foreach my $ob (@other_ballots) {
		next unless $ob->entry;
		my $entry = $ob->entry->id;
		$total_positions_by_entry{$entry} += $ob->speakerorder;
		$positions_by_entry{$entry."-".$ob->speakerorder}++;
	}

	#Set speaker order
	foreach my $key (keys %panel_entries) {

		my @entries = @{$panel_entries{$key}};
		@entries = shuffle(@entries);
		@entries = sort {
			$total_positions_by_entry{$b} <=> $total_positions_by_entry{$a}
		} @entries;

		my $size_of_panel = scalar @entries;

		my $moved = 1;

		foreach (1 .. 10) {

			next unless $moved;
			undef $moved;
			my $position;

			foreach my $entry (@entries) {

				$position++;

				if ($positions_by_entry{$entry."-".$position}) {

					#Remove from place in line
					my $speakdex = 0;
					$speakdex++ until $entries[$speakdex] == $entry;
					splice(@entries, $speakdex, 1);

					#Find a new home
					my $place = $position;
					while ($place == $position) {
						$place = int(rand($size_of_panel));
					}

					$place--;
					$place = 1 if $place < 0;
					splice(@entries,($place - 1),0,$entry);
					$moved++;
				}
			}
		}
		@{$panel_entries{$key}} = @entries;
	}

	foreach my $panel (@use_panels) {

		my @entries = @{$panel_entries{$panel->id}} if $panel_entries{$panel->id};
		my @judges = $m->comp("/funclib/panel_judges.mas", panel => $panel);

		my $sth = $dbh->prepare("
			delete score.*, ballot.*
			from ballot, score
			where ballot.panel = ?
			and ballot.id = score.ballot
		");

		$sth->execute($panel->id);

		if (@judges) {

			foreach my $judge (@judges) {
				my $position;

				foreach my $entry (@entries) {

					$position++;
					next unless $entry;
					my $ballot = Tab::Ballot->create({
						panel        => $panel->id,
						judge        => $judge->id,
						entry        => $entry,
						speakerorder => $position
					})
				}
			}

		} else {

			my $position;
			foreach my $entry (@entries) {

				$position++;
				next unless $entry;

				my $ballot = Tab::Ballot->create({
					panel        => $panel->id,
					judge        => 0,
					entry        => $entry,
					speakerorder => $position
				});
			}
		}
	}

	$into->created($now);
	$into->post_results(0);  # People always do this
	$into->update();

	my @ties = $m->comp("/funclib/congress_ties.mas", round => $into);

	if (@ties && $ARGS{"realign"}) {

		foreach my $tie (@ties) {
			next if $tie->id == $into->id;

			foreach my $panel (@use_panels) {
				my $new_panel = $panel->copy( round => $tie->id );

				foreach my $ballot ($panel->ballots) {
					my $new_ballot = $ballot->copy(
						panel => $new_panel
					);
				}
			}
		}
	}

	my $msg = "Elim round paneled";
	undef %penalties;

	return $msg if $ARGS{'return'};

	if ($into->type eq "final") {
		$m->redirect("/panel/schemat/show.mhtml?round_id=".$into->id."&msg=$msg");
	} else {
		$m->redirect("/panel/schemat/show_snake.mhtml?round_id=".$into->id."&msg=$msg");
	}

	sub score_elim_chamber {

		my ($panref, $entref, $loud) = @_;
		my $score = 0;

		foreach my $entry (@$panref) {
			foreach my $other (@$panref) {

				next unless $other > $entry;

				if ($entref->{$entry}{"school"} == $entref->{$other}{"school"}) {
					$score += $penalties{"school"};
				}

				if ($entref->{$entry}{"district"} == $entref->{$other}{"district"}) {
					$score += $penalties{"district"};
				}

				if ($entref->{$entry}{"state"} eq $entref->{$other}{"state"}) {
					$score += $penalties{"state"};
				}

				if ($entref->{$entry}{"prelim"} eq $entref->{$other}{"prelim"}) {
					$score += $penalties{"prelim"};
				}
			}
		}
		return $score;
	}

</%init>
