<%args>
	$school_id
	$person
	$person_settings
	$perms
</%args>
<%init>

	my $school = Tab::School->retrieve($school_id);
	my $chapter = $school->chapter;
	my $tourn  = $school->tourn;

	my %event_by_id = map {$_->id => $_} ($tourn->events);

	my %district_entry = $m->comp(
		"/funclib/district_entry.mas", 
		chapter => $chapter 
	);

</%init>

	<& 
		"nsda_menu.mas", 
		school => $school,
		whoami => "doubleentry"
	&>

	<div class="main">

        <& tabbar.mas, 
			school => $school,
			whoami => "nsda" 
		&>

        <h4 class="martopmore padmuchmore">
			Single Entry Preferences
        </h4>

		<p class="explain">
			These settings are for informational purposes only, and (for now)
			only cover entries for Districts events run on Tabroom.  Work in
			progress.
		<p>
			Schools are therefore still required to bring a signed Single Entry
			Letter of Intent for each double entered individual to their
			District Tournament.
		</p>

		<form 
			action="nsda_single_entry_save.mhtml" 
			method="post"
		>

		<input 
			type  = "hidden"
			name  = "school_id"
			value = "<% $school->id %>"
		>

<%perl>

		my %already_entries = ();
		my %already_students = ();

		my %student_entries = ();
		my %student_partners = ();

		my @student_ids = sort keys %{$district_entry{"entries"}};

		@student_ids = 
			sort { $district_entry{'entries'}{$b} 
					<=> $district_entry{'entries'}{$a} 
				} @student_ids;

		foreach my $student_id (@student_ids) { 

			my $student;

			$student = $already_students{$student_id};

			unless ($student) { 
				$student = Tab::Student->retrieve($student_id);
				$already_students{$student_id} = $student;
			}

			foreach my $entry_id ( @{$district_entry{"entries"}{$student_id}} ) { 

				my $entry;

				$entry = $already_entries{$entry_id};

				unless ($entry) { 
					$entry = Tab::Entry->retrieve($entry_id);
					$already_entries{$entry_id} = $entry;
				}

				push @{$student_entries{$student_id}}, $entry;
				my $partner_string;

				foreach my $partner_id (@{$district_entry{"entry_students"}{$entry_id}} ) { 

					next if $partner_id == $student_id;

					my $partner;

					$partner = $already_students{$partner_id};

					unless ($partner) {
						$partner = Tab::Student->retrieve($partner_id);
						$already_students{$partner_id} = $partner;
					}

					push @{$student_partners{$student_id}}, $partner;
					$student_partners{"entry"}{$student_id}{$partner_id} = $entry;

					unless ($partner_string) { 
						$partner_string = "Partner w/";
					} else { 
						$partner_string .= " &amp; "
					}

					$partner_string .= $partner->first." ".$partner->last;

				}

				$district_entry{"partner_string"}{$entry_id}{$student_id} = $partner_string;

			}

		}

		my %event_mix = ();

		foreach my $student_id (@student_ids) { 

			foreach my $entry (@{$student_entries{$student_id}}) { 

				if (scalar (@{$district_entry{"entry_students"}{$entry->id}}) == 2) {

					$event_mix{$student_id}{"partnerships"}++;

				} else { 

					$event_mix{$student_id}{"individuals"}++;

				}

			}

		}

		my %forced_choices = ();

		foreach my $student_id (@student_ids) { 

			# Do I have any team events?  That's the only way I would face a
			# forced choice.

			if ($event_mix{$student_id}{"partnerships"} > 0)  { 

				# Do I also have individual event entries?

				if ($event_mix{$student_id}{"individuals"} > 0)  { 

					# Does my partner also have an individual event?  
					# If yes, you can choose either way. 
					# If no, then you must choose the partnership event.

					my $live_free;

					foreach my $partner_id (@{$student_partners{$student_id}}) { 

						if ($event_mix{$partner_id}{"individuals"} > 0)  { 
							$live_free++;
						} 
					
						# However, both must choose the same way

						if ($live_free && ($student_id < $partner_id)) { 

							my $partner_picked;
						
							foreach my $entry (@{$student_entries{$student_id}}) { 
							
								if (scalar (@{$district_entry{"entry_students"}{$entry->id}}) == 2) { 
									$partner_picked = $entry->setting("nsda_priority");
								}
							}

							if ($partner_picked) { 

								foreach my $entry (@{$student_entries{$partner_id}}) { 
								
									if (scalar (@{$district_entry{"entry_students"}{$entry->id}}) == 2) { 

										$entry->setting("nsda_priority", $partner_picked);

									} else { 

										my $picked = $partner_picked - 1;
										$picked = 2 if $picked < 1;
										$entry->setting("nsda_priority", $picked);

									}

									$forced_choices{$partner_id}++;
								}

							}
						}

					}

					unless ($live_free) {

						$forced_choices{$student_id}++;

						foreach my $entry (@{$student_entries{$student_id}}) { 

							if (scalar (@{$district_entry{"entry_students"}{$entry->id}}) == 1) { 
								$entry->setting("nsda_priority", 2) 
							} else { 
								$entry->setting("nsda_priority", 1) 
							}
						}
					}

				} else { 

					# I have no individual entries.  So I get linked choices
					# with my partner

					my %seen;

					@{$student_partners{$student_id}} = 
						grep { ! $seen{$_} ++ } 
						@{$student_partners{$student_id}};
					
					if (scalar @{$student_partners{$student_id}} == 1) { 

						# I only have one partner which means I just lock the 2nd set of
						# preferences

						my $partner_id = ${$student_partners{$student_id}}[0];

						if ($student_id > $partner_id) { 
							$forced_choices{$student_id}++;
						}

					} else { 

						# If I have two different partners, then the later
						# weekend takes precedence always. 

						my $later_entry;
						my $former_entry;

						foreach my $partner_id (@{$student_partners{$student_id}}) { 

							my $this_entry = $student_partners{"entry"}{$student_id}{$partner_id};

							if ($later_entry) { 

								my $this_date = $district_entry{"entry_time"}{$this_entry};
								my $later_date = $district_entry{"entry_time"}{$later_entry};

								if ($this_date > $later_date) { 
									$former_entry = $later_entry;
									$later_entry = $this_entry;
								}
								
							} else { 
								
								$later_entry = $this_entry;

							}

						}

						$later_entry->setting("nsda_priority", 1);

						$former_entry->setting("nsda_priority", 2);

						$forced_choices{$student_id}++;

					}

				}

			}

		}


		@student_ids = 
			sort { $district_entry{'student_total'}{$b} 
					<=> $district_entry{'student_total'}{$a} 
				} @student_ids;

		foreach my $student_id (@student_ids) { 

			my $student = $already_students{$student_id};

</%perl>

			<div class="lightrow">

				<span class="fifth">
					<% $student->first." ".$student->last %>
				</span>

				<span class="eighth">
					<% $district_entry{'student_total'}{$student_id} %> entries
				</span>

				<span class="sixth nospace">


%					foreach my $entry (@{$student_entries{$student_id}}) { 

						<span 
							class="third hover padmore"
							title="<% $district_entry{"partner_string"}{$entry->id}{$student_id} %>"
						>
							<% $entry->event->abbr %>
						</span>
%					}
				</span>

				<span class="half nospace">

%					foreach my $slot (1 .. scalar @{$student_entries{$student_id}}) { 

						<span class="quarter marno">

							<% $slot %>.
							<select 
								class='fixedtiny plain'
								name="<% $student->id %>-<% $slot %>"
								<% $forced_choices{$student->id} ? 'disabled="true"' : "" %>
							>

								<option value=""></option>

%							foreach my $entry (@{$student_entries{$student_id}}) { 
								<option 
									value="<% $entry->id %>"
									<% $entry->setting("nsda_priority") == $slot ? 'selected="selected"' :  "" %>
								><% $entry->event->abbr %></option>
%							}

							</select>
				
						</span>
%					}

%					if ($forced_choices{$student_id}) { 

						<span class="quarter redtext"
							title="Choices are locked because of partnership rules"
						>
							<span class="fa fa-lock fa-lg redtext"></span>
							Locked
						</span>
%					}

				</span>

			</div>


%		}

		<div class="liblrow rightalign">

			<input 
				type="submit" 
				value="Save Preferences"
			>

			</form>

		</div>

	</div>
