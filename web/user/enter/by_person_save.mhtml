<%args> 
	$school
	$student_id => undef
</%args>
<%init>

	my $tourn = $school->tourn;
	my $student = Tab::Student->retrieve($student_id);

	$m->abort unless $student;

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;
	my $now = DateTime->now;

	my @entries = $m->comp("/funclib/student_entries.mas", 
		student => $student,
		tourn   => $tourn );

	my %ok_events = $m->comp("/funclib/student_clear_events.mas", 
		student => $student,
		school  => $school );

	my $hide_codes = $tourn->setting("hide_codes");

	my $deleted_students; 
	my $err;
	my $msg;

	foreach my $entry (@entries) { 

		my $event = $entry->event;

		# Code style
		my $code_style = $event->setting("code_style");

		# Titles and authors
		my $ask_for_titles = $event->setting("ask_for_titles");

		# Hybrid

		# APDA seeds
		my $apda = $event->setting("apda");

		my $max = $event->setting("max_entry");
		my $min = $event->setting("min_entry");

		#quals
		my $ask_quals = $event->setting("ask_quals");
		my $more_quals = $event->setting("more_quals");
		my $at_larges = $event->setting("at_larges");

		$entry->name($ARGS{$entry->id."_name"});

		if ($code_style eq "register" || $code_style eq "initials") { 

			my $new_code = $ARGS{$entry->id."_code"};

			if (Tab::Entry->search(code => $new_code)) { 

				$err .= "Code $new_code is already taken in the tournament.  Please select another <br />";

			} else { 
			
				$entry->code($ARGS{$entry->id."_code"});

			}
		}

		$entry->ada($ARGS{$entry->id."_ada"});

		$entry->update;

		$entry->setting("title", $ARGS{$entry->id."_title"});
		$entry->setting("author", $ARGS{$entry->id."_author"});

		if ($ask_for_titles &! $ARGS{$entry->id."_title"}) { 
			$err .= "Please provide a piece title and author <br />";
		}

		my $seed = $ARGS{$entry->id."_registered_seed"};

		$entry->setting("registered_seed", $ARGS{$entry->id."_registered_seed"});

		if ($seed eq "full") { 
			$entry->setting("pairing_seed", 1);
		} elsif ($seed eq "half") { 
			$entry->setting("pairing_seed", 2);
		} elsif ($seed eq "free") { 
			$entry->setting("pairing_seed", 3);
		} elsif ($event->setting("apda")) { 
			$entry->setting("pairing_seed", 4);
		}

		my @clear_students = $m->comp("/funclib/students_evententer.mas",
			event  => $event,
			school => $school
		);

		my %clear_by_id = map {$_->id => $_} @clear_students;

		my %already_students = map {$_->id => $_} $entry->students; 

		my %used_students;

		my $students_changed;

		my $minimum_counter; 
		
		foreach my $tick (1 .. $max) { 

			next unless $ARGS{$entry->id."_student_".$tick};
			next unless $clear_by_id{$ARGS{$entry->id."_student_".$tick}};

			$minimum_counter++;

			unless ($already_students{$ARGS{$entry->id."_student_".$tick}}) { 

				$students_changed++;

				unless (Tab::EntryStudent->search(
					entry   => $entry->id,
					student => $ARGS{$entry->id."_student_".$tick} )) { 

					eval {
						Tab::EntryStudent->create({
							entry   => $entry->id,
							student => $ARGS{$entry->id."_student_".$tick}
						});
					};
				}

			}

			$used_students{$ARGS{$entry->id."_student_".$tick}}++;

		}

		foreach my $student_id (keys %already_students) { 

			next if $used_students{$student_id};

			my $es = Tab::EntryStudent->search(
				entry => $entry->id,
				student => $student_id
			)->first;

			$deleted_students .= "," if $deleted_students;
			$deleted_students .= $student_id;

			$es->delete;
			$students_changed++;
		}

		if ($students_changed 
			&& ($code_style eq "initials" 
			|| $code_style eq "code_name" 
			|| $code_style eq "full_initials" 
			|| $code_style eq "school_names" 
			|| $code_style eq "school_name_only" 
			|| $code_style eq "names" 
			|| $code_style eq "names_lastfirst" 
			|| $code_style eq "last_names") 
		) { 

			$entry->code($m->comp("/funclib/entry_code.mas", entry => $entry));
		}

		if ($students_changed) { 
			$entry->name($m->comp("/funclib/entry_name.mas", entry => $entry));
			$entry->update;
		}

  		my $quals = $event->setting('ask_quals');
   		my $required = $quals;

        if ($event->setting("more_quals")) { 
            my @existing_quals = $entry->qualifiers;
            $quals = scalar @existing_quals if (scalar @existing_quals) > $quals;
            $quals += 5;
        }   

		if ($at_larges) { 

			if ($ARGS{$entry->id."_atlarge"}) { 
				$entry->setting("atlarge", $ARGS{$entry->id."_atlarge"});
			} else {
				$entry->setting("atlarge", 0);
			}
		}

		if ($quals) {

			my @qualifiers = $entry->qualifiers;

			my $counter;

			foreach my $tick (1 .. $quals) { 

				my $qual = shift @qualifiers if @qualifiers;

				if ($ARGS{$entry->id."_qual_name_".$tick}) { 

					if ($qual) { 

						$qual->name($ARGS{$entry->id."_qual_name_".$tick});
						$qual->result($ARGS{$entry->id."_qual_result_".$tick});
						$qual->update;

					} else { 

						Tab::Qualifier->create({
							entry  => $entry->id,
							tourn  => $tourn->id,
							name   => $ARGS{$entry->id."_qual_name_".$tick},
							result => $ARGS{$entry->id."_qual_result_".$tick}
						});

					}

					$counter++;

				} elsif ($qual) {

					eval{ $qual->delete };
				}

			}

			if ($counter < $required && (not defined $ARGS{$entry->id."_atlarge"}) ) { 
				$err .= "You have not entered enough qualifiers.  $required required; you entered only $counter";
			}

		}

	}

	if ($deleted_students) { 

		# Check housing status for any students who ended up voted off the
		# island. 

	}

	$msg = "Details saved for ".$student->first." ".$student->last." entries";

	$m->redirect("by_person_edit.mhtml?student_id=$student_id&school_id=".$school->id."&err=$err&msg=$msg");


</%init>
