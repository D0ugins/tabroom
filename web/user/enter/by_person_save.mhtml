<%args> 
	$school
	$student_id => undef
</%args>
<%init>

	my $tourn = $school->tourn;
	my $student = Tab::Student->retrieve($student_id);

	$m->abort unless $student;

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;
	my $now = DateTime->now;

	my @entries = $m->comp("/funclib/student_entries.mas", 
		student => $student,
		tourn   => $tourn );

	my %ok_events = $m->comp("/funclib/student_clear_events.mas", 
		student => $student,
		school  => $school );

	my $hide_codes = $tourn->setting("hide_codes");

	foreach my $entry (@entries) { 

		my $event = $entry->event;

		# Code style
		my $code_style = $event->setting("code_style");

		# Titles and authors
		my $ask_for_titles = $event->setting("ask_for_titles");

		# Hybrid

		# APDA seeds
		my $apda = $event->setting("apda");

		my $max = $event->setting("max_entry");
		my $min = $event->setting("min_entry");

		#quals
		my $ask_quals = $event->setting("ask_quals");
		my $more_quals = $event->setting("more_quals");
		my $at_larges = $event->setting("at_larges");

		$entry->name($ARGS{$entry->id."_name"});

		my $err;

		if ($code_style eq "registrant" || $code_style eq "initials") { 

			my $new_code = $ARGS{$entry->id."_code"};

			if (Tab::Entry->search(code => $new_code)) { 

				$errs .= "Code $new_code is already taken in the tournament.  Please select another <br />";

			} else { 
			
				$entry->code($ARGS{$entry->id."_code"});

			}
		}

		$entry->ada($ARGS{$entry->id."_ada"});

		$entry->update;

		$entry->setting("title", $ARGS{$entry->id."_title"});
		$entry->setting("author", $ARGS{$entry->id."_author"});
		$entry->setting("registered_seed", $ARGS{$entry->id."_registered_seed"});

		my @clear_students = $m->comp("/funclib/students_evententer.mas",
			event  => $event,
			school => $school
		);

		my %clear_by_id = map {$_->id => $_} @clear_students;

		my %already_students = map {$_->id => $_} $entry->students; 

		my %used_students;

		my $deleted_students; 

		my $minimum_counter; 
		
		foreach my $tick (1 .. $max) { 

			next unless $ARGS{$entry->id."_partner_".$tick};
			next unless $clear_by_id{$ARGS{$entry->id."_partner_".$tick}};

			$minimum_counter++;

			unless ($already_students{$ARGS{$entry->id."_partner_".$tick}}) { 
				Tab::EntryStudent->create({
					entry   => $entry->id,
					student => $ARGS{$entry->id."_partner_".$tick}
				});
			}

			$used_students{$ARGS{$entry->id."_partner_".$tick}}++;

		}

		foreach my $student_id (keys %already_students) { 

			next if $used_students{$student_id};

			my $es = Tab::EntryStudent->search(
				entry => $entry->id,
				student => $student_id
			)->first;

			$deleted_students .= "," if $deleted_students;
			$deleted_students .= $student_id;

			$es->delete;
		}

		# BREAK POINT HERE

   			my $quals = $event->setting('ask_quals');
   			my $required = $quals;
   			$quals = 5 if $event->setting("more_quals");

				if ($quals) {

   			<h6>(<% $required %> Required)</h6>
				if ($event->setting("at_larges")) {
   				name  = "<% $entry->id %>_atlarge"
				}

				my @qualifiers = $entry->qualifiers;

				my $num_quals = (scalar @qualifiers) + $quals;

				foreach my $tick (1 .. $num_quals) { 

					my $qual = shift @qualifiers if @qualifiers;
   						<span class="fifth <% $tick > $required ? "" : "required" %>">
   					name="qual_<% $tick %>" 
   					value="<% $qual ? $qual->name : "" %>" 

   					name="qualpts_<% $tick %>" 
   					value="<% $qual ? $qual->result : "" %>"
				}
