<%args>
	$school
	$tourn_settings    => undef
	$event_settings    => undef
	$category_settings => undef
</%args>
<%init>

	my %reasons;

	# Rules only apply until the right person asks, then who gives a shit
	# whether it's a rule that everyone else follows, that it costs thousands
	# of dollars worth of programmer time, and introduces errors that folks
	# will later get mad about even though they were warned it would. 

	# I'm past the point of caring enough about this to do this at all
	# properly.  Besides, if I even try to do that, then the rules and
	# exemptions will change again.   So I'm just putting in a fucking button
	# that will override this, despite it going against everything I know about
	# responsible design, cause I no longer can summon one single solitary fuck
	# about this bullshit.  Keeping Tabroom design elegant in face of the
	# massive chaos and incoherency that is how the NSDA does things is
	# impossible anyway.  They killed JOT already and now are killing Tabroom
	# so what the fuck ever. 

	if ($school->setting("no_judge_warnings")) { 

	} else { 

		foreach my $category (
			$m->comp("/funclib/school_categories.mas", 
				school => $school
			) 
		) { 

			my %owed;

			if ($category->setting("nats_category")) { 

				my ($provided, $burden) = $m->comp(
					"/funclib/judgemath/nats_judging.mas",
					category          => $category,
					school            => $school,
					category_settings => $category_settings,
					tourn_settings    => $tourn_settings,
					event_settings    => $event_settings,
				);

				if ($provided->{'minimum_unmet'}) {
					$reasons{$category->id} .= "<p>".$provided->{"minimum_unmet"}." rounds short of minimum required</p>";
					$reasons{"nope"}++;
				}

				$owed{$category->id} = $burden->{"total"};
				$owed{$category->id} -= $provided->{"total"};

				$reasons{"obligation"}{$category->id} = $burden->{'total'};
				$reasons{"provided"}{$category->id} += $provided->{"total"};

				my $judge_hire = Tab::JudgeHire->search(
					category => $category->id,
					school   => $school->id
				)->first;

				if ($judge_hire) { 
					$owed{$category->id} -= $judge_hire->rounds_accepted();
					$reasons{"provided"}{$category->id} += $judge_hire->rounds_accepted();
				}

				if ($burden->{'amt'}) {

					my $amt_total;

					foreach my $jpool_id (keys %{$burden->{"amt"}}) { 
						$reasons{$category->id} .= "<p>Short ".$burden->{"amt"}{$jpool_id}." rounds in ";
						$reasons{$category->id} .= $burden->{"jpools"}{$jpool_id}{"name"};
						$amt_total += $burden->{"amt"}{$jpool_id};
					}

					if ($amt_total > $owed{$category->id}) { 
						$owed{$category->id} = $amt_total;
					}
				}

				if ($owed{$category->id} < 0) { 
					$owed{$category->id} = 0 ;
				} elsif ($owed{$category->id} > 0) { 
					$reasons{$category->id} .= "<p>".$owed{$category->id}." rounds still owed </p>";
					$reasons{"nope"}++;
				}

				my @incomplete_judges = $m->comp(
					"/funclib/nats_incomplete_judges.mas", 
					school => $school
				);

				foreach my $judge (@incomplete_judges) { 
					$reasons{$category->id} .= "<p>".$judge->first." ".$judge->last." incomplete: ".$judge->reason."</p>";
					$reasons{"nope"}++;
				}

			} else { 

				my ($uncovered, $overage, $response) = $m->comp(
					"/funclib/judgemath/uncovered_burden_by_category.mas", 
					category          => $category,
					school            => $school,
					category_settings => $category_settings,
					tourn_settings    => $tourn_settings,
					event_settings    => $event_settings,

				);
				
				$reasons{"provided"}{$category->id} = $response->{"provided"};
				$reasons{"obligation"}{$category->id} = $response->{"burden"};

				if ($uncovered) { 
					$reasons{$category->id} .= "<p> $uncovered uncovered entries</p>";
					$reasons{"nope"}++;
				}
			}
		}
	}

	if ($reasons{"nope"}) { 
		$school->setting("judging_unmet", 1);
	} else { 
		$school->setting("judging_unmet", 0);
	}

	return %reasons;

</%init>
