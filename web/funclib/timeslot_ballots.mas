<%args>
	$timeslot
	$style => undef
	$limit => undef
	$events => undef
</%args>
<%init>

	my $eventlimit;

	if ($events) {

		$eventlimit = " and event.id in (".

		my $notfirst;
		foreach my $eid (@{$events}) {
			if ($notfirst++) {
				$eventlimit .= ",";
			}
			$eventlimit .= $eid->id;
		}
		$eventlimit .= ")";
	}

	Tab::Ballot->columns(TEMP => "entrycode");
	Tab::Ballot->columns(TEMP => "roomname");
	Tab::Ballot->columns(TEMP => "lastname");
	Tab::Ballot->columns(TEMP => "firstname");
	Tab::Ballot->columns(TEMP => "code");
	Tab::Ballot->columns(TEMP => "firstname");
	Tab::Ballot->columns(TEMP => "eventabbr");
	Tab::Ballot->columns(TEMP => "eventid");
	Tab::Ballot->columns(TEMP => "sectionletter");
	Tab::Ballot->columns(TEMP => "flight");
	Tab::Ballot->columns(TEMP => "started_by");
	Tab::Ballot->columns(TEMP => "started_byf");
	Tab::Ballot->columns(TEMP => "started_byl");
	Tab::Ballot->columns(TEMP => "flighted");
	Tab::Ballot->columns(TEMP => "starttime");

	if ($style eq "unstarted") {

		my $limit;

		$limit = "and event.category = ".$ARGS{"category"}->id
			if $ARGS{"category"};

		if ($ARGS{"return"} eq "count") {

			Tab::Ballot->set_sql( count_unstarted => "

				select count(distinct(concat(panel.id, judge.id)))
				from (panel, round, ballot, judge, event, entry)
				where round.timeslot = ?
					and round.id = panel.round
					and panel.id = ballot.panel
					and ballot.judge = judge.id
					and (
						ballot.judge_started is null
						OR ballot.judge_started = '0000-00-00 00:00:00'
					)
					and ballot.entry = entry.id
					and entry.active = 1
					and ballot.bye != 1
					and ballot.forfeit != 1
					and panel.bye != 1
					and round.event = event.id
					$eventlimit
					".$limit."
			");

			return Tab::Ballot->sql_count_unstarted->select_val($timeslot->id);

		} else {

			Tab::Ballot->set_sql( by_timeslot => "

				select distinct ballot.*,
					room.name as roomname,
					judge.code as code,
					judge.last as lastname,
					judge.first as firstname,
					panel.letter as sectionletter,
					panel.flight as flight,
					event.abbr as eventabbr,
					event.id as eventid,
					round.flighted as flighted,
					ballot.judge_started as starttime,
					started_by.first as started_byf,
					started_by.last as started_byl,
					started_by.email as started_by

				from (panel, round, ballot, judge, event, entry)

				left join room on panel.room = room.id
				left join person started_by on started_by.id = ballot.started_by

				where round.timeslot = ?
				and round.id = panel.round
				and panel.id = ballot.panel
				and ballot.judge = judge.id

				and (
					ballot.judge_started is null
					OR ballot.judge_started = '0000-00-00 00:00:00'
				)

				and ballot.entry = entry.id
				and entry.active = 1

				and ballot.bye != 1
				and ballot.forfeit != 1
				and panel.bye != 1
				$eventlimit

				and round.event = event.id

				".$limit."

				group by panel.id, judge.id
				order by panel.flight, room.name
			");

			return Tab::Ballot->search_by_timeslot($timeslot->id);
		}

	} elsif ($style eq "started") {

		my $limit;

		$limit = "and event.category = ".$ARGS{"category"}->id
			if $ARGS{"category"};

		if ($ARGS{"return"} eq "count") {

			Tab::Ballot->set_sql( count_started => "

				select count(distinct(concat(panel.id, judge.id)))
				from (panel, round, ballot, judge, event, entry)

				where round.timeslot = ?
					and round.id = panel.round
					and panel.id = ballot.panel
					and ballot.judge = judge.id

					and ballot.judge_started is not null
					and ballot.judge_started > '0000-00-00 00:00:00'

					and ballot.entry = entry.id
					and entry.active = 1
					and ballot.bye != 1
					and ballot.forfeit != 1
					and panel.bye != 1
					$eventlimit

					and round.event = event.id
				".$limit."
			");

			return Tab::Ballot->sql_count_started->select_val($timeslot->id);

		} else {

			Tab::Ballot->set_sql( by_timeslot => "

				select ballot.*,
					room.name as roomname,
					judge.last as lastname,
					judge.code as code,
					judge.first as firstname,
					event.abbr as eventabbr,
					event.id as eventid,
					ballot.judge_started as starttime,
					panel.flight as flight,
					round.flighted as flighted,
					panel.letter as sectionletter,
					started_by.first as started_byf,
					started_by.last as started_byl,
					started_by.email as started_by

				from (panel, round, ballot, judge, event, entry)

				left join room on panel.room = room.id
				left join person started_by on started_by.id = ballot.started_by

				where round.timeslot = ?
				and round.id = panel.round
				and panel.id = ballot.panel
				and ballot.judge = judge.id

				and ballot.judge_started is not null
				and ballot.judge_started > '0000-00-00 00:00:00'

				and ballot.entry = entry.id
				and entry.active = 1
				and ballot.bye != 1
				and ballot.forfeit != 1
				and panel.bye != 1
				$eventlimit

				and round.event = event.id
				".$limit."
				group by judge.id, panel.id
				order by room.name
			");

			return Tab::Ballot->search_by_timeslot($timeslot->id);

		}

	} else {


		Tab::Ballot->set_sql( by_timeslot => "

			select distinct ballot.*,
				entry.code as entrycode,
				student.last as lastname,
				student.first as firstname,
				started_by.first as started_byf,
				started_by.last as started_byl,
				started_by.email as started_by

			from (panel, round, ballot, entry, event)

			left join entry_student on entry_student.entry = entry.id
			left join student on entry_student.student = student.id
			left join person started_by on started_by.id = ballot.started_by

			where ballot.panel = panel.id
				and panel.round    = round.id
				and round.timeslot = ?
				and ballot.entry   = entry.id
				and entry.dropped  = 0
				and entry.dq       = 0
				and entry.waitlist = 0
				and round.event    = event.id
				$eventlimit
			group by ballot.id
			order by panel.letter
		");

		return Tab::Ballot->search_by_timeslot($timeslot->id);

	}

</%init>
