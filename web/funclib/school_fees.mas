<%args>
	$school
	$ignore_judging    => undef
	$tourn             => undef
	$tourn_settings    => undef
	$all               => undef
	$names             => undef
	$entry_fees        => undef
	$concessions       => undef
	$payments          => undef
	$show_deleted      => undef
	$categories        => undef
	$category_settings => undef
	$events            => undef
	$concession_array  => undef
	$event_settings    => undef
	$bulk              => undef
	$schools           => undef
	$entries           => undef
</%args>
<%init>

	use POSIX;
	use Data::Dumper;

	my $total;
	my @felines;

	unless ($tourn) { 
		$tourn = $school->tourn;
		my %ts = $tourn->all_settings();
		$tourn_settings = \%ts;
	}

	my $symbol = $tourn_settings->{"currency"};
	my $school_id = $school->id;

	$entry_fees++ if $all;
	$payments++ if $all;
	$concessions++ if $all;

	my $total_entry_fees;
	my $only_entry_fees;
	my $total_concessions;
	my $total_payments;

	my $alterna_state = $tourn_settings->{"fees_alternate_state"};

	if ($alterna_state) { 
		undef $alterna_state 
			unless $school->chapter 
			&& $school->chapter->state eq $alterna_state;
	}

	if ($entry_fees && $tourn_settings->{"per_person_fee"}) { 
	
		my $individuals = $school->setting('individuals');

		my %person_line = ();

		$person_line{"fee"} = $individuals * $tourn_settings->{"per_person_fee"};

		$total += $person_line{"fee"};

		$total_entry_fees += $person_line{"fee"};
		$only_entry_fees += $person_line{"fee"};

		unless ($bulk) { 

			$person_line{"name"} = $individuals.' people at x '.$tourn_settings->{"per_person_fee"};
			$person_line{"quantity"} = $individuals;
			$person_line{"per_unit"} = $tourn_settings->{"per_person_fee"};
			$person_line{"short_name"} = "Individuals in Attendance";

			push (@felines, {%person_line});
		}
	}

	unless ($schools) {
		if ($tourn->hotels) { 
			%{$tourn_settings->{$tourn->id}{"hotels"}} = map {$_->id => $_} $tourn->hotels();
			$schools->{"hotels"}{$school_id} = $school->setting('hotel');
		}
	}

	my $judging_fees;

	if ($entry_fees) { 

		my @entries;

		@entries = @{$entries} if $entries;

		unless (@entries || $bulk) { 

			Tab::Entry->set_sql( with_event => "
				select entry.*, entry.event as eventid, event.category as categoryid
				from entry, event
				where entry.school = ? 
				and entry.unconfirmed = 0
				and entry.event = event.id
				and not exists (	
					select entry_setting.id
					from entry_setting
					where entry_setting.entry = entry.id
					and entry_setting.tag = 'rejected_by'
				)
			");

			@entries = Tab::Entry->search_with_event($school_id);
		}

		my %entries_by_event;
		my %entries_by_category;

		foreach my $entry (@entries) { 
			if ($entry->waitlist) { 
				push @{$entries_by_event{$entry->eventid}{"waitlist"}}, $entry;
				push @{$entries_by_category{$entry->categoryid}{"waitlist"}}, $entry;
			} else { 
				push @{$entries_by_event{$entry->eventid}{"confirmed"}}, $entry;
				push @{$entries_by_category{$entry->categoryid}{"confirmed"}}, $entry;
			}
		}

		my $hotel_multiplier;
		my $hotel;

		if ($tourn_settings->{$tourn->id}{"hotels"}) { 
			$hotel = $tourn_settings->{$tourn->id}{"hotels"}{$schools->{"hotel"}{$school_id}};
			$hotel_multiplier = $hotel->multiple if $hotel;
		}

		unless ($bulk) { 

			if ($hotel && $hotel_multiplier > 1) { 

				my %hotel_warning = ();

				$hotel_warning{"name"} = "You are marked as staying at ".$hotel->name.".  Your entry fees are therefore adjusted by ".$hotel->multiple."x";

				$hotel_warning{"message"}++;
				push @felines, \%hotel_warning;

			}
		}

		my @events;

		@events = @{$events} if $events;
		@events = $tourn->events unless @events;

		EVENT:
		foreach my $event (@events) { 

			my $event_id = $event->id;

			my @entries;
			
			@entries = @{$entries_by_event{$event_id}{"confirmed"}}
				if $entries_by_event{$event_id}{"confirmed"};

			push @entries, @{$entries_by_event{$event_id}{"waitlist"}}
				if $tourn_settings->{"invoice_waitlist"}
				&& $entries_by_event{$event_id}{"waitlist"};

			if ($ARGS{"worlds_event"} 
				&& $ARGS{"worlds_event"}->id == $event_id
			) { 
				push @entries, @{$schools->{"worlds"}{$school_id}} if (
					$schools
					&& $schools->{"worlds"}
					&& $schools->{"worlds"}{$school_id}
				);
			}

			next unless @entries;
		
			unless ($event_settings->{$event_id}) { 
				%{$event_settings->{$event_id}} = $event->all_settings();
				$event_settings->{$event_id}{"fee"} = $event->fee;
			}

			my $fee_per = $event_settings->{$event_id}{"fee"};

			$fee_per = $event_settings->{$event_id}{"alt_state_fee"} 
				if $alterna_state
				&& $event_settings;

			$fee_per = $event->setting("alt_state_fee") 
				if $alterna_state
				&! $event_settings;
				
			my $fee_total = $fee_per * scalar @entries;
			$fee_total = $fee_total * $hotel_multiplier if $hotel_multiplier > 1;


			next EVENT unless $fee_total;

			$total_entry_fees += $fee_total;
			$only_entry_fees += $fee_total;
			$total += $fee_total;

			unless ($bulk) { 

				my $name = scalar @entries. " entries in ".$event->abbr.' x '.$fee_per;

				$fee_per = sprintf("%.2f", $fee_per);

				my %line_hash= ();

				$line_hash{"quantity"} = scalar @entries;
				$line_hash{"per_unit"} = $fee_per;
				$line_hash{"short_name"} = "Entries in ".$event->name;
				$line_hash{"name"} = $name;
				$line_hash{"fee"} = $fee_total;

				push (@felines, {%line_hash});

			}
		}



		if ($tourn_settings->{"nsda_nats"} &! $bulk) { 
		
			foreach my $event ($tourn->events()) { 

				next unless $event->setting("usa_wsdc");

				Tab::Student->set_sql( school_wsdc => "
					select distinct student.id
					from student, entry_student, entry
					where entry.event = ?
					and entry.id = entry_student.entry
					and entry_student.student = student.id
					and student.chapter = ? 
				");

				my @worlds_students = Tab::Student->search_school_wsdc( 
					$event->id, 
					$school->chapter->id 
				);

				if (@worlds_students) { 

					my $count = scalar @worlds_students;
					my $fee_per = $event->fee;

					my $fee_total = $fee_per * $count;
					$fee_total = $fee_total * $hotel_multiplier if $hotel_multiplier > 0;

					if ($fee_total) { 

						$total_entry_fees += $fee_total;
						$only_entry_fees += $fee_total;
						$total += $fee_total;

						unless ($bulk) { 

							my $name = "$count competitors in ".$event->abbr.' x '.$fee_per;

							$fee_per = sprintf("%.2f", $fee_per);

							my %line_hash= ();

							$line_hash{"quantity"} = $count;
							$line_hash{"per_unit"} = $fee_per;
							$line_hash{"short_name"} = "Students in ".$event->name;
							$line_hash{"name"} = $name;
							$line_hash{"fee"} = $fee_total;

							push (@felines, {%line_hash});

						}
					}
				}
			}
		}


		unless ($ignore_judging) { 
		

			my @categories;
			@categories = @{$categories} if $categories;
			@categories = $tourn->categories unless @categories;

			GROUP:
			foreach my $category (@categories) { 

				my $category_id = $category->id;

				next unless $entries_by_category{$category_id}{"confirmed"}
					|| ($entries_by_category{$category_id}{"waitlist"}
					 	&& $tourn_settings->{"judges_waitlist"});

				unless ($category_settings->{$category_id}) { 
					%{$category_settings->{$category_id}} = $category->all_settings();
					@{$category_settings->{$category_id}{"shifts"}}
						= $category->shifts(type => "strike");
				}
			
				my $rounds_per = $category_settings->{$category_id}{"rounds_per"};
				$rounds_per++ if $category_settings->{$category_id}{"nats_category"};

				my $judge_per = $category_settings->{$category_id}{"judge_per"};
				my $attending_judge_fee = $category_settings->{$category_id}{"attending_judge_fee"}; 


				if ($category_settings->{$category_id}{"drops_no_burden"}) { 

					my @undropped;

					foreach my $entry (@{$entries_by_category{$category_id}{"confirmed"}}) { 
						push @undropped, $entry unless $entry->dropped;
					}

					@{$entries_by_category{$category_id}{"confirmed"}} = @undropped;

				}

				my $extra;
				my $uncovered;

				if ($category_settings->{$category_id}{"nats_category"} && $bulk) { 
				
					Tab::debuglog("Bulk is $bulk!");


					my $fee = $category_settings->{$category_id}{"round_hire_fee"};

					if ($fee) { 

						foreach my $hire (@{$schools->{"hires"}{$school_id}{$category_id}}) { 

							my $accepted = $hire->rounds_accepted;

							if ($accepted) { 
								$total_entry_fees += $accepted * $fee;
								$total += $accepted * $fee;
								$judging_fees += $accepted * $fee;
							}
						}
						
						undef @{$schools->{"hires"}{$school_id}{$category_id}};
					} 

				} elsif ($category_settings->{$category_id}{"nats_category"}) { 

					my ($provided, $burden) = $m->comp(
						"/funclib/judgemath/nats_judging.mas",
						category          => $category,
						school            => $school,
						category_settings => $category_settings->{$category_id},
						tourn_settings    => $tourn_settings,
						event_settings    => $event_settings,
					);

					my @jpools = $m->comp(
						"/funclib/category_jpools.mas",
						category => $category,
						limit   => "registrant"
					);

					foreach my $jpool (@jpools) { 
						$uncovered += ($burden->{$jpool->id} - $provided->{$jpool->id});
					}

					my $judge_hire = Tab::JudgeHire->search(
						category => $category->id,
						school   => $school->id
					)->first;

					$uncovered -= $judge_hire->rounds_accepted if $judge_hire;

					undef $extra;

					if ($provided->{'minimum_unmet'} &! $tourn_settings->{"nsda_nats"}) { 

						# because who needs to follow our own rules?  

						my %minimum_hash;

						$minimum_hash{"name"} = "No judging for a minimum ";
						$minimum_hash{"name"} .= $category_settings->{$category_id}{"minimum_supplied"};
						$minimum_hash{"name"} .= " rounds committment provided";
	
						$minimum_hash{"fee"} = $category_settings->{$category_id}{"minimum_supplied_fine"};
						$minimum_hash{"short_name"} = "Judge Minimum";
						push (@felines, {%minimum_hash});

						$total_entry_fees += $minimum_hash{"fee"};
						$total += $minimum_hash{"fee"};
						$judging_fees += $minimum_hash{"fee"};

					}

				} else { 


					($uncovered, $extra ) = $m->comp(
						"/funclib/judgemath/uncovered_burden_by_category.mas", 
						category          => $category,
						category_settings => $category_settings->{$category_id},
						tourn_settings    => $tourn_settings,
						event_settings    => $event_settings,
						judges            => $schools->{"judges"}{$school_id}{$category_id},
						hires             => $schools->{"hires"}{$school_id}{$category_id},
						school            => $school,
						confirmed         => $entries_by_category{$category_id}{"confirmed"},
						waitlist          => $entries_by_category{$category_id}{"waitlist"},
						bulk              => $bulk
					);
				}

				if ($attending_judge_fee) { 

					my %judge_fee_hash;

					my @judges;
					
					if ($schools->{"judges"}{$school_id}) { 

						@judges = @{$schools->{"judges"}{$school_id}{$category_id}};
					
					} else {

						@judges = $school->judges(category => $category_id);
					}

					unless ($bulk) { 

						if (@judges) { 
							$judge_fee_hash{"name"} = scalar @judges.' individual judges at x ';
							$judge_fee_hash{"name"} .= $attending_judge_fee;
						}

						$judge_fee_hash{"fee"} = 
							scalar @judges * $attending_judge_fee 
							if @judges;

						$judge_fee_hash{"quantity"} = scalar @judges;
						$judge_fee_hash{"per_unit"} = $attending_judge_fee;
						$judge_fee_hash{"short_name"} = "Judges in Attendance";
					
						push (@felines, {%judge_fee_hash});

					}

					$total_entry_fees += $judge_fee_hash{"fee"};
					$total += $judge_fee_hash{"fee"};
					$judging_fees += $judge_fee_hash{"fee"};

				} 
				
				if ($category_settings->{$category_id}{"track_judge_hires"}) {

					my ($requests, $total_accepted) = $m->comp(
						'/funclib/school_hires.mas', 
						school            => $school,
						category          => $category,
						category_settings => $category_settings->{$category_id},
						hires             => $schools->{"hires"}{$school_id}{$category_id},
						bulk              => $bulk
					);

					my @adjustments;
					my %adjustments;
					my %hired_fee = ();

					if ($tourn_settings->{"adjustments"}) { 

						%adjustments = $m->comp(
							"/funclib/judge_hire_adjustments.mas", 
							school            => $school,
							category          => $category,
							category_settings => $category_settings->{$category_id},
							hires             => $schools->{"hires"}{$school_id}{$category_id}
						);


						@adjustments = sort {$b <=> $a} keys %adjustments;

					}

					push @adjustments, 0; 

					my $adjustment_amount;

					foreach my $adjustment (@adjustments) { 

						my $accepted = $total_accepted; 

						if ($adjustment == 0) { 

							$accepted = $total_accepted; 
						
						} else { 
							$accepted = $adjustments{$adjustment};
							$accepted = $total_accepted if $accepted > $total_accepted;
							$total_accepted -= $accepted; 
						}

						if ($category_settings->{$category_id}{"round_hire_fee"}) { 

							my $fee = $category_settings->{$category_id}{"round_hire_fee"};
							$fee = $fee + ($fee * ($adjustment / 100));

							if ($accepted ) { 

								$hired_fee{"fee"} = $accepted * $fee;
								$total_entry_fees += $accepted * $fee;
								$total += $accepted * $fee;
								$judging_fees += $accepted * $fee;

								unless ($bulk) { 

									$hired_fee{"name"} = $accepted." rounds hired judging in ";
									$hired_fee{"name"} .= $category->name.'. '. $fee." each";

									$hired_fee{"quantity"} = $accepted;
									$hired_fee{"per_unit"} = $fee;
									$hired_fee{"short_name"} = "Rounds of ".$category->abbr." hired judging";
									push (@felines, {%hired_fee});

								}

							}

						} elsif ($category_settings->{$category_id}{"hired_fee"}) { 

							$accepted = ceil($accepted / $judge_per) if $judge_per;

							my $fee = $category_settings->{$category_id}{"hired_fee"};
							$fee = $fee + ($fee * ($adjustment / 100));
				
							if ($accepted ) { 

								$hired_fee{"fee"} = $accepted * $fee;
								$total += $accepted * $fee;
								$total_entry_fees += $accepted * $fee;
								$judging_fees += $accepted * $fee;

								unless ($bulk) { 

									$hired_fee{"name"} = $accepted." hired judges for ".$category->name.' at '.$fee." each";

									$hired_fee{"quantity"} = $accepted;
									$hired_fee{"per_unit"} = $fee;
									$hired_fee{"short_name"} = $category->abbr." hired judges";
									push (@felines, {%hired_fee});
								}

							}
				
						} elsif ($category_settings->{$category_id}{"uncovered_entry_fee"}) { 
						
							my $fee = $category_settings->{$category_id}{"uncovered_entry_fee"};
							$fee = $fee + ($fee * ($adjustment / 100));

							if ($accepted ) { 

								my $entry = "entries";
								$entry = "entry" if $accepted == 1;

								$hired_fee{"fee"} = $accepted * $fee;
								$total += $accepted * $fee;
								$total_entry_fees += $accepted * $fee;
								$judging_fees += $accepted * $fee;

								unless ($bulk) { 

									$hired_fee{"name"} = "$accepted $entry covered by hires in ";
									$hired_fee{"name"} .= $category->name.' at ';
									$hired_fee{"name"} .= $fee." each";


									$hired_fee{"quantity"} = $accepted;
									$hired_fee{"per_unit"} = $fee;
									$hired_fee{"short_name"} = $category->abbr." entries covered by hired judging";
									push (@felines, {%hired_fee});

								}
							}
						}
					}

					# If there are still missing judges despite the hires, warn the
					# user and invalidate the invoice if that's not OK
				
					if ($uncovered > 0) {

						my %judge_fee_hash = ();

						$uncovered = ceil($uncovered / $judge_per) if $judge_per;

						if ($category_settings->{$category_id}{"missing_judge_fee"}) { 

							if ($rounds_per) { 

								$judge_fee_hash{"fee"} = 
									$uncovered 
									* $category_settings->{$category_id}{"missing_judge_fee"};

								$total += $judge_fee_hash{"fee"};
								$total_entry_fees += $judge_fee_hash{"fee"};
								$judging_fees += $judge_fee_hash{"fee"};

								unless ($bulk) { 

									my $round = "round";
									$round .= "s" if $uncovered != 1;

									$judge_fee_hash{"name"} = "Missing $uncovered $round in ".$category->name;
									$judge_fee_hash{"quantity"} = $uncovered;
									$judge_fee_hash{"per_unit"} = $category_settings->{$category_id}{"missing_judge_fee"};
									$judge_fee_hash{"short_name"} = $category->abbr." uncovered rounds of judging";
								}


							} elsif ($judge_per) { 
						

								$judge_fee_hash{"fee"} = 
									$uncovered * $category_settings->{$category_id}{"missing_judge_fee"};

								$total += $judge_fee_hash{"fee"};
								$total_entry_fees += $judge_fee_hash{"fee"};
								$judging_fees += $judge_fee_hash{"fee"};

								unless ($bulk) { 

									my $judge = "judge";
									$judge .= "s" if $uncovered != 1;
									$judge_fee_hash{"name"} = "Missing $uncovered $judge in ".$category->name;

									$judge_fee_hash{"quantity"} = $uncovered;
									$judge_fee_hash{"per_unit"} = $category_settings->{$category_id}{"missing_judge_fee"};
									$judge_fee_hash{"short_name"} = $category->abbr." judges under obligation";
								}

							}

						} else { 

							unless ($bulk) { 

								$judge_fee_hash{"warn"}++;

								if ($judge_per) { 
									$judge_fee_hash{"name"} = "WARNING: You are under by $uncovered judges ";
									$judge_fee_hash{"name"} .= "in ".$category->name.". Hire or register ";
									$judge_fee_hash{"name"} .= "more judges to cover your obligation by ";
									$judge_fee_hash{"name"} .= "the deadline, or the tournament may ";
									$judge_fee_hash{"name"} .= "reject your entry.";
								} elsif ($rounds_per) { 
									$judge_fee_hash{"name"} = "WARNING: You are under by $uncovered rounds in ";
									$judge_fee_hash{"name"} .= $category->name." judging. Hire or register more ";
									$judge_fee_hash{"name"} .= "rounds to cover your obligation, or the ";
									$judge_fee_hash{"name"} .= "tournament may reject your entry";
								}
							}
						}

						push (@felines, {%judge_fee_hash});
				
					}

				} elsif ($uncovered > 0) {

					my %judge_fee_hash = ();

					$uncovered = ceil($uncovered / $judge_per) if $judge_per > 0;

					$judge_fee_hash{"fee"} = $uncovered 
						* $category_settings->{$category_id}{'missing_judge_fee'};

					$judge_fee_hash{"warn"} = 1;

					$total += $judge_fee_hash{"fee"};
					$total_entry_fees += $judge_fee_hash{"fee"};
					$judging_fees += $judge_fee_hash{"fee"};

					unless ($bulk) { 

						if ($judge_per) { 

							$judge_fee_hash{"name"}  = "WARNING: You are missing $uncovered judge(s) ";
							$judge_fee_hash{"name"} .= "in ".$category->name;
							
							if ($category_settings->{$category_id}{'missing_judge_fee'}) { 
								$judge_fee_hash{"name"} .= "This fine does not ";
								$judge_fee_hash{"name"} .= "necessarily count for a hired judge ";
								$judge_fee_hash{"name"} .= "depending on the tournament's policies.";
							}

						} elsif ($rounds_per) { 

							$judge_fee_hash{"name"} = "WARNING: You are missing $uncovered round(s) ";
							$judge_fee_hash{"name"} .= "in ".$category->name;
							
							if ($category_settings->{$category_id}{'missing_judge_fee'}) { 
								$judge_fee_hash{"name"} .= "This fine does not necessarily count";
								$judge_fee_hash{"name"} .= "as a hired judge; request hired rounds,";
								$judge_fee_hash{"name"} .= "register judges or reduce your entry.";
							}

						}

						push (@felines, {%judge_fee_hash});
					}

				}

				if ($category_settings->{$category_id}{"shifts"}) { 

					my %stimes_under = $m->comp(
						"/funclib/judgemath/judge_partials_short.mas", 
						category          => $category,
						category_settings => $category_settings->{$category_id},
						event_settings    => $event_settings,
						tourn_settings    => $tourn_settings,
						school            => $school,
						confirmed         => $entries_by_category{$category_id}{"confirmed"},
						waitlist          => $entries_by_category{$category_id}{"waitlist"},
						judges            => $schools->{"judges"}{$school_id}{$category_id},
						hires             => $schools->{"hires"}{$school_id}{$category_id},
						shifts			  => $category_settings->{$category_id}{"shifts"},
						bulk              => $bulk
					);

					foreach my $key (keys %stimes_under) {

						my $stime = Tab::JudgeShift->retrieve($key);

						next unless $stimes_under{$stime->id} > 0;

						if ($stime->no_hires) { 

							my %judge_fee_hash = ();
							$judge_fee_hash{"name"} .= "WARNING: You are under judge obligation by ";
							$judge_fee_hash{"name"} .= $stimes_under{$stime->id}." judge(s) in ";
							$judge_fee_hash{"name"} .= $category->name." ".$stime->name;

							$judge_fee_hash{"warn"} = 1;
							push (@felines, {%judge_fee_hash});

						} 
						
						if ($stime->fine) { 
						
							my %stime_fine = ();
							$stime_fine{"fee"}  =  $stime->fine * $stimes_under{$stime->id};
							$total += $stime->fine * $stimes_under{$stime->id};
							$total_entry_fees += $stime->fine * $stimes_under{$stime->id};
							$judging_fees += $stime->fine * $stimes_under{$stime->id};

							unless ($bulk) { 

								$stime_fine{"name"} = $stimes_under{$stime->id}." ".$category->name;
								$stime_fine{"name"} .= "judges under in ".$stime->name." at ".$stime->fine." each";

								$stime_fine{"quantity"} = $stimes_under{$stime->id};
								$stime_fine{"per_unit"} = $stime->fine;
								$stime_fine{"short_name"} = "Judges under obligation in ".$stime->name;
								push (@felines, {%stime_fine});

							}
						} 
					}	
				}	
			} #end of foreach group
		} 
	} 

	if ( $entry_fees && 
		(	$tourn_settings->{"per_student_fee"}
			|| $tourn_settings->{$tourn->id}{"hotels"}
		)
	) { 

		my $hotel;
		my $hotel_surcharge;

		if ($tourn_settings->{$tourn->id}{"hotels"}) { 
			$hotel = $tourn_settings->{$tourn->id}{"hotels"}{$schools->{"hotel"}{$school_id}};
			$hotel_surcharge = $hotel->surcharge if $hotel;
		}

		if ($tourn_settings->{"per_student_fee"} || $hotel_surcharge ) { 

			my @students = $m->comp(
				"/funclib/school_students.mas", 
				school   => $school,
				waitlist => $tourn_settings->{"invoice_waitlist"}
			);

			if ($tourn_settings->{"per_student_fee"}) { 

				my %student_line = ();

				$student_line{"fee"} = (scalar @students) * $tourn_settings->{"per_student_fee"};

				$total += $student_line{"fee"};
				
				$total_entry_fees += $student_line{"fee"};
				$only_entry_fees += $student_line{"fee"};

				unless ($bulk) { 

					$student_line{"name"} = scalar @students.' individual students at x '.$tourn_settings->{"per_student_fee"};
					$student_line{"quantity"} = scalar @students;
					$student_line{"per_unit"} = $tourn_settings->{"per_student_fee"};
					$student_line{"short_name"} = "Students in Attendance";

					push (@felines, {%student_line});

				}
			}
			
			if ($hotel_surcharge) { 

				my %surcharge_line = ();

				$surcharge_line{"fee"} = (scalar @students) * $hotel_surcharge;

				$total += $surcharge_line{"fee"};
				$total_entry_fees += $surcharge_line{"fee"};
				$only_entry_fees += $surcharge_line{"fee"};

				unless ($bulk) { 

					if ($surcharge_line{"fee"} > 0) { 

						$surcharge_line{"name"} = "Hotel surcharge: ".scalar @students.' competitors staying outside the block x '.$hotel_surcharge; 
						$surcharge_line{"short_name"} = "Block hotel discount";
					} else { 

						$surcharge_line{"name"} = "Hotel discount: ".scalar @students.' competitors in the block x '.$hotel_surcharge; 
						$surcharge_line{"short_name"} = "Non-block hotel surcharge";
					}

					$surcharge_line{"quantity"} = scalar @students;
					$surcharge_line{"per_unit"} = $hotel_surcharge;

					push (@felines, {%surcharge_line});

				}
			}
		}
	}

	my @all_orders;
	my %concessions_by_code;

	if ($concessions) { 

		my @concessions;

		@concessions = @{$concession_array} if $concession_array;
		@concessions = $tourn->concessions unless @concessions;

		if ($bulk) { 

			foreach my $order_id (keys %{$schools->{'orders'}{$school_id}}) { 
				$total += $schools->{"orders"}{$school_id}{$order_id}{"total"};
				$total_concessions += $schools->{"orders"}{$school_id}{$order_id}{"total"};
				
				Tab::debuglog("Order $order_id total concessions is $total_concessions") if $school_id == 214196;

			}

		} else { 

			foreach my $concession (@concessions) {

				my @orders = Tab::ConcessionPurchase->search( 
					school     => $school_id,
					concession => $concession->id 
				);

				my $quantity;

				foreach my $order (@orders) { 
					$quantity += $order->quantity;
				}
			
				next unless $quantity;

				$total += $quantity * $concession->price;
				$total_concessions += $quantity * $concession->price;

				push @all_orders, @orders;
				my %line = ();

				$line{"name"} = $quantity." ".$concession->name." at ".$concession->price." each";
				$line{"fee"} = $quantity * $concession->price;

				$line{"quantity"} = $quantity;
				$line{"per_unit"} = $concession->price;
				$line{"short_name"} = $concession->name;

				if ($concession->billing_code) { 
					$line{"billing_code"} = $concession->billing_code;
					$concessions_by_code{$concession->billing_code} += ($quantity * $concession->price);
				}

				push (@felines, {%line});
			}
		}
	}

	my @fines;
	my $fine_total;
	my $bond_total;

	if ($entry_fees || $payments) { 

		my @all_fines;
		
		@all_fines = @{$schools->{"fines"}{$school_id}} 
			if $schools
			&& $schools->{"fines"}
			&& $schools->{"fines"}{$school_id};

		@all_fines = Tab::Fine->search(
			school => $school_id
		) unless $bulk || @all_fines;

		foreach my $fine (@all_fines) { 

			next if ( (not defined $show_deleted) && $fine->deleted);
			next if ( (not defined $entry_fees) && $fine->payment == 0);
			next if ( (not defined $payments) && $fine->payment != 0);

			push @fines, $fine;

		}

		FINE: 
		foreach my $fine (@fines) { 

			my %fine_hash;

			unless ($bulk) { 

				my $reason = $fine->reason;

				$fine_hash{"name"} .= $reason;
				$fine_hash{"short_name"} .= $reason;
				$fine_hash{"nsda_invoice"} = $fine->invoice;

				if ($fine->deleted) { 

					$fine_hash{"deleted"}++;

					$fine_hash{"name"} .= " deleted at "
						if $fine->deleted_at;

					$fine_hash{"name"} .= &Tab::niceshortdt($fine->deleted_at->set_time_zone($tourn->tz)) 
						if $fine->deleted_at;

					$fine_hash{"name"} .= " by ". $fine->deleted_by->first." ".$fine->deleted_by->last  
						if $fine->deleted_by && $names;

				} else { 

					$fine_hash{"name"} .= " recorded "
						if $fine->levied_at;

					$fine_hash{"name"} .= &Tab::eurodate($fine->levied_at->set_time_zone($tourn->tz)) 
						if $fine->levied_at;

					$fine_hash{"name"} .= " by ". $fine->levied_by->first." ".$fine->levied_by->last  
						if $fine->levied_by && $names;
				}
			
				$fine_hash{"fine_id"} = $fine->id;
				$fine_hash{"fee"} = $fine->amount;

				push (@felines, {%fine_hash});
			}


			next if $fine->deleted;

			if ($fine->payment > 0) { 
				$total_payments += $fine->amount;
			} else { 

				$total_entry_fees += $fine->amount;

				if (lc($fine->reason) eq "judge bond") { 
					$bond_total += $fine->amount;
				} else { 
					$fine_total += $fine->amount;
				}
			}

			$total += $fine->amount();

		} # end of foreach fine

	} 

	my %totals = ();

	if ($all) { 
		$totals{"entries"}     = $only_entry_fees;
		$totals{"entry_fees"}  = $total_entry_fees;
		$totals{"concessions"} = $total_concessions;
		$totals{"total_fees"}  = $total_concessions + $total_entry_fees;
		$totals{"payments"}    = $total_payments;
		$totals{"judges"}      = $judging_fees;
		$totals{"bond"}        = $bond_total;
		$totals{"fines"}       = $fine_total;

		$totals{"concessions_by_code"} = \%concessions_by_code;
	}

	return ($total, \@felines, \%totals, \@fines, \@all_orders, $judging_fees);

</%init>
