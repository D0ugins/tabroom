<%args>
	$event
	$school  => undef
	$chapter => undef
	$debug   => undef
	$drops   => undef
	$retired => undef
</%args>
<%init>

	my $tourn = $event->tourn;

	$m->redirect('/user/home.mhtml') unless $tourn;

	my $double_entry = $tourn->setting("double_entry");
	my $double_max = $tourn->setting("double_max");

	if (defined $double_max && $double_max == 0) { 
		undef $double_entry;
		undef $double_max;
	}

	my $alumni = $event->setting("alumni");
	my $supp = $event->setting("supp");
	my $pattern = $event->pattern;
	my $ed_exclude = $event->pattern->exclude if $event->pattern;
	
	my @clean_students;
	my @students;

	my $wsdc = $tourn->setting("usa_wsdc");

	if ($wsdc && not defined $school->chapter) { 

		foreach my $entry ($school->entries) { 
			push @students, $entry->students;
		}

	} else { 

		$chapter = $school->chapter if $school;
		@students = sort {ucfirst $a->last cmp ucfirst $b->last} $chapter->students;
	}

	#Check the students to be sure that they're not entered in an event restricted against this one.

	my $now = DateTime->now;
	my $year = $now->year;
	$year++ if $now->month > 6;

	my %entry_by_id = ();
	my @entries = $school->entries if $school;
	foreach my $entry (@entries) { 
		$entry_by_id{$entry->id} = $entry;
	}

	Tab::EntryStudent->set_sql(by_chapter => "
		select distinct entry_student.*
		from entry_student, entry, student, event
		where entry.id = entry_student.entry
		and entry_student.student = student.id
		and student.chapter = ?
		and entry.event = event.id
		and event.tourn = ? 
		");

	my %entries_by_student = ();

	unless ($wsdc) { 
		foreach my $entry_student (Tab::EntryStudent->search_by_chapter($chapter->id, $tourn->id)) { 
			push (@{$entries_by_student{$entry_student->student->id}}, $entry_by_id{$entry_student->entry->id});
		}
	}

	my %double_by_event = ();

	foreach my $event ($m->comp("/funclib/tourn_events.mas", tourn => $tourn)) { 
		$double_by_event{$event->id} = $event->pattern;
	}

	STUDENT:
	foreach my $student (@students) { 

		#Students who aren't students anymore.
		unless ($retired) { 
			next STUDENT if $student->retired;
			next STUDENT unless $student->first && $student->last;
			next STUDENT if $student->grad_year && $student->grad_year < $year && not defined $alumni;
		}

		#Class specific double entry restrictions 
		my @entries = @{$entries_by_student{$student->id}} if $entries_by_student{$student->id};

		#Supplementals are only open to students entered in the tournament
		next STUDENT if $supp &! @entries;

		my %pattern_scoreboard = ();

		foreach my $entry (@entries) { 
			next unless $entry && $entry->id;
			$pattern_scoreboard{$double_by_event{$entry->event->id}}++;
		}

		my $entered;

		foreach my $entry (@entries) { 

			next unless $entry && $entry->id;
			my $event_id = $entry->event->id;

			unless ($entry->dropped || $entry->waitlist) { 

				# Am I already entered in this event?
				next STUDENT if $event_id == $event->id && not defined $event->setting("enter_me_twice");

				# Am I already entered in the tournament and in off the waitlist? 
				$entered++;

				# No double entry permitted if you're entered in this pattern and that's not ok
				next STUDENT if $pattern && $pattern->type == 2 && $entered;  


				#No double entry with a mutually-excluded group
				next STUDENT if $ed_exclude &&  $entry->event->pattern && $entry->event->pattern->id == $ed_exclude->id;


				if ($double_by_event{$event_id}) { 

					# No double entry permitted if you're already entered and the new pattern forbids double entry
					next STUDENT if $double_by_event{$event_id}->type == 2;

					#No double entry within the pattern
					next STUDENT if $double_by_event{$event_id}->type == 1 && 
							($pattern && $double_by_event{$event_id}->id == $pattern->id);  

					#No double entry beyond a limit within the pattern
					next STUDENT if ($double_by_event{$event_id}->type == 3) && 
						($pattern && $double_by_event{$event_id}->id == $pattern->id 
							&& $pattern_scoreboard{$pattern->id} >= $pattern->max); 

					#No double entry if the other pattern excludes mine
					next STUDENT if ( $double_by_event{$event_id}->exclude && $pattern && ($double_by_event{$event_id}->exclude->id == $pattern->id)   );

				}
			}
		}

		#Unlimited double entry
		push (@clean_students, $student) if $double_entry eq "unlimited";
		next STUDENT if $double_entry eq "unlimited";

		#No double entry
		next STUDENT if ($entered > 0 && $double_entry eq "none"); 

		#One event double entry
		next STUDENT if ($double_entry eq "max_events" && $entered >= $double_max);
	
		push (@clean_students, $student);
	}	

	return @clean_students;
	
</%init>
