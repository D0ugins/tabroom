<%args>
	$event
	$all => undef
</%args>
<%init>

	return if $event->setting('weekend') eq "nope";
	return if $event->setting('nsda_event_category') eq "108";

	my $tourn = $event->tourn;

	return unless $tourn->setting('nsda_district');

	my ($num_qualifiers, $num_alternates, $num_active) = $m->comp(
		"/funclib/nsda_qualifier_count.mas",
			event => $event
		);

	my %qualifiers;
	my $final = $event->rounds(
		type => "final"
	)->first;

	if ($event->abbr ne "HOU" || $final)  {

		my $result_set = Tab::ResultSet->search(
			event => $event->id,
			label => "District Qualifiers"
		)->first;

		return unless $result_set;

		my $counter;
		my $quantity = 1;
		my $last_rank;
		my $last_entry;

		RESULT:
		foreach my $result (
			sort {$a->rank <=> $b->rank}
			$result_set->results
		) {

			$counter++;
            my @values;
			my $place;

			Tab::debuglog("Result $result tick 1");

            foreach my $value ($result->values) {
                next if $value->priority < 1;
				if ($value->tag eq "Place") {
					$place = $value;
				} else {
                	push @values, $value;
				}
            }

			Tab::debuglog("Result $result tick 2");

			my $rank;

			if ($place) {
				$rank = $place->value;
			} else {
				$rank = $result->rank;
			}

			my $entry = $result->entry();
			my $vacate = $entry->setting('nsda_vacate');

			Tab::debuglog("Result $result tick 3");
			Tab::debuglog("Quantity is $quantity and num_quals is $num_qualifiers");

			if ($vacate) {

				Tab::debuglog("Result $result vacated! ");
				next RESULT if $quantity > $num_qualifiers;

			} elsif ($quantity == $num_qualifiers) {

				$last_rank = $rank;
				$last_entry = $entry;

				Tab::debuglog("Result is the last qualifier");

			} elsif ($quantity > $num_qualifiers) {

				Tab::debuglog("Quantity is $quantity and num_quals is $num_qualifiers");

				if ($last_rank == $rank) {
					push @{$qualifiers{"ties"}{$rank}}, $entry;
					push @{$qualifiers{"ties"}{$rank}}, $last_entry;
				} else {
					next RESULT;
				}
			}

			Tab::debuglog("Result $result tick 4");

			$qualifiers{$counter}{"rank"}  = $rank;
			$qualifiers{$counter}{"entry"} = $entry;
			$qualifiers{$counter}{"vacated"}++ if $vacate;

            my $tiebreaks;

            foreach my $value (
				sort {$a->priority <=> $b->priority}
				@values
			) {
				$qualifiers{$counter}{"tag"}{$value->priority}     = $value->tag;
				$qualifiers{$counter}{"descs"}{$value->priority}   = $value->description;
				$qualifiers{$counter}{"results"}{$value->priority} = $value->value;
			}

			Tab::debuglog("Result $result tick 5");

			foreach my $student ($entry->students) {

				push @{$qualifiers{$counter}{"students"}}, $student;

				$qualifiers{$counter}{$student->id}{"ineligible"}++
					unless $student->nsda;

				$qualifiers{$counter}{"ineligible"}++
					unless $student->nsda;
			}

			unless (
				$qualifiers{$counter}{"vacated"}
				|| $qualifiers{$counter}{"ineligible"}
				|| $all
			) {
				$quantity++;
			}

			Tab::debuglog("Result $result tick 6");
		}

	} elsif ($event->abbr eq "HOU") {

		my @rounds = sort {$b->name <=> $a->name} $event->rounds();
		next unless @rounds;

		my $last_round = shift @rounds;

		my $num_slots = 2;
		$num_slots = 1 if $event->setting('nsda_qual_nohousepilot');

		$m->comp("/funclib/clear_empty_panels.mas", round => $last_round);

		my @panels = $last_round->panels();

		unless (@panels) {
			$m->comp("/funclib/abort.mas",
				message => "You are trying to post results when the last round of ".$event->abbr.", ".$last_round->realname.", has no chambers.  Please clear empty, non used sessions before posting results"
			);
		}

		foreach my $chamber (@panels) {

			my $counter;
			my $quantity = 1;
			my $code = ": H".$chamber->letter;

			my $result_set  = Tab::ResultSet->search(
				label => "District Qualifiers".$code,
				tourn => $tourn,
				event => $event
			)->first;

			if (scalar @panels == 1 && (not defined $result_set)) {
				$result_set  = Tab::ResultSet->search(
					label => "District Qualifiers",
					tourn => $tourn,
					event => $event
				)->first;
			}

			next unless $result_set;
			my $last_rank;
			my $last_entry;

			RESULT:
			foreach my $result (
				sort {$a->rank <=> $b->rank}
				$result_set->results()
			) {

				$counter++;
				my $tag = $code."-".$counter;

				my $entry = $result->entry;
				my $vacate = $entry->setting('nsda_vacate');

				my $place;
				my @values;

				foreach my $value ($result->values) {
					next if $value->priority < 1;
					if ($value->tag eq "Place") {
						$place = $value;
					} else {
						push @values, $value;
					}
				}

				my $rank;

				if ($place) {
					$rank = $place->value;
				} else {
					$rank = $result->rank;
				}

				if ($vacate) {
					next RESULT if $quantity > $num_slots;
				} elsif ($quantity == $num_slots) {
					$last_rank = $rank;
					$last_entry = $entry;
				} elsif ($quantity > $num_slots) {
					if ($last_rank == $rank) {
						push @{$qualifiers{"ties"}{$rank}}, $entry;
						push @{$qualifiers{"ties"}{$rank}}, $last_entry;
					} else {
						next RESULT;
					}
				}

				$qualifiers{$tag}{"rank"}  = $rank;
				$qualifiers{$tag}{"entry"} = $entry;
				$qualifiers{$tag}{"vacated"}++ if $vacate;

				my $tiebreaks;

				foreach my $value (
					sort {$a->priority <=> $b->priority}
					@values
				) {
					$qualifiers{$tag}{"tag"}{$value->priority}     = $value->tag;
					$qualifiers{$tag}{"descs"}{$value->priority}   = $value->description;
					$qualifiers{$tag}{"results"}{$value->priority} = $value->value;
				}

				foreach my $student ($entry->students) {

					push @{$qualifiers{$tag}{"students"}}, $student;

					$qualifiers{$tag}{$student->id}{"ineligible"}++
						unless $student->nsda;

					$qualifiers{$tag}{"ineligible"}++
						unless $student->nsda;
				}

				unless (
					$qualifiers{$tag}{"vacated"}
					|| $qualifiers{$tag}{"ineligible"}
					|| $all
				) {
					$quantity++;
				}
			}
		}
	}

	return %qualifiers;

</%init>
